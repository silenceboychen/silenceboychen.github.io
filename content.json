{"meta":{"title":"blog","subtitle":"morty's blog","description":"morty的个人博客","author":"morty","url":"https://www.silenceboy.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-09-27T07:27:40.433Z","updated":"2021-09-27T07:27:40.433Z","comments":false,"path":"/404.html","permalink":"https://www.silenceboy.com//404.html","excerpt":"","text":""},{"title":"关于我","date":"2025-08-11T12:10:13.189Z","updated":"2025-08-11T12:10:13.189Z","comments":false,"path":"about/index.html","permalink":"https://www.silenceboy.com/about/index.html","excerpt":"","text":"简介 姓名：陈浩 17839718588（微信同） | silenceboychen@gmail.com https://github.com/silenceboychen 博客： https://www.silenceboy.com/ 河南大学 | 软件工程 | 本科 | 2012 - 2016 工作经验: 10年 核心技术能力 AI产品开发： 3年专业AI工具开发经验，掌握Function Calling、MCP（Model Context Protocol）、A2A（Agent-to-Agent）等核心技术的底层实现原理，能够基于这些技术构建智能化的产品解决方案 AI辅助开发： 熟练使用Cursor、Claude Code等前沿AI编码工具，通过AI辅助显著提升研发效率，在代码生成、调试优化、架构设计等环节实现智能化工作流 产品架构能力： 具备完整的产品全生命周期管理经验，包括产品需求分析、技术方案设计、业务架构规划等核心能力。近三年专注于AI产品领域，主导多个AI相关产品的规划设计和落地实施 产品创新能力： 具备从0到1构建AI产品的完整经验，能够将前沿AI技术转化为具有商业价值的产品方案 技术栈深度：10年+开发经验，以Node.js为核心技术栈，Python为辅助语言，在服务端架构、API设计、数据处理等方面具备一定的技术积累 工作经验亿咖通科技有限公司（2020.03-至今）经历过多次部门调整，参与和负责过不同的业务产品，主要分为3个阶段，按照时间倒序说明： 阶段三（AI工具链开发）负责全球研发中心的AI工具需求开发，目前担任AI工具组的Scrum Master。主要负责以下工作： 需求挖掘：与全球研发中心下的其他二级部门密切协作，基于目前的开发流程，分析可以使用AI工具提效的场景 知识分享：多次组织AI相关的技术分享会，推动研发对AI知识和工具的了解 产品规划：负责AI工具链产品规划、业务规划以及产品目标设定 业务洞察：深入理解业务逻辑和用户需求，将业务目标转化为技术实现方案 期间深入结合研发需求实现的产品有： 研发助手-代码生成详设：详细设计编写耗时耗力，结合研发的业务场景，深度分析后，搭建了代码生成详设项目，详设符合Aspice要求，目前支持C/C++/Java/Kotlin 4种语言，已经正式投入使用。 研发助手-代码生成单元测试：Aspice对单测覆盖率要求100%，导致单测的编写工作量巨大，引入AI进行提效，目前针对Java/Kotlin版本已经完成初步功能，部分研发在使用，C/C++版本还在技术验证中。 Jira-MCP：使用MCP技术实现了jira系统的MCP服务，能够接入Cursor等AI工具进行语义化jira操作。 阶段二（工具链开发）负责OS研发中心工具链开发，虚线管理研发人员：10+。主要负责以下工作： 团队管理：负责服务端团队管理，工作分配和任务管理 架构设计：负责工具链产品的技术架构设计 产品规划：负责工具链产品规划、业务规划以及产品目标设定 绩效评估：建立客观的绩效评价体系，定期进行团队成员绩效反馈 期间深入结合研发需求实现的产品有： 日志智能分析工具：提出了结合jira系统的日志识别浏览器插件产品方案，快速吸引大量用户，并接入AI智能分析，jirabug自动查重等功能，目前日活：200+、月活400+用户 模拟器：使用qemu模拟器技术，实现了对设备的模拟，并能够基于模拟器控制台模拟车机信号数据，进行快速的研发自测，解决设备不足问题 WEB IDE：基于VSCode开源代码进行二次开发，符合安全要求，研发通过WEB IDE连接堡垒机后的服务器进行代码开发，提升研发效率。 代码规范检查和自动修复插件：基于MISRA-C规范进行代码自动扫描，接入gpt-4o模型，进行AI自动修复，提升研发手动修复效率。 阶段一（开发者平台）担任开发者平台研发部服务端开发经理，团队成员：15+。主要负责以下工作： 团队管理：负责服务端团队管理，工作分配和任务管理 架构设计：采用微服务架构设计思想，提升项目开发效率和可维护性 技术规范制定：制定代码规范、开发流程标准、技术选型原则，确保团队技术栈的统一性和代码质量 性能优化：监控系统性能指标，制定性能优化策略，确保系统稳定性和可扩展性 项目规划：参与产品需求评审，制定开发计划和里程碑，合理分配开发资源 风险管控：识别项目风险点，制定应对措施，确保项目按时交付 质量保障：建立完善的测试流程，推进自动化测试，确保交付质量 人才培养：制定团队成员成长计划，提供技术指导和职业发展建议 招聘面试：参与技术人员招聘，评估候选人技术能力和团队匹配度 绩效评估：建立客观的绩效评价体系，定期进行团队成员绩效反馈 杭州基本起源信息科技有限公司（2019.07-2020.03）线上购物app。主要负责以下工作： 团队管理：负责服务端团队管理，合理分配工作 架构设计：采用微服务架构设计思想，进行服务端架构设计 接口开发：负责系统核心业务接口开发 基础运维：负责公司项目的运维工作，搭建CI/CD系统，所有项目docker化部署，自动运维 万汇互联（深圳）科技有限公司（2017.05-2019.05）贵金属外汇交易平台。主要负责以下工作： 团队管理：负责服务端团队管理，合理分配工作 架构设计：使用RPC技术实现微服务架构，Consul管理微服务 接口开发：负责平台大部分接口开发 基础建设：封装日志系统及RPC相关方法供全项目使用 容器化：负责所有Node.js项目Docker化 流程规范：按照dev→beta→production严格开发流程 技术分享：部门内多次技术分享 部署自动化：引入docker-compose技术，实现项目一键部署 深圳点猫科技有限公司（2015.09-2017.05）基于图形化的少儿编程在线教育平台。主要负责以下工作： 团队管理：负责服务端团队管理，合理分配工作 需求评审：参与产品功能评审，整理项目需求 架构设计：负责后端项目架构设计，数据库表结构设计 技术推广：项目内推广使用 TypeScript 文档管理：监督团队使用 API Doc 或 Swagger 编写接口文档 运维保障：负责维护服务正常访问和数据库连接 容器化部署：负责项目 Docker 化，编写 Dockerfile 和 docker-compose.yml 在校经历 担任计算机学院创新实验室负责人 负责学校多个学院的官网制作和维护 自我评价 热爱计算机行业，热爱编程，追求代码质量，不畏挑战。 求知欲强、为新技术和自我提升而自豪。 责任心强，高效且有质量的完成工作。"},{"title":"Repositories","date":"2021-09-27T07:27:40.458Z","updated":"2021-09-27T07:27:40.458Z","comments":false,"path":"repository/index.html","permalink":"https://www.silenceboy.com/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-09-27T07:27:40.450Z","updated":"2021-09-27T07:27:40.450Z","comments":false,"path":"books/index.html","permalink":"https://www.silenceboy.com/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-27T07:27:40.458Z","updated":"2021-09-27T07:27:40.458Z","comments":false,"path":"tags/index.html","permalink":"https://www.silenceboy.com/tags/index.html","excerpt":"","text":""},{"title":"爱","date":"2021-09-27T07:27:40.458Z","updated":"2021-09-27T07:27:40.458Z","comments":false,"path":"love/index.html","permalink":"https://www.silenceboy.com/love/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-27T07:27:40.450Z","updated":"2021-09-27T07:27:40.450Z","comments":false,"path":"categories/index.html","permalink":"https://www.silenceboy.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-09-27T07:27:40.457Z","updated":"2021-09-27T07:27:40.457Z","comments":true,"path":"links/index.html","permalink":"https://www.silenceboy.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"SSE与Streamable HTTP：MCP 背后的传输技术","slug":"SSE与Streamable-HTTP：MCP-背后的传输技术","date":"2025-08-27T03:06:46.000Z","updated":"2025-08-27T06:47:45.749Z","comments":true,"path":"2025/08/27/SSE与Streamable-HTTP：MCP-背后的传输技术/","link":"","permalink":"https://www.silenceboy.com/2025/08/27/SSE与Streamable-HTTP：MCP-背后的传输技术/","excerpt":"","text":"MCP 使用的传输协议背后的历史MCP（模型上下文协议）是当今最流行、应用最广泛的人工智能协议之一，它从 2025-03-26 版本开始，用 Streamable HTTP 取代了 HTTP+SSE 传输机制。这标志着该协议架构的重大变革。 现在，在解释这两种传输机制的含义之前，让我们先更好地理解这一变化。 为什么AI协议需要传输机制像 MCP 这样的 AI 协议需要传输机制来促进协议架构中不同组件之间的信息交换。 具体来说，MCP 使用 JSON-RPC 2.0 作为客户端和服务器之间的连接格式。对于 JSON-RPC 消息的传输，它依赖于标准传输机制，如 HTTP+SSE 或 Streamable HTTP（在 stdio 中 - 用于通过本地服务器上的标准输入和标准输出进行通信）。 这些专用的传输层是必需的，因为传统 HTTP 的请求-响应模型对于实时 AI 通信来说效率低下。这是因为纯 HTTP 频繁建立连接会导致高开销和延迟。相比之下，MCP 需要连续、低延迟的数据流——HTTP+SSE 和 Streamable HTTP 正是为此而设计的。 为什么从 SSE 转变到 Streamable HTTPMCP 最初使用 HTTP+SSE 来实现远程场景下的服务器到客户端的流式传输。然而，以下三个主要限制使得这一改变变得合理： 不支持可恢复流：无法从断开处恢复数据流。 需要维护长连接：服务器需要维护长时间的、高可用的连接，消耗资源，尤其是在大 规模部署时。 仅允许通过 SSE 传递服务器消息：客户端必须使用单独的 HTTP POST 请求发送消息， 无法在同一通道内双向通信。 Streamable HTTP 解决了这些问题。它支持无状态通信，甚至支持按需升级到 SSE。这提高了与现代基础设施的兼容性，并确保了更稳定、更高效的通信。同时，这一转变体现了 MCP 在追求以下目标： 提升可伸缩性：通过支持无状态服务器和减少长连接依赖，MCP 能够更好地应对大规模并发请求，为 AI 服务的爆发式增长提供坚实基础。 增强鲁棒性：可恢复流的引入，使得 MCP 在面对不稳定的网络环境时，依然能够保证数据传输的可靠性，减少因网络问题导致的数据丢失或服务中断。 优化资源利用：减少长连接的维护成本，使得服务器资源能够更高效地分配和利用，降低运营成本。 拥抱未来趋势：Streamable HTTP 与现代 Web 技术栈和云原生架构更加契合，为 MCP 未来的发展和与其他技术的融合提供了更广阔的空间。 SSESSE（Server-Sent Events）是一种允许 Web 客户端从服务器接收自动更新的机制。这些更新被称为“事件”，并通过单个长寿命 HTTP 连接发送。 与WebSockets 不同，SSE 是单向的，这意味着数据仅从服务器流向客户端。SSE 的工作原理是服务器通过此开放连接发送事件流，通常格式为text/event-streamMIME类型。 在 MCP 中使用 HTTP+SSE 服务器必须提供两个端点： 客户端用于建立连接并从服务器接收消息的 SSE GET 端点。 客户端向服务器发送 JSON-RPC 消息的常规 HTTP POST 端点。 当客户端连接时，服务器必须发送一个端点事件，其中包含客户端将用于发送消息的 URI。所有客户端 JSON-RPC 消息都将作为 HTTP POST 请求发送到此 URI。 服务器通过打开的 SSE 连接发送流式事件来响应，模拟持久会话。具体来说，服务器消息以 SSE 消息事件的形式传递，其内容在事件数据中以 JSON 格式编码。 对于单个响应，服务器发送消息并关闭流。对于正在进行的通信，连接保持打开状态。 优点和缺点优点： 流式传输大量结果：允许立即发送部分结果，允许立即发送部分结果，避免 MCP 工具处理大量数据或等待外部 API 响应时的延迟。 事件驱动触发器：支持未经请求的服务器事件，通过警报或状态更新通知客户端有关更改。 简单：使用标准 HTTP，无需特殊协议或复杂设置。 缺点： 仅限单向：数据只能在 SSE 通道中从服务器流向客户端。客户端必须使用单独的 HTTP POST 请求来发送消息。 长连接资源使用：维护开放连接会消耗大量服务器资源，尤其是在大规模连接时。 Streamable HTTP在 MCP 的语境中，Streamable HTTP 是一种使用纯 HTTP 在客户端和服务器之间传输流式数据的方法。它为实时通信打开了大门，无需长连接。 虽然它仍然可以使用 SSE 来实现灵活性和向后兼容性，但不再需要该传输方式。这使得 MCP 能够支持无状态服务器，而无需维护高可用性持久连接的开销。 为什么是Streamable HTTP + 可选 SSE 而不是 WebSockets？ 避免不必要的开销：对于简单的 RPC 调用或数据流，WebSocket 的全双工特性可能引入不必要的协议开销和复杂性。Streamable HTTP 在保持流式传输能力的同时，更加轻量。 更好的 HTTP 兼容性：WebSocket 的协议升级机制有时会与现有的 HTTP 基础设施（如代理、负载均衡器）产生兼容性问题，并且浏览器无法直接在 WebSocket 连接上附加 HTTP 头（如 Authorization）。Streamable HTTP 则完全兼容 HTTP，避免了这些问题。 POST 请求的灵活性：WebSocket 的升级握手主要基于 GET 请求，这使得基于 POST 的复杂交互流程实现起来较为繁琐。Streamable HTTP 则对 POST 和 GET 请求都提供了良好的支持。 在 MCP 中使用 Streamable HTTP在 Streamable HTTP 传输中，服务器作为一个独立进程，能够处理多个客户端连接。它使用标准的 HTTP POST 和 GET 请求进行通信。 服务器可以选择使用 SSE 将多条消息流式传输到客户端。这既适用于用于简单请求/响应工具的基本 MCP 服务器，也适用于提供更高级功能（例如流式传输和实时服务器到客户端通知）的服务器。 服务器必须公开一个支持 POST 和 GET 方法的 HTTP 端点（称为 “MCP 端点“）。 下图说明了使用 Streamable HTTP 的 MCP 客户端和服务器之间的通信流程： 为了支持恢复断开的连接并重新传递可能丢失的消息，MCP 服务器会为每个流分配 ID。这些 ID 在每个流中充当游标。 优点和缺点优点： 支持无状态服务器：无需始终在线的长连接。 纯 HTTP：可以使用任何标准 HTTP 服务器实现，而无需 SSE。 基础设施友好：与常见的 HTTP 中间件、代理和托管平台兼容。 向后兼容：在以前的 HTTP+SSE 传输基础上逐步构建。 可选流式传输：服务器可在需要时升级为 SSE，以实现流式传输响应。 解决 SSE 局限性：支持可恢复流，无需维护长连接，且允许客户端和服务器在同一 HTTP 端点进行通信（通过 POST 和 GET）。 效率更高：对于大负载或自定义二进制协议，数据传输更高效，没有 SSE 的事件格式 开销。 更强的控制力：应用可以更精细地控制缓冲策略，可能减少内存开销。 缺点： 暂无 SSE 与Streamable HTTP对比 类型 HTTP+SSE Streamable HTTP 通信类型 单向（服务器→客户端） 双向（客户端通过 GET/POST ↔ 服务器） HTTP 协议的使用 GET 用于流媒体，POST 用于客户端信息 从一个端点使用标准 HTTP POST 和 GET 状态性 有状态 有状态，但支持无状态服务器 需要长期 HTTP 连接 是 否 要求高可用性 是，用于连接持久性 否，适用于无状态或临时服务器 可扩展性 有限 高 流媒体支持 是（通过文本/事件流） 是（通过 SSE 作为可选增强功能） 身份验证支持 是 是 支持可恢复性和重新交付 没有 没有 客户数量 多个 多个 在 MCP 中的使用 自协议版本 2025-03-26 起已弃用 在 2025-03-26 版协议中引入 向后兼容性 - 完全向后兼容基于 SSE 的客户端","categories":[{"name":"mcp","slug":"mcp","permalink":"https://www.silenceboy.com/categories/mcp/"}],"tags":[{"name":"mcp","slug":"mcp","permalink":"https://www.silenceboy.com/tags/mcp/"},{"name":"AI","slug":"AI","permalink":"https://www.silenceboy.com/tags/AI/"}]},{"title":"命令帮手：tldr 安装与中文配置指南","slug":"命令帮手：tldr-安装与中文配置指南","date":"2025-05-09T05:39:38.000Z","updated":"2025-05-09T05:50:09.722Z","comments":true,"path":"2025/05/09/命令帮手：tldr-安装与中文配置指南/","link":"","permalink":"https://www.silenceboy.com/2025/05/09/命令帮手：tldr-安装与中文配置指南/","excerpt":"","text":"在日常开发与运维过程中，你是否会觉得传统的 man 手册过于繁琐？tldr 项目正是为了解决这个问题而生，它为上百个常用命令提供了简明直观的示例，极大地提升了查阅效率。本文将手把手介绍 tldr 在 Windows、Mac、Ubuntu 下的安装流程，基本使用方法，以及如何让 tldr 输出为简体中文。 一、tldr 安装方法1. Windows 系统方法一：用 Scoop 安装（推荐） 安装 Scoop（如果还没装）： 12Set-ExecutionPolicy RemoteSigned -Scope CurrentUserirm get.scoop.sh | iex 安装 tldr： 1scoop install tldr 方法二：用 npm 安装需先装好 Node.js 与 npm，然后在命令行执行：1npm install -g tldr 方法三：用 pip 安装需先装好python与pip，然后在命令行执行：1pip3 install tldr 2. macOS 系统推荐使用 Homebrew： 1brew install tldr 或者用 npm： 1npm install -g tldr 或者用 pip： 1pip3 install tldr 3. Ubuntu / Debian 系统推荐方式（snap 安装）： 1sudo snap install tldr 或者用 apt（部分老版本仓库没有）： 12sudo apt updatesudo apt install tldr 还可以用 npm： 1npm install -g tldr 或者用 pip： 1pip3 install tldr 二、tldr 的基本使用安装好 tldr 后，在命令行中直接输入： 1tldr 命令名 例如：1tldr tar 它会显示 tar 常用的简要用法和示例。 常用选项： tldr -u强制更新离线文档缓存。 tldr --list查看有哪些命令有 tldr 页面。 tldr --help查看 tldr 的详细帮助信息。 三、配置 tldr 显示中文页面tldr 官方已支持多语言，目前大部分主流命令已有简体中文文档。只需调整默认语言环境变量即可。 1. 临时使用中文只对当前命令生效： 1LANG=zh tldr ls 或（部分 tldr 客户端支持）1LANGUAGE=zh tldr ls 2. 永久设置为中文macOS / Ubuntu / WSL将下方内容添加到 ~/.bashrc 或 ~/.zshrc（具体看你用哪个 shell）： 1export LANG=zh 保存后，执行一次：1source ~/.bashrc # 或 source ~/.zshrc 这样每次开新终端，tldr 默认输出中文页面。 Windows（CMD 或 PowerShell）CMD 中临时生效：12set LANG=zhtldr ls 长期生效：在系统环境变量或用户环境变量中添加 LANG，值填 zh。 3. 更新缓存（非常重要）修改语言后，强烈建议刷新缓存让中文页面生效： 1tldr -u 4. 验证效果运行：1tldr cp 如果出现中文简明用法，表明配置成功。 四、常见问题 部分命令还是英文？可能该命令尚未有中文翻译。同样建议及时更新缓存。 未知命令提示或无法联网？检查网络或采用 tldr --update 手动补全离线缓存。 Windows 环境变量生效问题？尝试重启终端或电脑，确认语言变量设置无误。 五、总结tldr 是极简而实用的命令行速查工具，无论软件开发者还是 Linux/Unix/Windows 运维者都能从中获益。通过简单的安装和配置，你就能轻松查阅常见命令的简明用法，还能设为汉语输出，降低理解难度，为高效开发助力。 扩展阅读： 官方网站：https://tldr.sh/ GitHub 项目：https://github.com/tldr-pages/tldr","categories":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/tags/shell/"}]},{"title":"Python魔法方法介绍","slug":"Python魔法方法介绍","date":"2025-04-25T06:34:11.000Z","updated":"2025-04-25T06:35:45.791Z","comments":true,"path":"2025/04/25/Python魔法方法介绍/","link":"","permalink":"https://www.silenceboy.com/2025/04/25/Python魔法方法介绍/","excerpt":"","text":"1. 什么是魔法方法魔法方法是指前后都有双下划线的特殊方法，例如 init、new、str 等。这些方法是 Python 内部预定义的，将它们以特定名字命名，是为了配合 Python 的特性（如对象创建、属性访问、运算符重载等）实现自定义行为。 2. 常见魔法方法类别与功能a) 对象的构造与销毁 魔法方法 作用描述 常用场景 __new__ 实例创建，返回一个新对象 单例、元类、自定义创建流程 __init__ 实例初始化，设置属性等 常规对象初始化 __del__ 实例删除前调用（析构函数） 资源释放、日志等 b) 字符串与可打印表现 魔法方法 作用描述 常用场景 __str__ str(obj)、print(obj) 时的表现 用户友好信息 __repr__ repr(obj)、调试器、解释器中直接输入对象时的表现 开发调试、复现对象 c) 运算符重载使实例自定义如何参与各种运算： 魔法方法 覆盖的运算符 例子 __add__ + a + b __sub__ - a - b __mul__ * a * b __truediv__ / a / b __floordiv__ // a // b __mod__ % a % b __pow__ ** a ** b __eq__ == a == b __ne__ != a != b __lt__ &lt; a &lt; b __gt__ &gt; a &gt; b __le__ &lt;= a &lt;= b 还有很多，比如逻辑运算（__and__, __or__ 等）、反向运算（如 __radd__)等。 d) 集合与映射接口用于容器类的自定义： 魔法方法 作用描述 使用方式 __len__ 求长度 len(obj) __getitem__ 获取指定元素 obj[key] __setitem__ 设置值 obj[key]=value __delitem__ 删除项 del obj[key] __contains__ in/not in 查询 item in obj __iter__ 返回迭代器 for x in obj __next__ 迭代器的下一个值 next(iterator) e) 上下文管理 魔法方法 作用描述 使用方式 __enter__ 进入上下文、with块前调用 with obj as xxx __exit__ 离开上下文、with块后调用 f) 可调用对象相关 魔法方法 作用描述 示例 __call__ 让实例像函数一样可调用 obj() g) 其他常用魔法方法 __getattr__ / __setattr__ / __delattr__：属性访问/设置/删除拦截。 __slots__：限制对象可以有哪些属性，提高内存效率。 3. 魔法方法功能对比表 方法 调用时机/作用 返回值须 是否常用 __new__ 创建对象（类-&gt;实例） 实例 or 其子类 部分场景 __init__ 初始化对象 None 常用 __del__ 删除对象时 None 偶尔 __str__ str/print str 常用 __repr__ repr()，交互式解释器 str 常用 __add__ a+b 任意 按需 __getitem__ obj[key] 任意 按需 __call__ obj() 任意 有趣/高阶 __enter__ with 块开始 任意 按需 __exit__ with 块结束 None/Bool 按需 4. 总结 魔法方法本质上让我们可以“像内置类型一样”自定义自己的类行为。 它们不需要显式调用，由 Python 语法环境/运算符/函数自动调用。 合理地使用魔法方法，可以让自己的类表现得更“Pythonic”，增加灵活性、可读性与可用性。 不是所有魔法方法都需要重写，按需选择。 举例说明： 123456789101112class Vector2D: def __init__(self, x, y): self.x, self.y = x, y def __add__(self, other): return Vector2D(self.x + other.x, self.y + other.y) def __str__(self): return f\"(&#123;self.x&#125;, &#123;self.y&#125;)\"v1 = Vector2D(1,2)v2 = Vector2D(3,4)print(v1 + v2) # 自动调用 __add__（输出：(4, 6)）print(str(v1)) # 自动调用 __str__（输出：(1, 2)）","categories":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"}]},{"title":"取消conda终端默认激活base虚拟环境","slug":"取消conda终端默认激活base虚拟环境","date":"2025-04-09T10:20:02.000Z","updated":"2025-04-09T10:20:52.786Z","comments":true,"path":"2025/04/09/取消conda终端默认激活base虚拟环境/","link":"","permalink":"https://www.silenceboy.com/2025/04/09/取消conda终端默认激活base虚拟环境/","excerpt":"","text":"默认情况下，安装完conda后，每次打开终端都会自动激活base环境。如果你不习惯这一行为，可以通过修改conda的相关配置，使终端启动时不再默认激活base环境。 ▶️ 临时关闭 auto activate (当前终端有效)如果你只是想一次性临时地关闭，可以运行： 1conda deactivate 但是这种方式仅对当前打开的终端临时生效，打开新的终端窗口时，base还是会自动激活。 ✅ 长期永久关闭默认激活 (推荐)要永久关闭每次终端自动激活base环境，可以运行： 1conda config --set auto_activate_base false 以上命令会修改conda配置文件~/.condarc，添加如下内容： 1auto_activate_base: false 以后你每次打开新的终端窗口时，base将不会再自动激活。 📝 如果你后悔了，如何恢复自动激活base？再次启用自动激活： 1conda config --set auto_activate_base true 🔍 验证你的配置执行以下命令验证： 1conda config --show | grep auto_activate_base 输出： 1auto_activate_base: false 代表成功地关闭了默认激活行为。 ⚠️ 注意： 在关闭默认激活之后，如果想激活base或其他虚拟环境，就需要手动运行： 12conda activate base #激活baseconda activate env_name #激活其他环境 按照以上方法，你便可以自由控制conda是否默认激活base环境了。","categories":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"}]},{"title":"python项目批量检查依赖并添加进requirements文件","slug":"python项目批量检查依赖并添加进requirements文件","date":"2025-04-09T01:38:13.000Z","updated":"2025-04-09T09:04:46.010Z","comments":true,"path":"2025/04/09/python项目批量检查依赖并添加进requirements文件/","link":"","permalink":"https://www.silenceboy.com/2025/04/09/python项目批量检查依赖并添加进requirements文件/","excerpt":"","text":"在Python项目中，管理依赖是很重要的工作。下面我介绍几种方法，可以帮助你批量检查项目依赖并更新requirements文件。 1. 使用pipreqs自动生成requirements.txtpipreqs是一个很好的工具，它能分析你的代码并只生成项目实际使用的依赖列表。 12345# 安装pipreqspip install pipreqs# 在项目根目录运行pipreqs . --force # --force选项会覆盖已存在的requirements.txt 这个工具的优点是它只包含代码中实际导入的包，而不是环境中安装的所有包。 2. 使用pip-tools管理依赖pip-tools提供了两个命令：pip-compile和pip-sync，可以更精确地管理依赖。 123456789# 安装pip-toolspip install pip-tools# 创建一个requirements.in文件，列出主要依赖# 然后生成详细的requirements.txtpip-compile requirements.in# 保持环境与requirements.txt同步pip-sync 这种方法的优点是可以区分直接依赖和间接依赖，并且锁定所有包的版本。 3. 检查项目中缺少的依赖可以使用pylint或其他静态分析工具来查找可能缺少的导入： 12345# 安装pylintpip install pylint# 扫描项目pylint --disable=all --enable=no-name-in-module,import-error path/to/your/project 4. 自动化脚本示例你可以创建一个脚本来自动执行这些步骤： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python3\"\"\"自动检查和更新项目依赖，并添加到requirements.txt文件\"\"\"import osimport subprocessimport sysdef main(): \"\"\"主函数\"\"\" # 确保pip-tools已安装 try: import piptools except ImportError: print(\"安装 pip-tools...\") subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"pip-tools\"]) # 使用pipreqs分析项目依赖 try: import pipreqs except ImportError: print(\"安装 pipreqs...\") subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"pipreqs\"]) # 生成临时requirements文件 print(\"分析项目依赖...\") subprocess.check_call([\"pipreqs\", \".\", \"--savepath\", \"requirements.temp.txt\", \"--force\"]) # 读取现有的requirements.txt (如果存在) existing_reqs = set() if os.path.exists(\"requirements.txt\"): with open(\"requirements.txt\", \"r\") as f: for line in f: line = line.strip() if line and not line.startswith(\"#\"): existing_reqs.add(line.split(\"==\")[0]) # 读取新生成的requirements new_reqs = [] with open(\"requirements.temp.txt\", \"r\") as f: for line in f: line = line.strip() if line and not line.startswith(\"#\"): new_reqs.append(line) # 合并并分类 main_deps = [] for req in new_reqs: pkg_name = req.split(\"==\")[0] if pkg_name not in existing_reqs: main_deps.append(f\"&#123;req&#125; # 新添加的依赖\") else: main_deps.append(req) # 写入最终的requirements.txt with open(\"requirements.txt\", \"w\") as f: f.write(\"# 主要依赖 - 项目直接使用\\n\") for dep in sorted(main_deps): f.write(f\"&#123;dep&#125;\\n\") f.write(\"\\n# 根据实际需要添加开发和测试依赖\\n\") # 清理临时文件 os.remove(\"requirements.temp.txt\") print(\"完成! requirements.txt 已更新。\")if __name__ == \"__main__\": main() 将这个脚本保存为update_requirements.py，然后运行： 1python update_requirements.py 5. 整合进Makefile如果你的项目使用Makefile，可以添加一个目标来更新依赖： 1234567.PHONY: update-depsupdate-deps: @echo \"更新项目依赖...\" pip install pipreqs pipreqs . --force @echo \"依赖已更新到requirements.txt\" 6. 对于复杂项目的建议对于有多个环境的复杂项目： 使用pyproject.toml配合setuptools或poetry管理依赖 区分开发依赖和运行时依赖 使用虚拟环境确保依赖隔离 1234# 使用poetrypoetry init # 创建pyproject.tomlpoetry add package1 package2 # 添加依赖poetry export -f requirements.txt --output requirements.txt # 导出requirements.txt 7. 检查未使用的依赖可以使用pip-extra-reqs工具检查未使用的依赖： 12pip install pip-extra-reqspip-extra-reqs src/ 通过以上步骤，你可以有效地管理项目依赖，确保requirements.txt文件包含所有必要的依赖，同时避免添加不必要的包。无论项目规模大小，这些方法都能帮助你保持依赖的清晰和最新。","categories":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"}]},{"title":"本地管理多个python版本","slug":"本地管理多个python版本","date":"2025-03-26T12:13:54.000Z","updated":"2025-04-09T09:04:36.161Z","comments":true,"path":"2025/03/26/本地管理多个python版本/","link":"","permalink":"https://www.silenceboy.com/2025/03/26/本地管理多个python版本/","excerpt":"","text":"在本地管理多个 Python 版本是开发中的常见需求，以下是几种主流且高效的方法，适用于不同操作系统： 一、使用 pyenv（推荐给 macOS/Linux 用户）原理：通过修改环境变量动态切换 Python 版本，不依赖系统自带的 Python。 1. 安装 pyenv1234567# 使用安装脚本curl https://pyenv.run | bash# 将以下内容添加到 ~/.bashrc 或 ~/.zshrcexport PATH=\"$HOME/.pyenv/bin:$PATH\"eval \"$(pyenv init -)\"eval \"$(pyenv virtualenv-init -)\" 2. 常用命令1234567891011121314151617# 查看可安装版本pyenv install --list# 安装指定版本（如 Python 3.9.6）pyenv install 3.9.6# 列出已安装版本pyenv versions# 设置全局默认版本pyenv global 3.9.6# 设置当前目录的本地版本（优先级更高）pyenv local 3.8.12# 卸载版本pyenv uninstall 3.7.0 二、使用 conda（跨平台，适合科学计算场景）原理：通过虚拟环境管理 Python 版本和依赖。 1. 安装 Miniconda/Anaconda从官网下载安装包：https://docs.conda.io/en/latest/miniconda.html 2. 创建不同 Python 版本的环境1234567891011121314# 创建名为 py38 的环境，指定 Python 3.8conda create -n py38 python=3.8# 激活环境conda activate py38# 查看所有环境conda env list# 退出环境conda deactivate# 删除环境conda env remove -n py38 三、使用 Docker（适合隔离开发环境）通过容器化技术隔离不同项目环境。 示例 Dockerfile12345FROM python:3.7-slimWORKDIR /appCOPY requirements.txt .RUN pip install -r requirements.txtCMD [\"python\", \"app.py\"] 使用不同镜像版本12# 运行 Python 3.9 容器docker run -it --rm python:3.9-alpine python --version 四、Windows 用户的替代方案 pyenv-win（类似 Unix 的 pyenv）： 123# 安装命令Invoke-WebRequest -UseBasicParsing -Uri \"https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1\" -OutFile \"./install-pyenv-win.ps1\"&amp; \"./install-pyenv-win.ps1\" 手动安装多个版本： 从官网下载不同版本的安装包（如 python-3.8.exe 和 python-3.10.exe） 安装时勾选 “Add to PATH”，但通过修改可执行文件名区分版本：12# 将 Python 3.8 的可执行文件重命名mv /path/to/python3.8/python.exe /path/to/python3.8/python38.exe 五、通用技巧：虚拟环境 + 版本指定即使使用系统 Python，也可通过 venv 或 virtualenv 隔离环境：123456# 使用特定 Python 版本创建虚拟环境/path/to/python3.9 -m venv myenv# 激活环境source myenv/bin/activate # Linux/macOSmyenv\\Scripts\\activate.bat # Windows 版本管理工具对比 工具 适用系统 特点 pyenv macOS/Linux 轻量级，纯命令行操作 conda 跨平台 集成包管理，适合科学计算 Docker 跨平台 完全环境隔离，但需学习容器技术 手动管理 所有系统 灵活性高，但维护成本较高 选择工具时，建议优先使用 pyenv（Unix）或 conda（跨平台）以简化操作。","categories":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"}]},{"title":"pip自动写入requirements的终极方案","slug":"pip自动写入requirements的终极方案","date":"2025-03-21T04:50:53.000Z","updated":"2025-03-21T04:52:40.422Z","comments":true,"path":"2025/03/21/pip自动写入requirements的终极方案/","link":"","permalink":"https://www.silenceboy.com/2025/03/21/pip自动写入requirements的终极方案/","excerpt":"","text":"在Python开发中，手动维护requirements.txt文件容易遗漏依赖项。本文将介绍三种自动化解决方案，让依赖管理更高效。 方案一：智能Shell别名（原生pip增强）实现原理： 通过Shell函数封装pip命令，在执行安装后自动更新requirements文件 配置方法（在.bashrc/.zshrc中添加）： 1234567pip() &#123; if [ \"$1\" = \"install\" ]; then command pip \"$@\" &amp;&amp; pip freeze --exclude-editable | grep -v '^#' &gt; requirements.txt else command pip \"$@\" fi&#125; 使用示例：12345678# 安装包并自动记录pip install requests==2.26.0# 安装多个包（支持所有pip参数）pip install django~=3.2.0 celery[redis]# 开发模式安装（不会记录到requirements）pip install -e . 方案特点： ✅ 零依赖，纯Shell实现 🛡️ 排除-e安装的本地包 🔍 自动过滤注释行 ⚠️ 注意：会覆盖原有requirements文件 方案二：pip-autosave工具（专业级自动记录）安装使用：1pip install pip-autosave 使用场景：12345678# 基础用法（自动生成requirements.txt）pip install requests --save# 指定保存文件pip install pandas --save requirements-dev.txt# 批量安装并记录pip install -r base-requirements.txt --save 核心功能： 📦 增量更新模式（保留已有依赖） 🎯 智能版本锁定（记录精确版本号） 🔄 支持多环境文件（dev/prod） 📊 生成依赖关系树可视化：1pip show pandas --save --tree 方案三：现代项目管理工具集成1. Pipenv工作流：123456# 安装并自动更新Pipfilepipenv install requestspipenv install --dev pytest# 生成标准requirements文件pipenv requirements &gt; requirements.txt 2. Poetry配置：12345678910# pyproject.toml 配置示例[tool.poetry.dependencies]python = \"^3.8\"requests = &#123; version = \"*\", optional = true &#125;[tool.poetry.dev-dependencies]pytest = \"^6.2.5\"# 导出requirements.txtpoetry export -f requirements.txt --output requirements.txt 3. Hatch环境管理：12345# 创建带自动依赖跟踪的环境hatch env create myenv# 在环境中安装依赖hatch run myenv pip install numpy 版本控制最佳实践 差异化版本记录： 12345# 生产依赖pip freeze --exclude-editable | grep -v 'pkg-resources==0.0.0' &gt; requirements.txt # 开发依赖pip freeze --exclude-editable | grep -E '(pytest|coverage)' &gt; requirements-dev.txt 依赖树可视化检查： 1pipdeptree --exclude pip,pip-autosave,setuptools,wheel 安全更新策略： 12345# 查看过时依赖pip list --outdated --format=columns # 批量更新命令pip install $(pip list --outdated | awk 'NR&gt;2 &#123;print $1&#125;') --upgrade 不同方案的适用场景对比 方案 适用场景 优势 局限性 Shell别名 快速原型开发 无需安装新工具 功能有限，可能覆盖文件 pip-autosave 企业级项目 精细控制，支持多环境 需要额外安装 Pipenv/Poetry 长期维护的大型项目 完整依赖解析，支持锁定文件 学习成本较高 Hatch 多环境复杂配置 集成测试和构建流程 生态系统较新 常见问题解决方案Q：如何处理不同操作系统依赖？12# 使用平台标记pip install pywin32 --save; sys_platform == 'win32' Q：如何避免开发工具污染生产依赖？123456# 使用分层requirements文件.├── requirements│ ├── base.txt│ ├── dev.txt│ └── prod.txt Q：依赖冲突自动解决示例：123# 使用版本范围语法Django&gt;=3.2,&lt;4.0requests&gt;=2.25.1,!=2.28.0","categories":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"}]},{"title":"Python虚拟环境创建、激活、管理与最佳实践","slug":"Python虚拟环境创建、激活、管理与最佳实践","date":"2025-03-21T04:47:36.000Z","updated":"2025-03-21T04:49:00.909Z","comments":true,"path":"2025/03/21/Python虚拟环境创建、激活、管理与最佳实践/","link":"","permalink":"https://www.silenceboy.com/2025/03/21/Python虚拟环境创建、激活、管理与最佳实践/","excerpt":"","text":"引言：为什么需要虚拟环境？在Python开发中，不同项目往往依赖不同版本的第三方库。全局安装的包可能导致版本冲突，例如项目A需要Django 3.2，而项目B需要Django 4.0。虚拟环境通过为每个项目创建隔离的Python运行环境，完美解决这一难题。 一、创建虚拟环境1. 使用内置venv模块12# 适用于Python 3.3+版本python -m venv myenv # 创建名为myenv的虚拟环境 2. 指定Python解释器版本1python3.8 -m venv py38_env # 使用特定Python版本创建 3. 目录结构解析12345myenv/├── bin/ # Unix激活脚本├── Scripts/ # Windows激活脚本├── Lib/ # 安装的第三方库└── pyvenv.cfg # 环境配置文件 二、激活虚拟环境Windows系统12myenv\\Scripts\\activate# 命令提示符显示 (myenv) C:\\&gt; macOS/Linux系统12source myenv/bin/activate# 终端提示符显示 (myenv) $ 验证激活状态：12which python # Unixwhere python # Windows 三、管理项目依赖安装依赖包1pip install django==3.2.12 导出依赖清单1pip freeze &gt; requirements.txt 批量安装依赖1pip install -r requirements.txt 四、退出虚拟环境12deactivate# 命令提示符恢复默认状态 五、进阶技巧与工具1. 虚拟环境管理工具对比 工具 特点 适用场景 venv Python内置，轻量级 简单项目 virtualenv 支持Python 2/3 兼容旧项目 pipenv 整合pip+虚拟环境 复杂依赖管理 poetry 依赖解析+打包一体化 专业项目开发 2. 快速复制环境12345# 在原环境执行pip list --format=freeze &gt; requirements.txt# 在新环境执行pip install -r requirements.txt 3. 环境配置加速12python -m pip install pip --upgrade # 升级pippip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple # 国内镜像源 六、最佳实践 项目隔离原则：每个独立项目创建专属虚拟环境 版本控制：将requirements.txt加入Git仓库，忽略虚拟环境目录 1234# .gitignoremyenv/venv/*.env/ 定期维护： 12pip list --outdated # 检查过期包pip-autoremove # 清理无用依赖 结语掌握虚拟环境是Python开发者的必备技能。通过venv创建隔离环境，配合requirements.txt管理依赖，能有效避免”在我机器上能运行”的经典问题。建议立即在您的下一个Python项目中实践这些技巧，体验更干净的开发环境！ 提示：删除虚拟环境只需删除对应目录即可，但请确保已执行deactivate退出环境。","categories":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"}]},{"title":"ASIL等级是什么","slug":"ASIL等级是什么","date":"2024-10-22T06:45:40.000Z","updated":"2024-10-22T06:46:23.432Z","comments":true,"path":"2024/10/22/ASIL等级是什么/","link":"","permalink":"https://www.silenceboy.com/2024/10/22/ASIL等级是什么/","excerpt":"","text":"ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL A表示最低的安全要求。 ASIL等级的定义ASIL等级基于三个主要因素来确定： 严重性（Severity, S）：故障导致的潜在伤害的严重程度。 暴露率（Exposure, E）：驾驶员或乘客暴露于潜在故障的频率。 可控性（Controllability, C）：驾驶员或乘客在故障发生时控制车辆的能力。 ASIL等级的划分根据上述三个因素的组合，ASIL等级可以分为以下四个级别： ASIL A：最低的安全要求。适用于故障对安全影响较小、暴露率低且可控性高的情况。 ASIL B：中等安全要求。适用于故障对安全影响中等、暴露率中等且可控性一般的情况。 ASIL C：较高的安全要求。适用于故障对安全影响较大、暴露率较高且可控性较低的情况。 ASIL D：最高的安全要求。适用于故障对安全影响非常大、暴露率非常高且几乎不可控的情况。 ASIL等级的确定ASIL等级的确定通常通过一个风险评估矩阵来完成，该矩阵综合考虑严重性、暴露率和可控性三个因素。以下是一个简化的示例矩阵： 严重性/暴露率/可控性 E1（低） E2（中低） E3（中高） E4（高） S1（低） QM QM ASIL A ASIL A S2（中） QM ASIL A ASIL B ASIL B S3（高） ASIL A ASIL B ASIL C ASIL D S4（极高） ASIL B ASIL C ASIL D ASIL D 注：QM（Quality Management）表示不需要特别的安全措施，只需按照质量管理标准进行处理。 ASIL等级的应用在汽车电子系统的设计和开发过程中，确定ASIL等级是确保系统安全性的关键步骤。不同的ASIL等级对应不同的开发流程和验证要求： ASIL A：基本的安全措施和验证。 ASIL B：需要更严格的设计和测试流程。 ASIL C：需要高级的安全分析和验证技术。 ASIL D：需要最高级别的安全措施、冗余设计和全面的验证。 总结ASIL等级是评估和管理汽车电子系统安全性的关键工具。通过确定系统的ASIL等级，开发人员可以采取适当的设计和验证措施，以确保系统在各种可能的故障情况下都能保持安全性。ISO 26262标准提供了详细的指南和方法，帮助开发人员在整个开发生命周期中实现和维护所需的安全完整性等级。","categories":[{"name":"ASIL","slug":"ASIL","permalink":"https://www.silenceboy.com/categories/ASIL/"}],"tags":[{"name":"ASIL","slug":"ASIL","permalink":"https://www.silenceboy.com/tags/ASIL/"}]},{"title":"SOC中除了R核和A核还有哪些处理器核心","slug":"SOC中除了R核和A核还有哪些处理器核心","date":"2024-10-21T06:25:57.000Z","updated":"2024-10-21T06:26:19.127Z","comments":true,"path":"2024/10/21/SOC中除了R核和A核还有哪些处理器核心/","link":"","permalink":"https://www.silenceboy.com/2024/10/21/SOC中除了R核和A核还有哪些处理器核心/","excerpt":"","text":"除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型： M核（Microcontroller Core）M核通常指的是微控制器核心，主要用于低功耗、低成本的嵌入式系统。以下是M核的一些特点和应用： 低功耗：设计目标是尽量减少功耗，适合电池供电的设备。 简单架构：通常具有较简单的指令集和架构，易于编程和调试。 集成外设：通常集成了丰富的外设接口，如ADC、DAC、UART、I2C、SPI等。 实时性：虽然不如R核那样严格，但也能处理一些实时任务。 应用场景 家用电器 传感器节点 简单控制系统 物联网设备 NPU（Neural Processing Unit）NPU是神经网络处理单元，专门用于加速深度学习和人工智能任务。以下是NPU的一些特点和应用： 高效计算：专门优化用于矩阵运算和卷积操作，适合深度学习模型的推理和训练。 并行处理：具有高度并行的计算能力，能够同时处理大量数据。 低功耗：相对于通用处理器，NPU在执行AI任务时具有更高的能效比。 应用场景 图像和视频处理 语音识别 自然语言处理 自动驾驶 DSP（Digital Signal Processor）DSP是数字信号处理器，专门用于处理数字信号，如音频、视频和通信信号。以下是DSP的一些特点和应用： 高效信号处理：专门优化用于快速傅里叶变换（FFT）、滤波和其他信号处理算法。 实时处理：能够实时处理输入信号，适合实时音频和视频处理。 低延迟：设计目标是尽量减少处理延迟，确保信号处理的实时性。 应用场景 音频处理（如回声消除、降噪） 视频处理（如编码、解码） 通信系统（如调制、解调） 雷达和声纳 GPU（Graphics Processing Unit）GPU是图形处理单元，主要用于图形渲染和计算加速。以下是GPU的一些特点和应用： 高并行性：具有大量并行处理单元，能够同时处理大量数据。 图形渲染：专门用于处理图形渲染任务，如3D图形、游戏图形等。 通用计算：近年来，GPU也被广泛用于通用计算（GPGPU），如科学计算、机器学习等。 应用场景 游戏和娱乐 图形设计和渲染 科学计算 深度学习 VPU（Vision Processing Unit）VPU是视觉处理单元，专门用于处理计算机视觉任务。以下是VPU的一些特点和应用： 优化视觉任务：专门优化用于图像和视频处理任务，如对象检测、图像识别等。 高效能效比：在处理视觉任务时具有高效的能效比。 实时处理：能够实时处理图像和视频数据，适合实时应用。 应用场景 计算机视觉 增强现实（AR）和虚拟现实（VR） 自动驾驶 安全监控 总结在现代SoC设计中，除了R核和A核，还有多种类型的处理器核心，如M核、NPU、DSP、GPU和VPU等。每种核心都有其特定的用途和优势，通过组合使用这些核心，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。","categories":[{"name":"SoC","slug":"SoC","permalink":"https://www.silenceboy.com/categories/SoC/"}],"tags":[{"name":"SoC","slug":"SoC","permalink":"https://www.silenceboy.com/tags/SoC/"}]},{"title":"SOC的R核、A核有什么区别","slug":"SOC的R核、A核有什么区别","date":"2024-10-21T06:22:57.000Z","updated":"2024-10-21T06:23:53.596Z","comments":true,"path":"2024/10/21/SOC的R核、A核有什么区别/","link":"","permalink":"https://www.silenceboy.com/2024/10/21/SOC的R核、A核有什么区别/","excerpt":"","text":"在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。 R核（Real-time Core）R核通常指的是实时处理器核心，主要用于处理实时任务。以下是R核的一些特点和应用： 实时性：R核设计用于处理需要严格时间约束的任务，确保任务在规定时间内完成。 确定性：R核通常具有确定的响应时间，适合用于实时操作系统（RTOS）。 低延迟：R核的设计目标是尽量减少处理延迟，以确保快速响应外部事件。 低功耗：R核通常功耗较低，适合用于电池供电的嵌入式设备。 应用场景 工业自动化控制 汽车电子（如引擎控制单元） 医疗设备 物联网设备 A核（Application Core）A核通常指的是应用处理器核心，主要用于运行复杂的应用程序和操作系统。以下是A核的一些特点和应用： 高性能：A核设计用于处理复杂计算任务，具有较高的处理能力。 多任务处理：A核通常支持多任务处理，能够运行完整的操作系统（如Linux、Android）。 丰富的外设支持：A核通常集成了丰富的外设接口，如USB、HDMI、以太网等。 较高功耗：由于需要处理复杂任务，A核的功耗通常较高。 应用场景 智能手机和平板电脑 个人计算机 多媒体设备（如智能电视和机顶盒） 高级嵌入式系统（如无人机和机器人） 例子：ARM Cortex 系列在ARM的Cortex系列处理器中，R核和A核的区别非常明显： Cortex-R 系列：这是ARM的实时处理器系列，设计用于高可靠性和实时性应用，如Cortex-R5和Cortex-R8。 Cortex-A 系列：这是ARM的应用处理器系列，设计用于高性能和复杂应用，如Cortex-A53、Cortex-A72等。 SoC中的组合在许多SoC设计中，R核和A核常常被组合使用，以便同时满足实时处理和高性能计算的需求。例如： 智能手机SoC：通常包含多个Cortex-A系列核心用于运行操作系统和应用程序，同时可能包含一个或多个Cortex-R系列核心用于处理实时任务，如基带处理。 汽车电子SoC：可能包含Cortex-R系列核心用于引擎控制和安全系统，同时包含Cortex-A系列核心用于信息娱乐系统。 总结 R核（Real-time Core）：用于实时任务，强调低延迟和确定性，适合工业控制、汽车电子等领域。 A核（Application Core）：用于运行复杂应用程序和操作系统，强调高性能和多任务处理，适合智能手机、平板电脑等设备。 通过结合使用R核和A核，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。","categories":[{"name":"SoC","slug":"SoC","permalink":"https://www.silenceboy.com/categories/SoC/"}],"tags":[{"name":"SoC","slug":"SoC","permalink":"https://www.silenceboy.com/tags/SoC/"}]},{"title":"docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？","slug":"docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？","date":"2024-06-28T07:22:18.000Z","updated":"2024-06-28T07:23:01.137Z","comments":true,"path":"2024/06/28/docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？/","link":"","permalink":"https://www.silenceboy.com/2024/06/28/docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？/","excerpt":"","text":"如果你在 Docker 容器中默认用户是 dev，但不知道密码，无法执行 sudo 操作，你可以通过以下几种方法来解决这个问题： 方法一：以 root 用户重新启动容器你可以以 root 用户重新启动容器，然后更改 dev 用户的密码或者直接执行你需要的操作。 1docker exec -u root -it &lt;container_id_or_name&gt; /bin/bash 方法二：修改 Dockerfile 重新构建镜像如果你有 Dockerfile，可以修改 Dockerfile 来设置 dev 用户的密码或者直接使用 root 用户。 例如，修改 Dockerfile 来设置 dev 用户的密码： 123456FROM your_base_image# 设置 dev 用户的密码RUN echo 'dev:your_new_password' | chpasswd# 其他 Dockerfile 指令 然后重新构建镜像并运行容器： 12docker build -t your_image_name .docker run -it your_image_name 方法三：创建新的镜像并修改用户配置如果你没有 Dockerfile，但可以访问容器的镜像，你可以创建一个新的镜像并修改用户配置。 首先，启动一个新的容器并进入： 1docker run -it --name temp_container your_image_name /bin/bash 在容器中修改 dev 用户的密码： 1echo 'dev:your_new_password' | chpasswd 退出容器并提交更改： 12exitdocker commit temp_container your_new_image_name 使用新的镜像启动容器： 1docker run -it your_new_image_name 方法四：直接进入容器并修改密码如果容器已经在运行，你可以直接进入容器并修改 dev 用户的密码。 首先，以 root 用户进入容器： 1docker exec -u root -it &lt;container_id_or_name&gt; /bin/bash 在容器中修改 dev 用户的密码： 1echo 'dev:your_new_password' | chpasswd 方法五：使用 docker commit 修改现有容器如果你已经有一个运行中的容器，可以使用 docker commit 来创建一个新的镜像，并在新镜像中修改 dev 用户的密码。 首先，以 root 用户进入容器： 1docker exec -u root -it &lt;container_id_or_name&gt; /bin/bash 在容器中修改 dev 用户的密码： 1echo 'dev:your_new_password' | chpasswd 退出容器并提交更改： 12exitdocker commit &lt;container_id_or_name&gt; your_new_image_name 使用新的镜像启动容器： 1docker run -it your_new_image_name 通过这些方法，你可以解决无法执行 sudo 操作的问题，并根据需要修改 dev 用户的密码或直接使用 root 用户。","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"}]},{"title":"代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比","slug":"代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比","date":"2024-06-24T08:02:01.000Z","updated":"2024-06-24T08:10:17.375Z","comments":true,"path":"2024/06/24/代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比/","link":"","permalink":"https://www.silenceboy.com/2024/06/24/代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比/","excerpt":"","text":"代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别： 1. SonarQube简介: SonarQube 是一个开源的代码质量管理工具。 支持多种编程语言，如 Java、C#、JavaScript、TypeScript、Python 等。 功能: 静态代码分析：检测代码中的漏洞、错误和代码异味。 代码度量：提供代码覆盖率、复杂度等度量指标。 集成：与 CI/CD 工具（如 Jenkins、GitLab CI）集成，自动化代码质量检查。 优点: 开源且社区活跃。 支持多种插件，扩展功能强大。 直观的用户界面，易于使用。 2. Fireline简介: Fireline 是一个专注于代码安全的静态分析工具。 功能: 检测代码中的安全漏洞，如 SQL 注入、跨站脚本攻击（XSS）等。 提供详细的漏洞报告和修复建议。 优点: 专注于安全漏洞检测，提供深度分析。 适用于需要高安全性的应用程序开发。 3. Coverity简介: Coverity 是 Synopsys 提供的静态代码分析工具。 支持多种编程语言，如 C、C++、Java、C#、JavaScript 等。 功能: 静态代码分析：检测代码中的缺陷和安全漏洞。 自动化分析：与 CI/CD 工具集成，实现自动化代码扫描。 报告和修复建议：提供详细的缺陷报告和修复建议。 优点: 高准确性和低误报率。 强大的企业级支持和服务。 支持广泛的编程语言和复杂代码库。 4. Fortify简介: Fortify 是 Micro Focus 提供的应用安全测试工具。 包含静态应用安全测试（SAST）和动态应用安全测试（DAST）。 功能: 静态代码分析：检测代码中的安全漏洞。 动态分析：在运行时检测应用程序的安全漏洞。 安全审计和合规性检查。 优点: 综合的安全测试解决方案，覆盖静态和动态分析。 强大的企业级支持和服务。 提供详细的漏洞修复指导。 5. Black Duck简介: Black Duck 是 Synopsys 提供的开源安全和管理工具。 专注于开源组件的安全和合规性。 功能: 开源组件扫描：检测项目中使用的开源组件。 漏洞检测：识别开源组件中的已知漏洞。 许可证合规性：检查开源组件的许可证合规性。 优点: 专注于开源组件的管理和安全。 提供详细的漏洞和许可证合规报告。 与其他 Synopsys 工具集成，提供全面的安全解决方案。 区别总结 SonarQube：主要关注代码质量和代码异味，提供全面的代码度量和质量报告。 Fireline：专注于代码安全漏洞的检测，适用于需要高安全性的应用。 Coverity：提供高准确性的静态代码分析，适合复杂和大型代码库。 Fortify：综合的应用安全测试工具，覆盖静态和动态分析，适合全面的安全测试需求。 Black Duck：专注于开源组件的安全和合规性管理，适用于使用大量开源组件的项目。 每种工具都有其特定的优势和应用场景，选择合适的工具应根据项目的具体需求和环境来决定。","categories":[{"name":"代码扫描","slug":"代码扫描","permalink":"https://www.silenceboy.com/categories/代码扫描/"}],"tags":[{"name":"代码扫描","slug":"代码扫描","permalink":"https://www.silenceboy.com/tags/代码扫描/"}]},{"title":"shell脚本里的#*@是什么意思","slug":"shell脚本里的-是什么意思","date":"2023-09-27T09:22:45.000Z","updated":"2023-12-05T01:44:02.331Z","comments":true,"path":"2023/09/27/shell脚本里的-是什么意思/","link":"","permalink":"https://www.silenceboy.com/2023/09/27/shell脚本里的-是什么意思/","excerpt":"","text":"在Shell脚本中，${variable#pattern} 是一种字符串处理方式，其中 # 后跟着一个模式（pattern）。这个语法的作用是从字符串变量 variable 的开头删除匹配 pattern 的最短子串，并返回删除后的结果。${variable#*@} 的含义是： ● variable 是一个字符串变量，通常是一个包含文本的字符串。 ● # 表示从字符串开头开始匹配。 ● *@ 是一个通配符模式，它匹配字符串中的任意字符序列，直到第一个 @ 字符。 所以，${variable#*@} 的作用是从变量 variable 的开头删除匹配 *@ 模式的最短子串，并返回删除后的结果。通常，这种操作用于处理文本或字符串，以过滤掉或提取感兴趣的部分。例如，如果 variable 的值是 &quot;user@example.com&quot;，那么 ${variable#*@} 的结果将是 &quot;example.com&quot;，因为它删除了字符串中第一个 &quot;@&quot; 符号及其之前的部分。","categories":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/tags/shell/"}]},{"title":"用go开发sse接口","slug":"用go开发sse接口","date":"2023-07-11T02:50:24.000Z","updated":"2023-07-21T05:36:57.832Z","comments":true,"path":"2023/07/11/用go开发sse接口/","link":"","permalink":"https://www.silenceboy.com/2023/07/11/用go开发sse接口/","excerpt":"","text":"开发环境： 系统： ubuntu20.04 go版本： 1.19 编辑器： goland sse 服务器发送事件(Server-Sent Events)，服务端向客户端单向传递消息。在一些只需要接受服务端数据的需求中可以取代websocket技术，使用起来也很简单。 目前go已经有一些支持sse的库，我这里选用了：eventsource.v1 1$ go get gopkg.in/antage/eventsource.v1 广播模式SSE广播模式SSE指不设置事件名，或者说是不设置通道，所有客户端接收同样的数据。 具体代码实现如下：点击查看源码 服务端 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"gopkg.in/antage/eventsource.v1\" \"log\" \"net/http\" \"time\")// 广播模式SSE，不设置事件名称（也可理解为通道）func main() &#123; es := eventsource.New(nil, nil) defer es.Close() http.Handle(\"/\", http.FileServer(http.Dir(\"./public\"))) http.Handle(\"/events\", es) go func() &#123; for &#123; // 只设置发送数据，不添加事件名 es.SendEventMessage(fmt.Sprintf(\"send data: %s\", time.Now().Format(\"2006-01-02 15:04:05\")), \"\", \"\") log.Printf(\"客户端连接数: %d\", es.ConsumersCount()) time.Sleep(2 * time.Second) &#125; &#125;() log.Println(\"Open URL http://localhost:8080/ in your browser.\") err := http.ListenAndServe(\":8080\", nil) if err != nil &#123; log.Fatal(err) &#125;&#125; 前端 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SSE test&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; const es = new EventSource(\"http://localhost:8080/events\"); es.onmessage = function (e) &#123; document.getElementById(\"test\") .insertAdjacentHTML(\"beforeend\", \"&lt;li&gt;\" + e.data + \"&lt;/li&gt;\"); &#125; es.onerror = function (e) &#123; // readyState说明 // 0：浏览器与服务端尚未建立连接或连接已被关闭 // 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据 // 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接 console.log(\"readyState = \" + e.currentTarget.readyState); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;SSE test&lt;/h1&gt;&lt;div&gt; &lt;ul id=\"test\"&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动服务端代码： 1$ go run main 打开浏览器访问前端代码： http://localhost:8080 服务端输出： 前端输出： 点对点模式SSE点击查看源代码 实现方式和广播模式差不多，只需做简单修改： 服务端代码只需添加事件名称： 12// 设置事件名称为：test-eventes.SendEventMessage(fmt.Sprintf(\"send data: %s\", time.Now().Format(\"2006-01-02 15:04:05\")), \"test-event\", \"\") 前端代码修改接收方式： 1234es.addEventListener(\"test-event\", (e) =&gt; &#123; document.getElementById(\"test\") .insertAdjacentHTML(\"beforeend\", \"&lt;li&gt;\" + e.data + \"&lt;/li&gt;\");&#125;); 支持跨域的SSE点击查看源代码 现在项目开发基本上都是前后端分离，这样就会存在跨域问题，SSE解决跨域的方式只需要在new方法内增加允许跨域请求头： 12345678es := eventsource.New( eventsource.DefaultSettings(), func(req *http.Request) [][]byte &#123; return [][]byte&#123; []byte(\"X-Accel-Buffering: no\"), []byte(\"Access-Control-Allow-Origin: *\"), &#125; &#125;) 前端创建sse连接时也可添加允许跨域参数： 1const es = new EventSource(\"http://localhost:8080/events\", &#123; withCredentials: true &#125;); 解决火狐浏览器断开不会自动重连问题点击查看源代码 在Chrome浏览器中sse断开后会自动重连，但firefox浏览器中断开后不会重连，解决办法是，前端js通过判断连接状态主动进行重连请求，通过判断readyState的值进行重新调用初始化操作 readyState说明： 0：浏览器与服务端尚未建立连接或连接已被关闭 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接 前端代码可修改为如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SSE test&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; let es = null; // 解决火狐浏览器断开不会自动重连问题 function initES() &#123; if (es == null || es.readyState == 2) &#123; es = new EventSource(\"http://localhost:8080/events\", &#123;withCredentials: true&#125;); es.addEventListener(\"test-event\", (e) =&gt; &#123; document.getElementById(\"test\") .insertAdjacentHTML(\"beforeend\", \"&lt;li&gt;\" + e.data + \"&lt;/li&gt;\"); &#125;); es.onerror = function (e) &#123; // readyState说明 // 0：浏览器与服务端尚未建立连接或连接已被关闭 // 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据 // 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接 console.log(\"readyState = \" + e.currentTarget.readyState); if (es.readyState == 2) &#123; setTimeout(initES, 5000) &#125; &#125; &#125; &#125; initES() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;SSE test&lt;/h1&gt;&lt;div&gt; &lt;ul id=\"test\"&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"grpc系列课程（五）：grpc调试工具","slug":"grpc系列课程（五）：grpc调试工具","date":"2023-06-26T02:38:01.000Z","updated":"2023-07-21T05:36:57.830Z","comments":true,"path":"2023/06/26/grpc系列课程（五）：grpc调试工具/","link":"","permalink":"https://www.silenceboy.com/2023/06/26/grpc系列课程（五）：grpc调试工具/","excerpt":"","text":"开发环境： 系统： ubuntu20.04 go版本： 1.19 编辑器： goland 平时我们编写http的api接口时能够很方便的通过postman工具进行接口调试，那么grpc接口是否也有类似postman的工具可以调试呐？当然可以，github上有一款工具grpcui，专门用来在浏览器中进行grpc接口调试。 安装grpcui工具1$ go install github.com/fullstorydev/grpcui/cmd/grpcui@latest 项目测试我们以demo_1测试代码为例进行调试。首先在项目中安装依赖： 1$ go get github.com/fullstorydev/grpcui 运行项目1$ go run server/main.go 启动grpcui另起一个终端，执行一下命令，注意这里的端口号要和grpc服务端口号保持一致。 1$ grpcui -plaintext 127.0.0.1:8080 如果你在执行以上命令的时候出现一下报错： 1Failed to compute set of methods to expose: server does not support the reflection API 需要在server/main.go文件中添加如下代码，增加反射： 1reflection.Register(s) 此时再运行以上启动grpcui命令，可看到一下输出： 12gRPC Web UI available at http://127.0.0.1:41619/Opening in existing browser session. 浏览器调试浏览器打开http://127.0.0.1:41619/ ,可以看到grpcui调试页面： 点击Invoke按钮，可以看到Responsetab页有对于的相应数据：","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"grpc系列课程（四）：双向流式rpc","slug":"grpc系列课程（四）：双向流式rpc","date":"2023-06-18T07:13:21.000Z","updated":"2023-07-21T05:36:57.831Z","comments":true,"path":"2023/06/18/grpc系列课程（四）：双向流式rpc/","link":"","permalink":"https://www.silenceboy.com/2023/06/18/grpc系列课程（四）：双向流式rpc/","excerpt":"","text":"开发环境： 系统： ubuntu20.04 go版本： 1.19 编辑器： goland grpc：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。 grpc环境配置protoc安装1234$ sudo apt install -y protobuf-compiler$ protoc --versionlibprotoc 3.6.1 如果是其他系统电脑，安装protoc可参考文档：Protocol Buffer Compiler Installation protocol编译插件安装12$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 安装完成后可以在bin目录下看到相关指令： 123$ ls $GOPATH/binprotoc-gen-go protoc-gen-go-grpc 项目开发项目源码地址 项目目录结构123456789101112├── demo_4│ ├── client│ │ └── main.go│ ├── go.mod│ ├── go.sum│ ├── helloworld│ │ ├── helloworld_grpc.pb.go│ │ ├── helloworld.pb.go│ │ └── helloworld.proto│ ├── README.md│ └── server│ └── main.go 项目创建12$ mkdir demo_4 &amp;&amp; cd demo_4$ go mod init 安装grpc依赖1$ go get -u google.golang.org/grpc 编写proto文件流式rpc使用stream关键字定义 123456789101112131415161718# helloworld/helloworld.protosyntax = \"proto3\";option go_package = \"/helloworld\";package helloworld;service Hello &#123; rpc SayHello (stream HelloRequest) returns (stream HelloReply) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125; 生成go代码123$ protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ helloworld/helloworld.proto 命令执行成功之后会在helloworld目录下生成两个文件： helloworld_grpc.pb.go和helloworld.pb.go，注意： 不要手动编辑这两个文件。 编写服务端代码flag用法可参考官方文档： https://pkg.go.dev/flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// server/main.gopackage mainimport ( \"flag\" \"fmt\" \"github.com/silenceboychen/gostudy/demo_4/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/reflection\" \"io\" \"log\" \"net\" \"strconv\")var ( port = flag.Int(\"port\", 8080, \"The server port\"))type server struct &#123; helloworld.UnimplementedHelloServer&#125;func (s *server) SayHello(stream helloworld.Hello_SayHelloServer) error &#123; n := 0 for &#123; res, err := stream.Recv() if err == io.EOF &#123; return nil &#125; if err != nil &#123; return err &#125; err = stream.Send(&amp;helloworld.HelloReply&#123; Message: \"server stream: \" + res.GetName() + \"_\" + strconv.Itoa(n), &#125;) if err != nil &#123; return err &#125; n++ log.Printf(\"client stream: %s\", res.GetName()) &#125;&#125;func main() &#123; flag.Parse() lis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port)) if err != nil &#123; log.Fatalf(\"failed to listen: %v\", err) &#125; s := grpc.NewServer() reflection.Register(s) helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;) log.Printf(\"server listening at %v\", lis.Addr()) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"failed to serve: %v\", err) &#125;&#125; 编写客户端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// client/main.gopackage mainimport ( \"context\" \"flag\" \"github.com/silenceboychen/gostudy/demo_4/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"io\" \"log\" \"strconv\" \"time\")var ( addr = flag.String(\"addr\", \"localhost:8080\", \"the address to connect to\") name = flag.String(\"name\", \"world\", \"Name to greet\"))func main() &#123; flag.Parse() conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; log.Fatalf(\"did not connect: %v\", err) &#125; defer conn.Close() c := helloworld.NewHelloClient(conn) _, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() stream, err := c.SayHello(context.Background()) if err != nil &#123; log.Fatalf(\"stream err: %v\", err) &#125; for n := 0; n &lt; 5; n++ &#123; err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: *name + \"_\" + strconv.Itoa(n)&#125;) if err != nil &#123; log.Fatalf(\"client stream err: %v\", err) &#125; res, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatalf(\"server stream err: %v\", err) &#125; // 打印返回值 log.Println(res.GetMessage()) &#125; err = stream.CloseSend() if err != nil &#123; log.Fatalf(\"close stream err: %v\", err) &#125;&#125; 项目运行开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。 服务端 12345678$ go run server/main.go2023/06/16 20:51:39 server listening at [::]:80802023/06/16 20:51:42 client stream: world_02023/06/16 20:51:42 client stream: world_12023/06/16 20:51:42 client stream: world_22023/06/16 20:51:42 client stream: world_32023/06/16 20:51:42 client stream: world_4 客户端 1234567$ go run client/main.go2023/06/16 20:51:42 server stream: world_0_02023/06/16 20:51:42 server stream: world_1_12023/06/16 20:51:42 server stream: world_2_22023/06/16 20:51:42 server stream: world_3_32023/06/16 20:51:42 server stream: world_4_4 下一篇将向大家介绍grpc调试工具。","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"grpc系列课程（三）：客户端流式rpc","slug":"grpc系列课程（三）：客户端流式rpc","date":"2023-06-18T07:12:48.000Z","updated":"2023-07-21T05:36:57.829Z","comments":true,"path":"2023/06/18/grpc系列课程（三）：客户端流式rpc/","link":"","permalink":"https://www.silenceboy.com/2023/06/18/grpc系列课程（三）：客户端流式rpc/","excerpt":"","text":"开发环境： 系统： ubuntu20.04 go版本： 1.19 编辑器： goland grpc：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。 grpc环境配置protoc安装1234$ sudo apt install -y protobuf-compiler$ protoc --versionlibprotoc 3.6.1 如果是其他系统电脑，安装protoc可参考文档：Protocol Buffer Compiler Installation protocol编译插件安装12$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 安装完成后可以在bin目录下看到相关指令： 123$ ls $GOPATH/binprotoc-gen-go protoc-gen-go-grpc 项目开发项目源码地址 项目目录结构123456789101112├── demo_3│ ├── client│ │ └── main.go│ ├── go.mod│ ├── go.sum│ ├── helloworld│ │ ├── helloworld_grpc.pb.go│ │ ├── helloworld.pb.go│ │ └── helloworld.proto│ ├── README.md│ └── server│ └── main.go 项目创建12$ mkdir demo_3 &amp;&amp; cd demo_3$ go mod init 安装grpc依赖1$ go get -u google.golang.org/grpc 编写proto文件流式rpc使用stream关键字定义 123456789101112131415161718# helloworld/helloworld.protosyntax = \"proto3\";option go_package = \"/helloworld\";package helloworld;service Hello &#123; rpc SayHello (stream HelloRequest) returns (HelloReply) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125; 生成go代码123$ protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ helloworld/helloworld.proto 命令执行成功之后会在helloworld目录下生成两个文件： helloworld_grpc.pb.go和helloworld.pb.go，注意： 不要手动编辑这两个文件。 编写服务端代码flag用法可参考官方文档： https://pkg.go.dev/flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// server/main.gopackage mainimport ( \"flag\" \"fmt\" \"github.com/silenceboychen/gostudy/demo_3/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/reflection\" \"io\" \"log\" \"net\")var ( port = flag.Int(\"port\", 8080, \"The server port\"))type server struct &#123; helloworld.UnimplementedHelloServer&#125;func (s *server) SayHello(stream helloworld.Hello_SayHelloServer) error &#123; for &#123; res, err := stream.Recv() if err == io.EOF &#123; return stream.SendAndClose(&amp;helloworld.HelloReply&#123;Message: \"over\"&#125;) &#125; if err != nil &#123; return err &#125; log.Println(res.Name) &#125;&#125;func main() &#123; flag.Parse() lis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port)) if err != nil &#123; log.Fatalf(\"failed to listen: %v\", err) &#125; s := grpc.NewServer() reflection.Register(s) helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;) log.Printf(\"server listening at %v\", lis.Addr()) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"failed to serve: %v\", err) &#125;&#125; 编写客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// client/main.gopackage mainimport ( \"context\" \"flag\" \"github.com/silenceboychen/gostudy/demo_3/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"log\" \"strconv\" \"time\")var ( addr = flag.String(\"addr\", \"localhost:8080\", \"the address to connect to\") name = flag.String(\"name\", \"world\", \"Name to greet\"))func main() &#123; flag.Parse() conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; log.Fatalf(\"did not connect: %v\", err) &#125; defer conn.Close() c := helloworld.NewHelloClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() stream, err := c.SayHello(ctx) if err != nil &#123; log.Fatalf(\"Upload list err: %v\", err) &#125; for n := 0; n &lt; 5; n++ &#123; //向流中发送消息 err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: \"stream client rpc \" + strconv.Itoa(n)&#125;) if err != nil &#123; log.Fatalf(\"stream request err: %v\", err) &#125; &#125; //关闭流并获取返回的消息 res, err := stream.CloseAndRecv() if err != nil &#123; log.Fatalf(\"SayHello get response err: %v\", err) &#125; log.Println(res)&#125; 项目运行开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。 服务端 12345678$ go run server/main.go2023/06/16 20:24:15 server listening at [::]:80802023/06/16 20:24:22 stream client rpc 02023/06/16 20:24:22 stream client rpc 12023/06/16 20:24:22 stream client rpc 22023/06/16 20:24:22 stream client rpc 32023/06/16 20:24:22 stream client rpc 4 客户端 123$ go run client/main.go2023/06/16 20:24:22 message:\"over\" 下一篇将向大家介绍双向流式rpc。","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"grpc系列课程（二）：服务端流式rpc","slug":"grpc系列课程（二）：服务端流式rpc","date":"2023-06-18T07:11:52.000Z","updated":"2023-07-21T05:36:57.829Z","comments":true,"path":"2023/06/18/grpc系列课程（二）：服务端流式rpc/","link":"","permalink":"https://www.silenceboy.com/2023/06/18/grpc系列课程（二）：服务端流式rpc/","excerpt":"","text":"开发环境： 系统： ubuntu20.04 go版本： 1.19 编辑器： goland grpc：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。 grpc环境配置protoc安装1234$ sudo apt install -y protobuf-compiler$ protoc --versionlibprotoc 3.6.1 如果是其他系统电脑，安装protoc可参考文档：Protocol Buffer Compiler Installation protocol编译插件安装12$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 安装完成后可以在bin目录下看到相关指令： 123$ ls $GOPATH/binprotoc-gen-go protoc-gen-go-grpc 项目开发项目源码地址 项目目录结构123456789101112├── demo_2│ ├── client│ │ └── main.go│ ├── go.mod│ ├── go.sum│ ├── helloworld│ │ ├── helloworld_grpc.pb.go│ │ ├── helloworld.pb.go│ │ └── helloworld.proto│ ├── README.md│ └── server│ └── main.go 项目创建12$ mkdir demo_2 &amp;&amp; cd demo_2$ go mod init 安装grpc依赖1$ go get -u google.golang.org/grpc 编写proto文件流式rpc使用stream关键字定义 123456789101112131415161718# helloworld/helloworld.protosyntax = \"proto3\";option go_package = \"/helloworld\";package helloworld;service Hello &#123; rpc SayHello (HelloRequest) returns (stream HelloReply) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125; 生成go代码123$ protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ helloworld/helloworld.proto 命令执行成功之后会在helloworld目录下生成两个文件： helloworld_grpc.pb.go和helloworld.pb.go，注意： 不要手动编辑这两个文件。 编写服务端代码flag用法可参考官方文档： https://pkg.go.dev/flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344// server/main.gopackage mainimport ( \"flag\" \"fmt\" \"github.com/silenceboychen/gostudy/demo_2/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/reflection\" \"log\" \"net\")var ( port = flag.Int(\"port\", 8080, \"The server port\"))type server struct &#123; helloworld.UnimplementedHelloServer&#125;func (s *server) SayHello(in *helloworld.HelloRequest, stream helloworld.Hello_SayHelloServer) error &#123; log.Printf(\"Received: %v\", in.GetName()) for i := 0; i &lt; 5; i++ &#123; stream.Send(&amp;helloworld.HelloReply&#123;Message: fmt.Sprintf(\"hello %s---%d\", in.Name, i)&#125;) &#125; return nil&#125;func main() &#123; flag.Parse() lis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port)) if err != nil &#123; log.Fatalf(\"failed to listen: %v\", err) &#125; s := grpc.NewServer() reflection.Register(s) helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;) log.Printf(\"server listening at %v\", lis.Addr()) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"failed to serve: %v\", err) &#125;&#125; 编写客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// client/main.gopackage mainimport ( \"context\" \"flag\" \"github.com/silenceboychen/gostudy/demo_2/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"io\" \"log\" \"time\")var ( addr = flag.String(\"addr\", \"localhost:8080\", \"the address to connect to\") name = flag.String(\"name\", \"world\", \"Name to greet\"))func main() &#123; flag.Parse() conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; log.Fatalf(\"did not connect: %v\", err) &#125; defer conn.Close() c := helloworld.NewHelloClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() stream, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;) if err != nil &#123; log.Fatalf(\"could not call: %v\", err) &#125; for &#123; res, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Printf(\"stream error: %v\", err) &#125; log.Printf(\"%s\", res.Message) &#125;&#125; 项目运行开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。 服务端 1234$ go run server/main.go2023/06/16 18:56:57 server listening at [::]:80802023/06/16 18:57:02 Received: world 客户端 1234567$ go run client/main.go2023/06/16 20:11:55 hello world---02023/06/16 20:11:55 hello world---12023/06/16 20:11:55 hello world---22023/06/16 20:11:55 hello world---32023/06/16 20:11:55 hello world---4 下一篇将向大家介绍客户端流式rpc。","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"grpc系列课程（一）：单项rpc","slug":"grpc系列课程（一）：单项rpc","date":"2023-06-18T07:09:39.000Z","updated":"2023-07-21T05:36:57.828Z","comments":true,"path":"2023/06/18/grpc系列课程（一）：单项rpc/","link":"","permalink":"https://www.silenceboy.com/2023/06/18/grpc系列课程（一）：单项rpc/","excerpt":"","text":"开发环境： 系统： ubuntu20.04 go版本： 1.19 编辑器： goland grpc：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。 grpc环境配置protoc安装1234$ sudo apt install -y protobuf-compiler$ protoc --versionlibprotoc 3.6.1 如果是其他系统电脑，安装protoc可参考文档：Protocol Buffer Compiler Installation protocol编译插件安装12$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 安装完成后可以在bin目录下看到相关指令： 123$ ls $GOPATH/binprotoc-gen-go protoc-gen-go-grpc 项目开发项目源码地址 项目目录结构123456789101112├── demo_1│ ├── client│ │ └── main.go│ ├── go.mod│ ├── go.sum│ ├── helloworld│ │ ├── helloworld_grpc.pb.go│ │ ├── helloworld.pb.go│ │ └── helloworld.proto│ ├── README.md│ └── server│ └── main.go 项目创建12$ mkdir demo_1 &amp;&amp; cd demo_1$ go mod init 安装grpc依赖1$ go get -u google.golang.org/grpc 编写proto文件123456789101112131415161718# helloworld/helloworld.protosyntax = \"proto3\";option go_package = \"/helloworld\";package helloworld;service Hello &#123; rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125; 生成go代码123$ protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ helloworld/helloworld.proto 命令执行成功之后会在helloworld目录下生成两个文件： helloworld_grpc.pb.go和helloworld.pb.go，注意： 不要手动编辑这两个文件。 编写服务端代码flag用法可参考官方文档： https://pkg.go.dev/flag 123456789101112131415161718192021222324252627282930313233343536373839404142// server/main.gopackage mainimport ( \"context\" \"flag\" \"fmt\" \"github.com/silenceboychen/gostudy/demo_1/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/reflection\" \"log\" \"net\")var ( port = flag.Int(\"port\", 8080, \"The server port\"))type server struct &#123; helloworld.UnimplementedHelloServer&#125;func (s *server) SayHello(ctx context.Context, in *helloworld.HelloRequest) (*helloworld.HelloReply, error) &#123; log.Printf(\"Received: %v\", in.GetName()) return &amp;helloworld.HelloReply&#123;Message: \"Hello \" + in.GetName()&#125;, nil&#125;func main() &#123; flag.Parse() lis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port)) if err != nil &#123; log.Fatalf(\"failed to listen: %v\", err) &#125; s := grpc.NewServer() reflection.Register(s) helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;) log.Printf(\"server listening at %v\", lis.Addr()) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"failed to serve: %v\", err) &#125;&#125; 编写客户端代码12345678910111213141516171819202122232425262728293031323334353637// client/main.gopackage mainimport ( \"context\" \"flag\" \"github.com/silenceboychen/gostudy/demo_1/helloworld\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"log\" \"time\")var ( addr = flag.String(\"addr\", \"localhost:8080\", \"the address to connect to\") name = flag.String(\"name\", \"world\", \"Name to greet\"))func main() &#123; flag.Parse() conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; log.Fatalf(\"did not connect: %v\", err) &#125; defer conn.Close() c := helloworld.NewHelloClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() r, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;) if err != nil &#123; log.Fatalf(\"could not greet: %v\", err) &#125; log.Printf(\"Greeting: %s\", r.GetMessage())&#125; 项目运行开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。 服务端 1234$ go run server/main.go2023/06/16 18:56:57 server listening at [::]:80802023/06/16 18:57:02 Received: world 客户端 123$ go run client/main.go2023/06/16 18:57:02 Greeting: Hello world 以上便是go实现单项rpc的所有内容，如果一切顺利，恭喜你，以及成功入门grpc，下一篇将向大家介绍服务端流式rpc。","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"ubuntu20.04禁用搜狗输入法繁简体快捷键设置","slug":"ubuntu20-04禁用搜狗输入法繁简体快捷键设置","date":"2023-06-14T03:00:52.000Z","updated":"2025-08-27T06:44:25.046Z","comments":true,"path":"2023/06/14/ubuntu20-04禁用搜狗输入法繁简体快捷键设置/","link":"","permalink":"https://www.silenceboy.com/2023/06/14/ubuntu20-04禁用搜狗输入法繁简体快捷键设置/","excerpt":"","text":"最近在ubuntu20.04系统上安装了搜狗输入法之后，发现vscode，idea，golang等编辑器的全局搜索快捷键Ctrl+Shift+F无法使用了，经排查发现是因为搜狗输入法占用了该快捷键，是搜狗输入法的繁简体切换快捷键。打开搜狗输入法的设置页面可以在高级选项里看到。 但是在设置里取消简繁切换快捷键的勾选保存之后发现无效果，快捷键依然被占用。 正确的解决方案是： 修改搜狗输入法配置文件 1$ vim ~/.config/sogoupinyin/conf/env.ini 找到ShortCutFanJian配置，将值改为0；默认1，等于开启；改为0表示关闭 打开系统输入法配置 附加组件中找到简繁转换，点击配置 将默认快捷键设置为空, 保存即可。 如果发现未生效，需要重启电脑。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"gomobile开发安卓应用环境搭建完整流程","slug":"gomobile开发安卓应用环境搭建完整流程","date":"2023-06-08T05:33:05.000Z","updated":"2023-06-08T05:34:01.833Z","comments":true,"path":"2023/06/08/gomobile开发安卓应用环境搭建完整流程/","link":"","permalink":"https://www.silenceboy.com/2023/06/08/gomobile开发安卓应用环境搭建完整流程/","excerpt":"","text":"go环境搭建不在这里赘述。 以下内容的执行环境为： 系统：ubuntu20.04 go版本：v1.19 项目创建执行以下命令创建一个go开发安卓应用的测试目录： 12$ mkdir $GOPATH/src/goapp &amp;&amp; cd $GOPATH/src/goapp$ go mod init 在该目录下执行以下命令获取官方提供的示例项目： 1$ go get -d golang.org/x/mobile/example/basic 安装gomibile12$ go install golang.org/x/mobile/cmd/gomobile@latest$ gomobile init 然后执行以下命令打包安卓应用： 1$ gomobile build -target=android -androidapi 19 golang.org/x/mobile/example/basic 此时会发现以下相关错误： gomobile: could not locate Android SDK: stat /home/test/Android/Sdk: no such file or directory; Android SDK was not found at /home/test/Android/Sdk gomobile: no usable NDK in /home/test/Android/Sdk: open /home/test/Android/Sdk/ndk: no such file or directory, open /home/test/Android/Sdk/ndk-bundle/meta/platforms.json: no such file or directory 这是因为本地没有配置安卓开发环境导致的。 安卓开发环境搭建Android Studio安装访问谷歌中国开发者网站下载 Android Studio 编辑器：https://developer.android.google.cn/studio 下载完成后执行以下操作： 12345678910111213141516# 将安装包移到/opt目录下，需要管理员权限$ sudo mv android-studio-2022.2.1.20-linux.tar.gz /opt# 进入/opt目录$ cd /opt# 解压文件，需要管理员权限$ sudo tar -xzvf android-studio-2022.2.1.20-linux.tar.gz# 运行Android Studio$ ./android-studio/bin/studio.sh==========================================================# 如果想在任意位置打开android studio，可配置软连接$ sudo ln -s /opt/android-studio/bin/studio.sh /usr/bin/android-studio# 配置完成以后在任意位置执行android-studio即可打开应用$ android-studio 第一次打开android-studio需要进行一些配置，一直选择下一步设置即可，其中有两个地方需要注意： 选择自定义安装 插件安装，可以全选 插件安装完成之后点击Finish即可打开应用。 安装NDKAndroid studio安装完成后并没有万事大吉，默认并没安装NDK，需要自己手工再安装。 点击ok会自动下载选择的插件。 编译安卓应用此时继续回到之前的项目目录，执行安卓构建命令 1$ gomobile build -target=android -androidapi 19 golang.org/x/mobile/example/basic 这一次没有出现报错，并且目录下多了一个basic.apk文件，该文件即为打包成功的安卓应用，可以安装一个安卓模拟器进行测试了。 安装安卓模拟器模拟器我选用了Anbox 1$ sudo snap install --devmode --edge anbox 安装完成之后执行以下命令启动安卓模拟器： 1$ anbox.appmgr 我比较顺利没有遇到报错，如果遇到模拟器启动报错，可以参考文章：https://juejin.cn/post/7152407243974148127 解决 打开后的界面如下： 测试应用安装安卓应用还需要adb命令： 1$ sudo apt install android-tools-adb -y 然后在最开始的项目目录下执行以下命令安装应用，此时安卓模拟器必须是打开的状态： 123$ asb install ./basic.apk# 或者$ adb install /home/test/go/src/goapp/basic.apk 安装成功后即可在模拟器中看到该应用 单击打开，运行效果如下： 此文章主要目的是为了帮助你了解如何使用golang开发安卓应用的流程，流程打通之后，可以结合自己的想法，做一些自己的应用。","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"go语言1.18 go:linkname must refer to declared function or variable解决办法","slug":"go语言1-18-go-linkname-must-refer-to-declared-function-or-variable解决办法","date":"2022-07-12T06:13:58.000Z","updated":"2022-07-12T06:14:58.301Z","comments":true,"path":"2022/07/12/go语言1-18-go-linkname-must-refer-to-declared-function-or-variable解决办法/","link":"","permalink":"https://www.silenceboy.com/2022/07/12/go语言1-18-go-linkname-must-refer-to-declared-function-or-variable解决办法/","excerpt":"","text":"在macos环境中，go1.18刚刚部署后，会报错如下： 12345678910111213golang.org/x/sys/unix# golang.org/x/sys/unixvendor/golang.org/x/sys/unix/syscall_darwin.1_13.go:29:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_13.go:27:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_13.go:40:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:28:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:43:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:59:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:75:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:90:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:105:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:121:3: //go:linkname must refer to declared function or variablevendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:121:3: too many errors 解决办法如下： 1.运行如下命令： 1go get -u golang.org/x/sys 2.运行： 1go mod vendor","categories":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"}]},{"title":"macbook如何卸载天空卫士","slug":"macbook如何卸载天空卫士","date":"2022-05-20T06:07:27.000Z","updated":"2022-05-20T06:19:34.769Z","comments":true,"path":"2022/05/20/macbook如何卸载天空卫士/","link":"","permalink":"https://www.silenceboy.com/2022/05/20/macbook如何卸载天空卫士/","excerpt":"","text":"首先找到安装天空卫士的目录：/Library/Application Support/SkyGuard 电脑关机，长按开机键直到进入recovery模式, 点自己的用户，输入密码，点下一步，然后到左上方找到终端打开 diskutil list 查看目前的磁盘, 找到标记有synthesized的磁盘，并找到对应的数据盘（有data关键字），这里假设为：/dev/disk3s3 执行diskutil mount /dev/disk3s3, 可能会报 this is an encrypted and locked APFS Volume的错，根据提示执行：diskutil apfs unlockVolume /dev/disk3s3，然后输入密码。再次执行diskutil mount /dev/disk3s3即可。 进入/Volumes/Macintosh HD/Library/Application Support目录，可以看到有SkyGuard文件。 执行rm -rf SkyGuard删除天空位置文件目录 reboot重启电脑，发现天空卫士已成功卸载","categories":[{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"天空卫士","slug":"天空卫士","permalink":"https://www.silenceboy.com/tags/天空卫士/"}]},{"title":"mac卸载jdk","slug":"mac卸载jdk","date":"2022-04-29T09:25:19.000Z","updated":"2022-04-29T09:27:28.102Z","comments":true,"path":"2022/04/29/mac卸载jdk/","link":"","permalink":"https://www.silenceboy.com/2022/04/29/mac卸载jdk/","excerpt":"","text":"删除运行路径和运行环境等 123sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPanesudo rm -fr ~/Library/Application\\ Support/Java 删除当前版本的jdk 1sudo rm -rf /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk 检查是否卸载成功 1java -version","categories":[{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"jdk","slug":"jdk","permalink":"https://www.silenceboy.com/tags/jdk/"}]},{"title":"docker跨平台打包问题does not match the detected host platform","slug":"docker跨平台打包问题does-not-match-the-detected-host-platform","date":"2022-04-29T03:44:40.000Z","updated":"2022-04-29T03:56:38.616Z","comments":true,"path":"2022/04/29/docker跨平台打包问题does-not-match-the-detected-host-platform/","link":"","permalink":"https://www.silenceboy.com/2022/04/29/docker跨平台打包问题does-not-match-the-detected-host-platform/","excerpt":"","text":"问题最近在mac M1上构建的docker镜像，发布到ubuntu20系统的服务器上后，一直运行失败。输出以下报错信息： 1The requested image&apos;s platform (linux/arm64) does not match the detected host platform (linux/amd64) and no specific platform was requested 在使用docker logs 查看docker日志的时候提示： 1standard_init_linux.go:228: exec user process caused: exec format error​ 解决方案 mac M1上设置”experimental”: true 实现跨平台打包 docker buildx build –platform linux/amd64 -t name .","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"}]},{"title":"mac电脑M1芯片如何安装低版本node环境","slug":"mac电脑M1芯片如何安装低版本node环境","date":"2021-10-22T09:15:17.000Z","updated":"2021-10-22T09:25:13.767Z","comments":true,"path":"2021/10/22/mac电脑M1芯片如何安装低版本node环境/","link":"","permalink":"https://www.silenceboy.com/2021/10/22/mac电脑M1芯片如何安装低版本node环境/","excerpt":"","text":"在mac M1上安装v14 及以下的老版本 Node会出现闪退问题，究其原因还是因为低版本的 node 并不是基于 arm64 架构的，所以不适配 M1 芯片。在这里教大家两个方法，就能成功安装上低版本 Node。 方法一在终端中，输入： 1arch -x86_64 zsh 通过这个命令可以让 shell 运行在Rosetta2下。之后你可以通过 nvm install v14 来安装低版本 Node。在此之后，您可以不用在 Rosetta2 中就可以使用安装的可执行文件，也就是说，您可以将 Node v15与其他节点版本互换使用。 方法二方法二就是通过 Rosetta2 来启动终端，这样通过 Rosetta2 转译到 x86 架构中执行安装，也一样可以安装成功。 在 finder 中，点击应用程序，并在实用工具中找到终端 (Terminal) 右键终端，点击获取信息 勾选 Open using Rosetta 重启终端，并执行 nvm install v14 命令","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"M1","slug":"M1","permalink":"https://www.silenceboy.com/tags/M1/"}]},{"title":"Arch linux i3wm运行企业微信和微信","slug":"Arch-linux-i3wm运行企业微信和微信","date":"2021-05-26T14:05:02.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2021/05/26/Arch-linux-i3wm运行企业微信和微信/","link":"","permalink":"https://www.silenceboy.com/2021/05/26/Arch-linux-i3wm运行企业微信和微信/","excerpt":"","text":"当你运行在i3wm环境下时，运行通过deepin-wine安装的企业微信和微信时，打开软件时会出现闪退的现象，启动不了软件。或直接在命令行里执行命令也启动不了程序，会出现以下提示： 12345X Error of failed request: BadWindow (invalid Window parameter) Major opcode of failed request: 20 (X_GetProperty) Resource id in failed request: 0x0 Serial number of failed request: 10 Current serial number in output stream: 10 解决方案 这个问题其实和 KDE 无关, 应该是 deepin 在打包 deepin-wine 的过程中有意或者无意加入了 GNOME 依赖。 执行 /usr/lib/gnome-settings-daemon/gsd-xsettings 即可.或者后台运行： 1nohup /usr/lib/gnome-settings-daemon/gsd-xsettings &gt; /dev/null 2&gt;&amp;1 &amp; 如果 GNOME 的版本较低(比如Debian 9), 没有单独的 gsd-xsettings 可执行文件, 则执行 gnome-settings-daemon. 然后切换到对应目录 cd /opt/deepinwine/apps/Deepin-WXWork 或者 /opt/deepinwine/apps/Deepin-WeChat运行 ./run.sh即可启动软件。 由于每次都执行上边的命令很繁琐，可以将其加入i3的启动项，每次开机制动设置即可。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"},{"name":"i3wm","slug":"i3wm","permalink":"https://www.silenceboy.com/tags/i3wm/"},{"name":"i3","slug":"i3","permalink":"https://www.silenceboy.com/tags/i3/"}]},{"title":"MySQL TEXT数据类型的最大长度","slug":"MySQL-TEXT数据类型的最大长度","date":"2020-12-22T04:33:17.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2020/12/22/MySQL-TEXT数据类型的最大长度/","link":"","permalink":"https://www.silenceboy.com/2020/12/22/MySQL-TEXT数据类型的最大长度/","excerpt":"","text":"类型 长度 TINYTEXT 256 bytes TEXT 65,535 bytes ~64kb MEDIUMTEXT 16,777,215 bytes ~16MB LONGTEXT 4,294,967,295 bytes ~4GB","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"}]},{"title":"ubuntu18.04安装jdk1.8","slug":"ubuntu18-04安装jdk1-8","date":"2020-11-28T06:30:31.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2020/11/28/ubuntu18-04安装jdk1-8/","link":"","permalink":"https://www.silenceboy.com/2020/11/28/ubuntu18-04安装jdk1-8/","excerpt":"","text":"下载jdk安装包https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 解压1tar -zxvf jdk-8u171-linux-x64.tar.gz 移动到自己想放的位置12##将文件从下载目录 挪到/usr/local下sudo mv jdk1.8.0_171 /usr/local/jdk1.8 设置环境变量 设置全局生效 修改全局配置文件，作用与所有用户： vim /etc/profile 1234 export JAVA_HOME=/usr/local/jdk1.8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 设置当前用户生效 修改当前用户配置文件，只作用于当前用户：vim ~/.bashrc 1234 export JAVA_HOME=/usr/local/jdk1.8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 使修改的配置立刻生效1234##对应方法一：source /etc/profile ##对应方法二：source ~/.bashrc 检查是否安装成功1java -version","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"},{"name":"jdk","slug":"jdk","permalink":"https://www.silenceboy.com/tags/jdk/"},{"name":"java","slug":"java","permalink":"https://www.silenceboy.com/tags/java/"}]},{"title":"alsamixer控制音量","slug":"alsamixer控制音量","date":"2020-11-28T05:51:40.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2020/11/28/alsamixer控制音量/","link":"","permalink":"https://www.silenceboy.com/2020/11/28/alsamixer控制音量/","excerpt":"","text":"解除各声道的静音目前版本的 ALSA 安装后，所有声道默认是静音的，必须手动解除。 使用 alsamixer 的 ncurses 界面，配置十分简单： 1$ alsamixer 此外，还可以在命令行下使用 amixer： 1$ amixer sset Master unmute 在alsamixer 中，下方标有 MM 的声道是静音的，而标有 00 的通道已经启用。 使用 ← 和 → 方向键，选中 Master 和 PCM 声道。按下 m 键解除静音。使用 ↑ 方向键增加音量，直到增益值为0。该值显示在左上方Item: 字段后。过高的增益值会导致声音失真。 要启用麦克风，切换至 Capture 选项卡，按下 F4，按下 空格 启用其中一个声道即可。 按下 Esc 键退出 alsamixer。 alsamixer 终端交互式设置音量123F6 选择网卡F2 显示系统信息，可以看到系统中已有网卡信息Esc 后退 123M 静音状态切换Q,W,E 增大 左,右,通道 的音量Z,X,C 减小 左,右,通道 的音量 amixer 命令行控制系统声音1cat /proc/asound/cards # 查看系统声卡 输出如下： 120 [PCH ]: HDA-Intel - HDA Intel PCH HDA Intel PCH at 0xe1340000 irq 130 设置声音 1amixer -c 1 -q set Master 2dB+ unmute 12-c 制定声卡id, 默认为0-q 安静模式，不输出结果","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"使用npm安装依赖时报错：gyp: No Xcode or CLT version detected!","slug":"使用npm安装依赖时报错：gyp-No-Xcode-or-CLT-version-detected","date":"2020-05-05T08:47:52.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2020/05/05/使用npm安装依赖时报错：gyp-No-Xcode-or-CLT-version-detected/","link":"","permalink":"https://www.silenceboy.com/2020/05/05/使用npm安装依赖时报错：gyp-No-Xcode-or-CLT-version-detected/","excerpt":"","text":"最近在macOS中使用npm安装模块，出现如下错误： 1234567891011121314151617181920212223npm WARN deprecated fsevents@1.2.12: fsevents 1 will break on node v14+. Upgrade to fsevents 2 with massive improvements.&gt; fsevents@1.2.12 install /Users/chenhao/outsourcing/egg-car/node_modules/fsevents&gt; node-gyp rebuildNo receipt for &apos;com.apple.pkg.CLTools_Executables&apos; found at &apos;/&apos;.No receipt for &apos;com.apple.pkg.DeveloperToolsCLILeo&apos; found at &apos;/&apos;.No receipt for &apos;com.apple.pkg.DeveloperToolsCLI&apos; found at &apos;/&apos;.gyp: No Xcode or CLT version detected!gyp ERR! configure errorgyp ERR! stack Error: `gyp` failed with exit code: 1gyp ERR! stack at ChildProcess.onCpExit (/Users/chenhao/.nvm/versions/node/v10.16.0/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)gyp ERR! stack at ChildProcess.emit (events.js:198:13)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12)gyp ERR! System Darwin 19.4.0gyp ERR! command &quot;/Users/chenhao/.nvm/versions/node/v10.16.0/bin/node&quot; &quot;/Users/chenhao/.nvm/versions/node/v10.16.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot;gyp ERR! cwd /Users/chenhao/outsourcing/egg-car/node_modules/fseventsgyp ERR! node -v v10.16.0gyp ERR! node-gyp -v v5.0.5gyp ERR! not ok 网上查找解决方案，都是通过执行xcode-select --install命令修复，但是执行该命令时会出现如下提示： 1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 最终的解决办法是先卸载之前安装的xcode-select，并重新安装： 12$ sudo rm -rf $(xcode-select -print-path)$ xcode-select --install","categories":[{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/tags/npm/"}]},{"title":"zsh在scp时不能使用通配符的原因和解决方案","slug":"zsh在scp时不能使用通配符的原因和解决方案","date":"2020-03-06T07:14:33.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2020/03/06/zsh在scp时不能使用通配符的原因和解决方案/","link":"","permalink":"https://www.silenceboy.com/2020/03/06/zsh在scp时不能使用通配符的原因和解决方案/","excerpt":"","text":"问题scp是经常使用的一个本地与远程服务器相互拷贝数据的命令，zsh是我最喜欢的shell，但是在zsh下使用scp来拷贝远程服务器的文件时，却出现这样的错误。 12$ scp -r test-server:/etc/nginx/conf.d/* .zsh: no matches found: test-server:/etc/nginx/conf.d/* 同样地命令，在bash下确实可以执行的，这个原因是什么呢？ 由于zsh不会按照远程地址上的文件去扩展参数，当你使用test-server:/etc/nginx/conf.d/*，因为本地当前目录中，是不存在test-server:/etc/nginx/conf.d/*，所以匹配失败。默认情况下，bash 在匹配失败时就使用原来的内容，zsh 则报告一个no matches的错误。 解决方案在zsh中执行setopt nonomatch，告诉它不要报告no matches的错误，而是当匹配失败时直接使用原来的内容。 实际上，不管是 bash 还是 zsh，不管设置了什么选项，只要把test-server:/etc/nginx/conf.d/*加上引号，如&quot;test-server:/etc/nginx/conf.d/*&quot;，就可解决问题。 当然根本的解决办法还是告诉zsh不要报告no matches错误。 执行下面的命令可以一劳永逸： 123$ echo &quot;setopt nonomatch&quot; &gt;&gt; ~/.zshrc或$ echo &quot;set -o nonomatch&quot; &gt;&gt; ~/.zshrc","categories":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"}],"tags":[{"name":"scp","slug":"scp","permalink":"https://www.silenceboy.com/tags/scp/"},{"name":"zsh","slug":"zsh","permalink":"https://www.silenceboy.com/tags/zsh/"}]},{"title":"git clone 出现ssh: connect to host github.com port 22: Connection timed out解决方案","slug":"git-clone-出现ssh-connect-to-host-github-com-port-22-Connection-timed-out解决方案","date":"2020-03-04T05:07:40.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2020/03/04/git-clone-出现ssh-connect-to-host-github-com-port-22-Connection-timed-out解决方案/","link":"","permalink":"https://www.silenceboy.com/2020/03/04/git-clone-出现ssh-connect-to-host-github-com-port-22-Connection-timed-out解决方案/","excerpt":"","text":"物理机服务器，安装git之后，想从github上clone自己的项目运行，ssh key已经配置过, 但在执行git clone命令时出现了如下报错： 1234ssh: connect to host github.com port 22: Connection timed outfatal: 无法读取远程仓库。请确认您有正确的访问权限并且仓库存在。 解决方案在系统~/.ssh目录下执行touch config命令新建config文件，并修改文件权限： 1sudo chmod 600 config 然后在config文件中添加如下内容： 123456Host github.comUser email@qq.com // 替换成自己的github登录邮箱Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 然后设置： 12git config --global user.name &quot;XXX&quot;git config --global user.email XXX@xx.com 此时再去执行git clone命令，一切正常。","categories":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"}]},{"title":"mysql5.7 ibtmp1文件过大","slug":"mysql5-7-ibtmp1文件过大","date":"2019-12-26T08:29:14.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2019/12/26/mysql5-7-ibtmp1文件过大/","link":"","permalink":"https://www.silenceboy.com/2019/12/26/mysql5-7-ibtmp1文件过大/","excerpt":"","text":"服务器上的磁盘被占满，通过一下命令查找服务器上的大文件： 1$ sudo find / -type f -size +800M -print0 | xargs -0 du -h | sort -nr 经过排查后发现，/var/lib/mysql目录下面有一个ibtmp1的文件特别大，有64G 。 ibtmp1是个什么东西呢？查看官方文档后发现这是非压缩的innodb临时表的独立表空间。通过innodb_temp_data_file_path参数指定文件的路径，文件名和大小，默认配置为ibtmp1:12M:autoextend，也就是说在支持大文件的系统这个文件大小是可以无限增长的。 解决办法： 修改my.cnf配置文件： 1innodb_temp_data_file_path = ibtmp1:12M:autoextend:max:5G 设置innodb_fast_shutdown参数 1SET GLOBAL innodb_fast_shutdown = 0; #InnoDB does a slow shutdown, a full purge and a change buffer merge before shutting down 关闭mysql服务 1systemctl stop mysqld.service 删除ibtmp1文件 启动mysql服务 1systemctl start mysqld.service","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"}]},{"title":"pm2日志拆分","slug":"pm2日志拆分","date":"2019-12-20T03:41:48.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2019/12/20/pm2日志拆分/","link":"","permalink":"https://www.silenceboy.com/2019/12/20/pm2日志拆分/","excerpt":"","text":"pm2默认会将日志文件写入家目录下的 .pm2/logs 目录中，但是pm2的日志文件不能自动分割，这会导致一个文件不断变大，不但影响性能，查看这些日志也会带来麻烦。 pm2的日志切割模块pm2-logrotate 安装pm2-logrotate： 1$ pm2 install pm2-logrotate 设置切割规则 12345678910111213141. 设置文件大小为100M，大于等于开始切割pm2 set pm2-logrotate:max_size 100M2.设置文件切割的监控间，监控间隔比较大，可能会使切割出的文件大小和max_size有出入pm2 set pm2-logrotate:workerInterval 13. 设置文件最多多少个，超过则删除pm2 set pm2-logrotate:retain 104. 设置文件是否压缩$ pm2 set pm2-logrotate:compress false5. 设置文件命名格式$ pm2 set pm2-logrotate:dateFormat YYYY-MM-DD_HH-mm-ss 更新pm2 执行一下命令使pm2配置生效 1$ pm2 update","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"pm2","slug":"pm2","permalink":"https://www.silenceboy.com/tags/pm2/"}]},{"title":"ssh使用ProxyCommand连接阿里云内网服务器","slug":"ssh使用ProxyCommand连接阿里云内网服务器","date":"2019-10-21T05:44:57.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2019/10/21/ssh使用ProxyCommand连接阿里云内网服务器/","link":"","permalink":"https://www.silenceboy.com/2019/10/21/ssh使用ProxyCommand连接阿里云内网服务器/","excerpt":"","text":"在没有发现proxyCommand命令的好处之前，本地连接想要访问内网服务器，需要先ssh连接开放外网ip并且与我们要访问的目标主机在同一个内网环境的esc服务器，然后将该服务器作为跳板机，在该服务器上ssh连接内网服务器。该操作非常麻烦。使用proxyCommand能够很方便的解决该问题。 proxyCommand配置修改~/.ssh/config： 123456789Host tiaobanHostname 跳板机的ipPort 跳板机的端口(如果是非22的需要填写)User root(如果非root,换成跳板机的用户)Host targetHostname 目标机的IPPort 跳板机的端口(如果是非22的需要填写)User root(如果非root,换成跳板机的用户)ProxyCommand ssh -q -x -W %h:%p tiaoban 这儿的%h表示要连接的目标机,也就是Hostname指定的ip或者主机名,%p表示要连接到目标机的端口.这儿可以直接写死固定值,但是使用%h和%p可以保证在Hostname和Port变化的情况下ProxyCommand这行不用跟着变化. 然后我们直接ssh target,可以看到直接就连接上了.","categories":[{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/categories/ssh/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/tags/ssh/"}]},{"title":"linux 添加只读用户","slug":"linux-添加只读用户","date":"2019-10-16T08:31:43.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2019/10/16/linux-添加只读用户/","link":"","permalink":"https://www.silenceboy.com/2019/10/16/linux-添加只读用户/","excerpt":"","text":"这里未使用rbash新建用户，使用rbash新建只读用户不能使用cd等内置命令。 添加用户 1# useradd -m test 设置密码 1# passwd test 修改用户的shell配置文件 12# chown root. /home/test/.bash_profile# chmod 755 /home/test/.bash_profile 修改/home/test/.bash_profile配置文件 将PATH改为$HOME/.bin 123456789101112# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then . ~/.bashrcfi# User specific environment and startup programs# PATH=$PATH:$HOME/.local/bin:$HOME/binPATH=$HOME/.binexport PATH 创建用户.bin目录 1# mkdir /home/test/.bin 将允许执行的命令链接到/home/test/.bin目录 123456789ln -s /usr/bin/wc /home/test/.bin/wcln -s /usr/bin/tail /home/test/.bin/tailln -s /usr/bin/more /home/test/.bin/moreln -s /usr/bin/cat /home/test/.bin/catln -s /usr/bin/grep /home/test/.bin/grepln -s /usr/bin/find /home/test/.bin/findln -s /usr/bin/pwd /home/test/.bin/pwdln -s /usr/bin/ls /home/test/.bin/lsln -s /usr/bin/less /home/test/.bin/less 之后使用创建的用户登录系统，用户只拥有只读权限，只能使用软连接的命令。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"Docker启用TLS进行安全配置","slug":"Docker启用TLS进行安全配置","date":"2019-09-29T01:56:59.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2019/09/29/Docker启用TLS进行安全配置/","link":"","permalink":"https://www.silenceboy.com/2019/09/29/Docker启用TLS进行安全配置/","excerpt":"","text":"之前开启了docker的2375 Remote API，由于没有启用TLS，导致服务器被入侵，安装了挖矿程序。所以如果想开通docker远程访问，就必须做好安全验证。 文中出现的$HOST指的是主机ip， 实际执行时用主机ip替换即可。 在Docker守护程序的主机上，生成CA私钥和公钥：1234567891011121314151617181920212223242526272829// 生成 CA 私钥root@docker-manager:~# openssl genrsa -aes256 -out ca-key.pem 4096Generating RSA private key, 4096 bit long modulus (2 primes).........................................................................++++.............................................++++e is 65537 (0x010001)// 需要输入两次自定义密码Enter pass phrase for ca-key.pem:Verifying - Enter pass phrase for ca-key.pem:// 生成 CA 公钥root@docker-manager:~# openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem// 这里需要输入第一步设置的密码Enter pass phrase for ca-key.pem:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:zhejiangLocality Name (eg, city) []:hangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Docker IncOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []: $HOSTEmail Address []: 创建服务器密钥和证书签名请求(CSR)1234567root@docker-manager:~# openssl genrsa -out server-key.pem 4096Generating RSA private key, 4096 bit long modulus (2 primes)......................................................................................................++++................++++e is 65537 (0x010001)root@docker-manager:~# openssl req -subj &quot;/CN=$HOST&quot; -sha256 -new -key server-key.pem -out server.csr 用CA签署公钥由于可以通过IP地址和DNS名称建立TLS连接，因此在创建证书时需要指定IP地址。例如，允许使用172.16.132.200和127.0.0.1进行连接： 这里遇到一个坑，如果IP后不指定本机ip，远程无法连接，不知道是不是配置哪里有问题，目前我会在下面的命令中添加IP:$HOST去解决问题 1root@docker-manager:~# echo subjectAltName = DNS:$HOST,IP:172.16.132.200,IP:127.0.0.1 &gt;&gt; extfile.cnf 将Docker守护程序密钥的扩展用法属性设置为仅用于服务器身份验证： 1root@docker-manager:~# echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf 生成服务端签名证书123456root@docker-manager:~# openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnfSignature oksubject=CN = 172.16.132.200Getting CA Private Key// 输入最开始设置的密码Enter pass phrase for ca-key.pem: 创建客户端密钥和证书签名请求1234567root@docker-manager:~# openssl genrsa -out key.pem 4096Generating RSA private key, 4096 bit long modulus (2 primes)..++++...............................................................................................................................................................................................................++++e is 65537 (0x010001)root@docker-manager:~# openssl req -subj &apos;/CN=client&apos; -new -key key.pem -out client.csr 为了使密钥适合客户端身份验证，请创建一个新的扩展配置文件： 1root@docker-manager:~# echo extendedKeyUsage = clientAuth &gt; extfile-client.cnf 生成客户端签名证书123456root@docker-manager:~# openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnfSignature oksubject=CN = clientGetting CA Private Key// 输入最开始设置的密码Enter pass phrase for ca-key.pem: 删除和修改文件权限生成后cert.pem，server-cert.pem您可以安全地删除两个证书签名请求和扩展配置文件： 12345root@docker-manager:~# rm -v client.csr server.csr extfile.cnf extfile-client.cnfremoved &apos;client.csr&apos;removed &apos;server.csr&apos;removed &apos;extfile.cnf&apos;removed &apos;extfile-client.cnf&apos; 为了保护您的钥匙免遭意外损坏，请删除其写权限。要使它们仅供您阅读，请按以下方式更改文件模式： 1234root@docker-manager:~# chmod -v 0400 ca-key.pem key.pem server-key.pemmode of &apos;ca-key.pem&apos; changed from 0600 (rw-------) to 0400 (r--------)mode of &apos;key.pem&apos; changed from 0600 (rw-------) to 0400 (r--------)mode of &apos;server-key.pem&apos; changed from 0600 (rw-------) to 0400 (r--------) 证书可以在世界范围内读取，但您可能希望删除写访问权限以防止意外损坏： 1234root@docker-manager:~# chmod -v 0444 ca.pem server-cert.pem cert.pemmode of &apos;ca.pem&apos; changed from 0644 (rw-r--r--) to 0444 (r--r--r--)mode of &apos;server-cert.pem&apos; changed from 0644 (rw-r--r--) to 0444 (r--r--r--)mode of &apos;cert.pem&apos; changed from 0644 (rw-r--r--) to 0444 (r--r--r--) 修改docker配置并重启docker编辑docker配置文件（我的是ubuntu机器）：vim /lib/systemd/system/docker.service 添加如下行： 1ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/root/docker/ca.pem --tlscert=/root/docker/server-cert.pem --tlskey=/root/docker/server-key.pem -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 重启docker服务： 12systemctl daemon-reloadsystemctl restart docker 查看端口号： 1234567root@docker-manager:~# netstat -plntActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp6 0 0 :::80 :::* LISTEN 858/nginx: master p tcp6 0 0 :::25 :::* LISTEN 1662/master tcp6 0 0 :::2375 :::* LISTEN 25582/dockerd tcp6 0 0 :::2377 :::* LISTEN 25582/dockerd 客户端远程安全连接将 ca.pem cert.pem key.pem三个文件通过 scp 下载到 客户端机器。 远程连接命令，路径根据实际情况填写： 123456docker --tlsverify \\ --tlscacert=/home/docker/ca.pem \\ --tlscert=/home/docker/cert.pem \\ --tlskey=/home/docker/key.pem \\ -H=172.16.132.200:2375 \\ info 把密钥放入 ~/.docker 文件夹中： 每次操作需要跟那么多参数，太麻烦了。我们可以把ca.pem cert.pem key.pem三个文件放入客户端~/.docker中，然后配置环境变量就可以简化命令了。 123$ export DOCKER_HOST=tcp://172.16.132.200:2375 DOCKER_TLS_VERIFY=1$ docker info","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"}]},{"title":"docker安装jira并破解","slug":"docker安装jira并破解","date":"2019-09-03T12:15:22.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2019/09/03/docker安装jira并破解/","link":"","permalink":"https://www.silenceboy.com/2019/09/03/docker安装jira并破解/","excerpt":"","text":"下载镜像1$ docker pull cptactionhank/atlassian-jira 运行容器12$ docker volume create jira_home$ docker run -d -p 8080:8080 --name jira --restart always -v jira_home:/var/atlassian/jira cptactionhank/atlassian-jira:latest 下载破解文件123$ wget https://github.com/silenceboychen/some-software/raw/master/Jira/mysql-connector-java-5.1.25-bin.jar$ wget https://github.com/silenceboychen/some-software/raw/master/Jira/atlassian-universal-plugin-manager-plugin-2.22.4.jar$ wget https://github.com/silenceboychen/some-software/raw/master/Jira/atlassian-extras-3.2.jar 添加mysql驱动程序mysql配置 12$ docker cp mysql-connector-java-5.1.25-bin.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/$ docker restart jira nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657upstream jira&#123; server 127.0.0.1:8080;&#125;# http配置#server &#123;# listen 80;# server_name jira.domain.com;# access_log /var/log/nginx/jira.domain.com-access.log;# error_log /var/log/nginx/jira.domain.com-error.log;# location / &#123;# proxy_pass_header Server;# proxy_set_header Host $http_host;# proxy_set_header X-Real-IP $remote_addr;# proxy_set_header X-Scheme $scheme;# proxy_pass http://jira;# &#125;#&#125;# https配置server &#123; #侦听443端口，这个是ssl访问端口 listen 443; #定义使用 访问域名 server_name jira.iblackvip.com; access_log /var/log/nginx/jira.domain.com.access.log; error_log /var/log/nginx/jira.domain.com.error.log; ssl on; ssl_certificate /etc/nginx/cert/jira.domain.com.pem; ssl_certificate_key /etc/nginx/cert/jira.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://jira; &#125; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;&#125;server &#123; # 80端口是http正常访问的接口 listen 80; server_name jira.domain.com; # 在这里，我做了https全加密处理，在访问http的时候自动跳转到https rewrite ^(.*) https://$host$1 permanent;&#125; Web设置 浏览器访问JiraWeb，语言可以设为中文，选择「我将设置它自己」——「下一步」 数据库设置，数据库类型选择「MySQL」，接着填入你的MySQL连接信息（需要你在你的MySQL数据库中创建数据库，数据库的字符类型必须是utf8），测试可以连接之后点击「下一步」 设置应用程序的属性——「下一步」 申请许可证关键字，点击「生成Jira试用许可证」 需要注册账号，注册完之后重新回到这个页面，选择相关信息，点击「Generate License」 点击「Yes」 页面就会带着你的许可证关键字回到Jira的设置页面，接着点击「下一步」 等待一会就进入设置管理员页面，填入一些信息即可，接着「下一步」 点击「完成」即完成设置 破解jira拷贝文件到容器内： 12$ docker cp atlassian-extras-3.2.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/$ docker cp atlassian-universal-plugin-manager-plugin-2.22.4.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/ 重启容器，破解结束： 1$ docker restart jira 查看jira页面设置-》应用程序，我们可以很明显的看到jira我们可以使用到2033年。","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"jira","slug":"jira","permalink":"https://www.silenceboy.com/tags/jira/"}]},{"title":"linux系统中root用户被提示：Operation not permitted","slug":"linux系统中root用户被提示：Operation-not-permitted","date":"2019-08-27T08:01:26.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2019/08/27/linux系统中root用户被提示：Operation-not-permitted/","link":"","permalink":"https://www.silenceboy.com/2019/08/27/linux系统中root用户被提示：Operation-not-permitted/","excerpt":"","text":"问题在修改文件权限时遇到如下报错： 12root@docker-manager:~/.ssh# chmod 600 authorized_keys chmod: changing permissions of &apos;authorized_keys&apos;: Operation not permitted 解决方法这里涉及到chattr和lsattr的知识： chattr是用来更改文件属性，lsattr可用来查看文件的属性，执行命令lsattr authorized_keys便可以看到当前文件的属性； 12root@docker-manager:~/.ssh# lsattr authorized_keys ----ia--------e--- authorized_keys 可以发现当前文件有个i属性，查阅命令帮助文档可以看到有i属性的文件是不能修改的，更不可被删除，即使是root用户也不可。 这里只需要去除i属性就可以修改文件权限。 123root@docker-manager:~/.ssh# chattr -i authorized_keys root@docker-manager:~/.ssh# lsattr authorized_keys -----a--------e--- authorized_keys chattr命令Linux chattr命令用于改变文件属性。 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： 12345678a：让文件或目录仅供附加用途。b：不更新文件或目录的最后存取时间。c：将文件或目录压缩后存放。d：将文件或目录排除在倾倒操作之外。i：不得任意更动文件或目录。s：保密性删除文件或目录。S：即时更新文件或目录。u：预防意外删除。 参数 1234567891011-R 递归处理，将指定目录下的所有文件及子目录一并处理。-v&lt;版本编号&gt; 设置文件或目录版本。-V 显示指令执行过程。+&lt;属性&gt; 开启文件或目录的该项属性。-&lt;属性&gt; 关闭文件或目录的该项属性。=&lt;属性&gt; 指定文件或目录的该项属性。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"部署Docker集群并使用Portainer管理","slug":"部署Docker集群并使用Portainer管理","date":"2019-08-14T04:34:06.000Z","updated":"2021-09-27T07:27:40.449Z","comments":true,"path":"2019/08/14/部署Docker集群并使用Portainer管理/","link":"","permalink":"https://www.silenceboy.com/2019/08/14/部署Docker集群并使用Portainer管理/","excerpt":"","text":"在有多台Docker的情况下，进行集群管理就十分重要了，Portainer也支持集群管理，Portainer可以和Swarm一起来进行集群管理操作。 环境要求 需要提前安装docker环境，docker安装教程。 使用docker安装portainer， 安装教程 搭建Swarm集群环境基本环境 用两台机器来搭建(都是ubuntu18.04系统) 12172.16.132.200 docker-manager172.16.132.201 dcoker-worker01 修改两台机器的主机名并做hosts 172.16.132.200机器 12345# hostnamectl set-hostname docker-manager# echo &quot;docker-manager&quot; &gt; /etc/hostname# vim /etc/hosts172.16.132.200 docker-manager172.16.132.201 dcoker-worker01 172.16.132.201机器 12345# hostnamectl set-hostname docker-worker01# echo &quot;docker-worker01&quot; &gt; /etc/hostname# vim /etc/hosts172.16.132.200 docker-manager172.16.132.201 dcoker-worker01 开通对外2375端口（方便portainer管理）12345678910111213// 先做备份# cp /lib/systemd/system/docker.service /lib/systemd/system/docker.service.bak # vim /lib/systemd/system/docker.service 找到ExecStart行改成这样的： ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375# systemctl daemon-reload# systemctl restart docker 重启docker服务，使用service docker restart也可以# netstat -plnt 查看端口号使用Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 20917/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 742/sshd tcp6 0 0 :::2375 :::* LISTEN 5836/dockerd tcp6 0 0 :::7946 :::* LISTEN 5836/dockerd tcp6 0 0 :::80 :::* LISTEN 20917/nginx: master Swarm集群创建初始化Swarm 12345678# docker swarm init --advertise-addr 172.16.132.200Swarm initialized: current node (7ggeai3dlqn0j8gkxjs46y250) is now a manager.To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-0n04bao3bkte48prmcf1xfmlfrk9zh19b9u16ysb63yhvgjiyi-3w0rd58keboh52zul8xcjfrof 172.16.132.200:2377To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions. 上面命令执行后，该机器自动加入到swarm集群。这个会创建一个集群token，获取全球唯一的 token，作为集群唯一标识。后续将其他节点加入集群都会用到这个token值。 123456789--advertise-addr 指定与其他 node 通信的地址。docker swarm init 输出告诉我们：① swarm 创建成功，swarm-manager 成为 manager node。② 添加 worker node 需要执行的命令。③ 添加 manager node 需要执行的命令。 添加集群节点 在docker-worker01机器上执行以下添加集群节点的操作命令: 1# docker swarm join --token SWMTKN-1-0n04bao3bkte48prmcf1xfmlfrk9zh19b9u16ysb63yhvgjiyi-3w0rd58keboh52zul8xcjfrof 172.16.132.200:2377 如后续要加入其他更多的节点,添加操作也是执行这个命令. 查看集群节点 在docker-manager机器上执行查看,因为此时它是swarm集群的leader节点: 1234root@docker-manager:~# docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION7ggeai3dlqn0j8gkxjs46y250 * docker-manager Ready Active Leader 18.09.71v09483w8dczd36bmtruzm2ix docker-node01 Ready Active 19.03.1 最后查看下两个机器上的2375端口是否都已经开启了 1234567[root@docker-manager ~]# lsof -i:2375COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdockerd 13785 root 5u IPv6 4518841 0t0 TCP *:2375 (LISTEN)[root@docker-woeker01 ~]# lsof -i:2375COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdockerd-c 2966 root 5u IPv6 3602947 0t0 TCP *:2375 (LISTEN) 部署Portainer12345$ docker volume create portainer_data$ docker run -d -p 8000:8000 -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9b051147a4c2 portainer/portainer &quot;/portainer&quot; 20 hours ago Up 18 hours 0.0.0.0:9000-&gt;9000/tcp portainer 访问http://172.16.132.200:9000, 同样首次登陆需要注册用户，给admin用户设置密码： 集群模式, 这样一定要选择Remote, 输入docker-worker01的ip，然后点击Connect。 同样点击左边栏的”Endpoints” - “+add endpoint”, 添加集群节点: 添加之后,点击左边栏的”Home”, 右边就可以看到节点信息了,可以进行切换操作.","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"portainer","slug":"portainer","permalink":"https://www.silenceboy.com/tags/portainer/"}]},{"title":"ubuntu18.04安装mysql并允许远程访问","slug":"ubuntu18-04安装mysql并允许远程访问","date":"2019-07-23T10:29:37.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2019/07/23/ubuntu18-04安装mysql并允许远程访问/","link":"","permalink":"https://www.silenceboy.com/2019/07/23/ubuntu18-04安装mysql并允许远程访问/","excerpt":"","text":"安装1$ apt-get install mysql-server mysql-client 字符集修改utf8进入mysql命令终端：（默认root密码为空）: 1$ mysql -u root -p 12345678910111213mysql&gt; show variables like &apos;char%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 12345678mysql&gt; show variables like &apos;collation%&apos;;+----------------------+-------------------+| Variable_name | Value |+----------------------+-------------------+| collation_connection | utf8_general_ci || collation_database | latin1_swedish_ci || collation_server | latin1_swedish_ci |+----------------------+-------------------+ 修改字符集： 123456$ vim /etc/mysql/mysql.conf.d/mysqld.cnf// 在文件末尾添加以下内容：collation-server = utf8_unicode_ciinit-connect=&apos;SET NAMES utf8&apos;character-set-server = utf8 重启后字符集修改为utf8： 1$ service mysql restart 修改端口号修改mysql配置文件，然后重启即可生效： 1234$ vim /etc/mysql/mysql.conf.d/mysqld.cnf// 修改以下内容：port = 6033 登录权限问题查看当前用户： 12345678910mysql&gt; SELECT User,Host FROM mysql.user;+------------------+-----------+| User | Host |+------------------+-----------+| debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+------------------+-----------+4 rows in set (0.00 sec) 删除root账号： 123456789101112mysql&gt; DROP USER &apos;root&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT User,Host FROM mysql.user;+------------------+-----------+| User | Host |+------------------+-----------+| debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost |+------------------+-----------+3 rows in set (0.00 sec) 重新创建root： 12345678910111213mysql&gt; CREATE USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT User,Host FROM mysql.user;+------------------+-----------+| User | Host |+------------------+-----------+| root | % || debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost |+------------------+-----------+4 rows in set (0.00 sec) 授权： 12345mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; WITH GRANT OPTION;Query OK, 0 rows affected (0.01 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 退出mysql，修改配置文件： 12$ vim /etc/mysql/mysql.conf.d/mysqld.cnf注释这一行：bind-address:127.0.0.1 重新启动mysql: 1$ service mysql restart","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"}]},{"title":"docker安装gitlab","slug":"docker安装gitlab","date":"2019-07-15T02:49:01.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2019/07/15/docker安装gitlab/","link":"","permalink":"https://www.silenceboy.com/2019/07/15/docker安装gitlab/","excerpt":"","text":"docker安装gitlabGitLab 分为 社区版（Community Edition，缩写为 CE）和 企业版（Enterprise Edition，缩写为 EE）。社区版是免费的，而企业版包含一些收费服务，一般来说个人开发者用社区版就足够了。 下载镜像 首先需要先下载 GitLab CE 的镜像，使用下面的命令进行下载，因为文件较大，所以可能需要一点时间，耐心等待即可。 12# 不加 tag 则默认为最新版本 latest$ docker pull gitlab/gitlab-ce 启动运行123456789$ docker run --detach \\ --hostname gitlab.example.com \\ --publish 8443:443 --publish 8880:80 --publish 8222:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 说明: –hostname gitlab.example.com: 设置主机名或域名 –publish 8443:443：将http：443映射到外部端口8443 –publish 8880:80：将web：80映射到外部端口8880 –publish 8222:22：将ssh：22映射到外部端口8222 –name gitlab: 运行容器名 –restart always: 自动重启 –volume /srv/gitlab/config:/etc/gitlab: 挂载目录 –volume /srv/gitlab/logs:/var/log/gitlab: 挂载目录 –volume /srv/gitlab/data:/var/opt/gitlab: 挂载目录 运行成功之后，可以使用下面的命令查看容器运行状态： 1$ docker ps 可以看到 GitLab 已经在运行了，有一个属性 STATUS 为 health: starting，说明 gitlab 的服务正在启动中，还没有启动完毕。等这个状态变成 healthy 时则说明已经部署完成，可以访问了。 访问gitlab启动成功后，浏览器访问http://ip:8880, 即可访问。为了使用域名访问，需要配置nginx： 1234567891011121314151617upstream gitlab&#123; server 127.0.0.1:8880;&#125;server &#123; listen 80; server_name gitlab.example.com; access_log /var/log/nginx/gitlab.example.com-access.log; error_log /var/log/nginx/gitlab.example.com-error.log; location / &#123; proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://gitlab; &#125;&#125; nginx重启配置生效后，浏览器访问http://gitlab.example.com 即可正常访问。 首次访问需要为root用户设置密码，设置完成后需要登录，默认用户名为：root， 密码为刚刚设置的密码。 配置邮件服务器想要让 GitLab 给你发送邮件，还要配置一下邮件服务器，这里以QQ邮箱的 IMAP/SMTP服务 来配置。 打开邮箱-&gt;设置-&gt;账户，然后开启 IMAP/SMTP服务，然后根据文档获取 授权码 ，这步比较重要。 然后跳转至挂载目录 /srv/gitlab/config/ 编辑gitlab.rb 文件，找到 Email Settings的注释位置，然后修改以下内容： 1234567891011### Email Settingsgitlab_rails[&apos;smtp_enable&apos;] = true # 开启 SMTP 功能gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.qq.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 465 # 端口不可以选择587，测试过会发送邮件失败gitlab_rails[&apos;smtp_user_name&apos;] = &quot;test@qq.com&quot; # 你的邮箱账号gitlab_rails[&apos;smtp_password&apos;] = &quot;1324dasd&quot; # 授权码，不是密码gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;smtp_tls&apos;] = truegitlab_rails[&apos;gitlab_email_from&apos;] = &apos;test@qq.com&apos; # 发件人信息，必须跟‘smtp_user_name’保持一致，否则报错gitlab_rails[&apos;smtp_domain&apos;] = &quot;qq.com&quot; # 修改并不影响 配置完成后保存，然后输入下面的命令使配置生效。 1$ docker exec gitlab gitlab-ctl reconfigure 使配置生效之后我们可以使用 gitlab 自带的工具进行一下测试。依次执行下面的命令： 12345678# 开启 gitlab 的 bash 工具$ docker exec -it gitlab bash# 开启 gitlab-rails 工具$ gitlab-rails console production# 发送邮件进行测试Notify.test_email(&apos;test_001@123.com&apos;, &apos;Message Subject&apos;, &apos;Message Body&apos;).deliver_now 测试完成之后退出gitlab的bash工具，重启 gitlab 即可。 1$ docker restart gitlab 修改SSH因为项目启动时gitlab内部的22端口号映射到宿主机的端口号是8222，所以需要配置gitlab的ssh端口号： 找到如下内容，将端口号修改为8222. 1gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 8222 配置完成后保存，然后输入下面的命令使配置生效。 12$ docker exec gitlab gitlab-ctl reconfigure$ docker restart gitlab 配置 Git 仓库访问路径在之前第一次运行 gitlab 容器的时候，有一个参数 hostname 为 gitlab.example.com , 如果配置了域名可以忽略这一步，如果你没有配置相应域名的话，你的仓库的地址将会变为下面这样： 12ssh : git@gitlab.example.com:test/test.githttp：gitlab.example.com/test/test.git 如果域名不存在的话，这个地址是无法进行 clone 的。 为了解决这个问题，我们可以设置成 IP 或 你配置了的域名来访问。 打开文件 /srv/gitlab/config/gitlab.rb 文件并找到 1# external_url &apos;GENERATED_EXTERNAL_URL&apos; 这行，去掉注释，并按照下面的格式修改。 1234567891011# ip 形式external_url &apos;http://192.168.1.44&apos;# 域名形式external_url &apos;http://JemGeek.com&apos;# 子域名external_url &apos;http://gitlab.JemGeek.com&apos;# 其他形式external_url &apos;http://JemGeek.com/gitlab&apos; 以上形式都是可以的。修改完成后，输入命令: 1$ docker exec gitlab gitlab-ctl reconfigure 使配置生效，然后重启 gitlab 即可。 升级参照官方的说明， 将原来的容器停止， 然后删除： 12$ docker stop gitlab$ docker rm gitlab 然后重新拉一个新版本的镜像下来， 1$ docker pull gitlab/gitlab-ce 使用原来的运行命令运行： 12345678910$ docker run --detach \\ --hostname gitlab.example.com \\ --publish 8443:443 --publish 8880:80 --publish 8222:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ --privileged=true \\ gitlab/gitlab-ce:latest GitLab 在初次运行的时候会自动升级， 为了预防万一， 还是建议先备份一下 /srv/gitlab/ 这个目录。 大版本升级（例如从 8.7.x 升级到 8.8.x）用上面的操作有可能会出现错误， 如果出现错误可以尝试登录到容器内部, 依次执行下面的命令： 12$ gitlab-ctl reconfigure$ gitlab-ctl restart","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.silenceboy.com/tags/gitlab/"}]},{"title":"js打印带颜色的 console 信息","slug":"js打印带颜色的-console-信息","date":"2019-07-12T06:30:24.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2019/07/12/js打印带颜色的-console-信息/","link":"","permalink":"https://www.silenceboy.com/2019/07/12/js打印带颜色的-console-信息/","excerpt":"","text":"打印红色的hello world: 1console.log(`\\x1b[31mhello world\\x1b[31m`) 以下是可以使用的文本命令的参考： 前景色（文字颜色）： 12345678\\x1b[30m = 黑色\\x1b[31m = 红色\\x1b[32m = 绿色\\x1b[33m = 黄色\\x1b[34m = 蓝色\\x1b[35m = 洋红色\\x1b[36m = 青色\\x1b[37m = 白色 背景色： 12345678\\x1b[40m = 黑色\\x1b[41m = 红色\\x1b[42m = 绿色\\x1b[43m = 黄色\\x1b[44m = 蓝色\\x1b[45m = 洋红色\\x1b[46m = 青色\\x1b[47m = 白色 其他： 1234567\\x1b[0m = 清除样式\\x1b[1m = 加粗\\x1b[2m = 半透明\\x1b[4m = 下划线\\x1b[5m = 闪动\\x1b[7m = 取反：背景色变前景色 前景色变背景色\\x1b[8m = 看不见 但位置还留着","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"eval()与new Function()","slug":"eval-与new-Function","date":"2019-04-14T12:55:54.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2019/04/14/eval-与new-Function/","link":"","permalink":"https://www.silenceboy.com/2019/04/14/eval-与new-Function/","excerpt":"","text":"evaleval接受字符串参数，解析其中的js代码。如果编译失败，会抛出异常，否则执行其中的代码，计算返回值。 12eval(&apos;2+2&apos;); // 4eval(&apos;console.log(&quot;ok&quot;)&apos;); // ok 在实际应用中，通常这样转换JSON。 12var jsonStr = &apos;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&apos;;eval(&apos;(&apos; + jsonStr + &apos;)&apos;); 为什么要加括号呢？ 因为js中{}通常是表示一个语句块，eval只会计算语句块内的值进行返回。加上括号就变成一个整体的表达式。 12console.log( eval(&apos;&#123;&#125;&apos;) ); // undefindconsole.log( eval(&apos;(&#123;&#125;)&apos;) ); // Object &#123;&#125; 使用eval需要注意执行作用域 1234567var s = 1;function a() &#123; eval(&apos;var s=2&apos;); console.log(s);&#125;a(); // 2console.log(s); // 1 在局部环境使用eval便会创建局部变量。可以显示指定eval调用者来改变上下文环境。 1234567var s = &apos;global&apos;;function a() &#123; eval(&apos;var s = &quot;local&quot;&apos;); console.log(s); // local console.log(eval(&apos;s&apos;)); // local console.log(window.eval(&apos;s&apos;)); // global&#125; Function在之前我对于Function的了解只限于“定义方法的一种非主流方式”。却忽略了Function与eval相同的字符串参数特性。 语法：var func = new Function(arg1, arg2, ..., functionBody); 实例： 12var add = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a+b;&apos;);console.log( add(2, 3) ); // 5 由于其形参使用字符串的方式表示，也可以使用1个字符串来描述多个形参。 12var add = new Function(&apos;a, b&apos;, &apos;return a+b;&apos;);console.log( add(2, 3) ); // 5 在转换JSON的实际应用中，只需要这么做。 12var jsonStr = &apos;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&apos;, json = (new Function(&apos;return &apos; + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。如果可以，请用更好的方法替代。 在一些特殊的运用场合，也有一些合理运用的实践。比如模板解析等。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"js实现凯撒密码 (Caesars Cipher)","slug":"js实现凯撒密码-Caesars-Cipher","date":"2019-04-04T09:31:04.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2019/04/04/js实现凯撒密码-Caesars-Cipher/","link":"","permalink":"https://www.silenceboy.com/2019/04/04/js实现凯撒密码-Caesars-Cipher/","excerpt":"","text":"凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。 所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 判断是否为大写也不难，我们可以通过 .charCodeAt() 返回的 ASCII 码来判断 至于加密的实现，我们可以像这样分情况讨论： 如果当前字符为 A - M 之间，对应的 ASCII 码范围就是 65 - 77，那么 ROT13 加密应该给它的 ASCII 码加 13 如果当前字符为 N - Z 之间，对应的 ASCII 码范围就是 78 - 90，那么 ROT13 加密应该给它的 ASCII 码减 13 如果当前字符为其他 (小写，空格或特殊符号)，那就不应该执行任何操作 12345678910111213141516171819function rot13(str) &#123; let result = &quot;&quot;; for (let i = 0; i &lt; str.length; i++) &#123; const currentCode = str[i].charCodeAt(); if (currentCode &gt; 90 || currentCode &lt; 65) &#123; // 非大写字符 result += String.fromCharCode(currentCode); &#125; else if (currentCode &lt; 78) &#123; // 大写字符 A - M result += String.fromCharCode(currentCode + 13); &#125; else &#123; // 大写字符 N - Z result += String.fromCharCode(currentCode - 13); &#125; &#125; return result;&#125; 通过求余数来进行优化： 123function rot13(str) &#123; return str.replace(/[A-Z]/g, char =&gt; String.fromCharCode(char.charCodeAt() % 26 + 65));&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"}]},{"title":"使用git进行远程分支同步","slug":"使用git进行远程分支同步","date":"2019-04-03T02:48:12.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2019/04/03/使用git进行远程分支同步/","link":"","permalink":"https://www.silenceboy.com/2019/04/03/使用git进行远程分支同步/","excerpt":"","text":"在git项目目录下执行git remote show origin命令： 12345678910111213➜ api git:(419788c) ✗ git remote show origin* remote origin Fetch URL: git@github.com:silenceboychen/blog.git Push URL: git@github.com:silenceboychen/blog.git HEAD branch: master Remote branches: alibeta tracked dev tracked master tracked production tracked refs/remotes/origin/feat-10.9 stale (use &apos;git remote prune&apos; to remove) refs/remotes/origin/feat-docker stale (use &apos;git remote prune&apos; to remove) refs/remotes/origin/feat_avatar stale (use &apos;git remote prune&apos; to remove) 可以看到有一些状态为stale的分支，这些分支都已经被删除了，但是我们本机上还有记录，这些记录不会通过git pull自动清除。 为了删除这些分支，实现和远程分支的同步，可以执行git remote prune origin 123456➜ api git:(419788c) ✗ git remote prune originPruning originURL: git@github.com:silenceboychen/blog.git * [pruned] origin/feat-10.9 * [pruned] origin/feat-docker * [pruned] origin/feat_avatar 再次查看，发现那些无效分支已经在本机被删除： 1234567891011121314➜ api git:(419788c) ✗ git remote show origin* remote origin Fetch URL: git@github.com:silenceboychen/blog.git Push URL: git@github.com:silenceboychen/blog.git HEAD branch: master Remote branches: alibeta tracked dev tracked master tracked production tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (local out of date)","categories":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"}]},{"title":"关于js的浅拷贝与深拷贝","slug":"关于js的浅拷贝与深拷贝","date":"2019-04-02T03:10:59.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2019/04/02/关于js的浅拷贝与深拷贝/","link":"","permalink":"https://www.silenceboy.com/2019/04/02/关于js的浅拷贝与深拷贝/","excerpt":"","text":"浅拷贝和深拷贝只针对像Object, Array这样的复杂对象的.简单来说，浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。 浅拷贝通过 Object.assign 来实现浅拷贝。123456let a = &#123; num: 1&#125;let b = Object.assign(&#123;&#125;, a)a.num = 2console.log(b.num) // 1 通过展开运算符(…)来实现浅拷贝123456let a = &#123; num: 1&#125;let b = &#123;...a&#125;a.num = 2console.log(b.num) // 1 通过属性赋值来实现浅拷贝:123456789101112const obj = &#123; a:1, arr: [2,3] &#125;;const shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 该方法体现了浅拷贝的问题．因为浅拷贝只会将对象的各个属性进行依次拷贝，并不会进行递归拷贝，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址． 导致的结果就是： 12shallowObj.arr[1] = 5;obj.arr[1] // = 5 这种情况就需要用到深拷贝了． 深拷贝通过JSON序列化实现深拷贝许多JavaScript框架都提出了自己的解决办法,但是Javascript应该采用那种方法作为标准呐? 在很长一段时间里,这个问题都没有明确的答案.对于JSON安全(也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象来说,有一种巧妙的复制方法: var newObj = JSON.parse(JSON.stringify(someObj)); 当然,这种方法需要保证对象是JSON安全的,所以只适用于部分情况. 你不知道的JavaScript(上) 该方法的局限性: 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 递归完成深拷贝1234567891011121314function deepCopy(obj)&#123; //判断是否是简单数据类型， if(typeof obj == &quot;object&quot;)&#123; //复杂数据类型 var result = obj.constructor == Array ? [] : &#123;&#125;; for(let i in obj)&#123; result[i] = typeof obj[i] == &quot;object&quot; ? deepCopy(obj[i]) : obj[i]; &#125; &#125;else &#123; //简单数据类型 直接 == 赋值 var result = obj; &#125; return result;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"Linux Shell >/dev/null 2>&1 &含义","slug":"Linux-Shell-dev-null-2-1-含义","date":"2019-04-01T10:04:28.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2019/04/01/Linux-Shell-dev-null-2-1-含义/","link":"","permalink":"https://www.silenceboy.com/2019/04/01/Linux-Shell-dev-null-2-1-含义/","excerpt":"","text":"shell中可能经常能看到：echo log &gt; /dev/null 2&gt;&amp;1 &amp;!, 但具体代表什么意思，很多人都不理解，下面对此进行一一讲解： &gt;: 代表重定向到哪里，例如：echo &quot;123&quot; &gt; /home/123.txt, 表示将字符串&#39;123&#39;写入文件/home/123.txt中, /dev/null: 代表空设备文件. %&gt;: 用来定义输出形式，其中&#39;%&#39;有几种可选值: 0: 标准输入 1: 表示stdout标准输出，系统默认值是1，所以&quot;&gt;/dev/null&quot;等同于&quot;1&gt;/dev/null“ 2: 表示stderr标准错误 &amp;: 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 所以&gt; /dev/null 2&gt;&amp;1可以分两步理解为: 1 &gt; /dev/null: 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1: 接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 最后一个&amp;! ， 是让该命令在后台执行，并且关闭终端后不退出。","categories":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/tags/shell/"}]},{"title":"[转]Node.js的模块-exports和module.exports","slug":"转-Node-js的模块-exports和module-exports","date":"2019-03-26T03:41:32.000Z","updated":"2021-09-27T07:27:40.449Z","comments":true,"path":"2019/03/26/转-Node-js的模块-exports和module-exports/","link":"","permalink":"https://www.silenceboy.com/2019/03/26/转-Node-js的模块-exports和module-exports/","excerpt":"","text":"原文链接： http://zhanglun.xyz/2014/04/26/%E8%AF%91-node-js%E7%9A%84%E6%A8%A1%E5%9D%97-exports-%E5%92%8C-module-exports/ exports 和 module.exports 有什么区别？你一定很熟悉 Node.js 模块中的用来在你的模块中创建函数的 exports 对象，就像下面这样。 创建一个叫做 rocker.js 的文件： 123exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 然后可以在另外一个文件中调用 rocker.js : 12var rocker = require(&apos;./rocker.js&apos;);rocker.name(); // &apos;My name is Lemmy Kilmister&apos; 但是，module.exports 到底什么？它是合法的吗？ 令人吃惊的是：module.exports 是真实存在的。exports 只不过是 module.exports 的帮手而已。你的模块直接返回返回 module.exports 给调用者，而不是 exports 。所有的 exports 做的工作实际上是收集属性，如果 module.exports 当前没有任何属性，exports便将收集到的属性添加到 module.exports 上。如果 module.exports已经存在若干属性，所以 exports 上的属性都会被忽略。 修改 rocker.js 文件： 1234module.exports = &apos;ROCK IT!&apos;;exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 在另一个文件中调用 rocker.js: 12var rocker = require(&apos;./rocker.js&apos;);rocker.name(); // TypeError: Object ROCK IT! has no method &apos;name&apos; 上述例子中的 rocker 模块完全将 exports.name 忽略了，只返回了一个 String 字符串：‘ROCK IT!’ 。 从这个例子你大概明白了：你的模块并不一定总是一个模块的实例(module instance)，它可以是任何合法的 JavaScript 对象——boolean, number, date, JSON, string, function, array 和其他的。你的模块可以是任何你设置的 module.exports 的值。如果你没有明确地为 module.exports 设置任何值，那么 exports 中的属性会自动添加到 module.exports 中，然后并返回它。 在这种情况下，你的模块是一个类： 1234567module.exports = function(name, age) &#123; this.name = name; this.age = age; this.about = function() &#123; console.log(this.name +&apos; is &apos;+ this.age +&apos; years old&apos;); &#125;;&#125;; 而你可以像这样使用： 123var Rocker = require(&apos;./rocker.js&apos;);var r = new Rocker(&apos;Ozzy&apos;, 62);r.about(); // Ozzy is 62 years old 在这时候你的模块是一个数组： 1234567module.exports = [ &apos;Lemmy Kilmister&apos;, &apos;Ozzy Osbourne&apos;, &apos;Ronnie James Dio&apos;, &apos;Steven Tyler&apos;, &apos;Mick Jagger&apos;]; 而你可以这样使用： 12var rocker = require(&apos;./rocker.js&apos;);console.log(&apos;Rockin in heaven: &apos; + rocker[2]); //Rockin in heaven: Ronnie James Dio 现在你应该明白了点什么：如果你想让你的模块返回一个特殊的对象类型，比如构造函数，那么你得使用 module.exports ；如果你只想模块作为一个典型的模块实例（module instance），那么就用exports。 把属性添加到 module.exports 中和添加到 exports 中的结果是一样的。比如像这样： 123module.exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 其实和下面的是一样的： 123exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 但是要注意，他们不是同一个东西。就像之前说的一样，exports 只不过是 module.exports 的帮手而已。话虽如此，exports还是推荐的对象，除非你想把你模块的对象类型从传统的模块实例（module instance）修改为其他的。 只要你没有使用赋值运算重写module.exports对象，任何添加到 module.exports和exports的属性都能够在 require模块中。 比如这是你的模块中的内容： 12module.exports.age = 68;exports.name = &apos;Lemmy Kilmister&apos;; 下面的代码可以很好的工作： 12var rocker = require(&apos;./rocker.js&apos;);console.log(&apos;%s is %s&apos;, rocker.name, rocker.age); // Lemmy Kilmister is 68 但是，如果你在你的模块中重写了module.exports中的任何地方，代码便会出错： 123module.exports = &apos;LOL&apos;;module.exports.age = 68;exports.name = &apos;Lemmy Kilmister&apos;; 或者这样： 123module.exports.age = 68;exports.name = &apos;Lemmy Kilmister&apos;;module.exports = &apos;WTF&apos;; 顺序没有关系，rocker.age 和 rocker.name 将显示为 undefined。 并且注意：只是因为 module.exports 和 exports 都能输出模块，并不意味这你可以组合使用。我的建议是，坚持使用 exports.*，明白module.exports 我希望这篇文章能帮助你理解exports和module.exports之间的不同，并且能进一步的理解模块在Node.js中是怎么工作的。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"关于LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443错误的两种解决方案","slug":"关于LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443错误的两种解决方案","date":"2019-03-23T04:54:30.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2019/03/23/关于LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443错误的两种解决方案/","link":"","permalink":"https://www.silenceboy.com/2019/03/23/关于LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443错误的两种解决方案/","excerpt":"","text":"错误来源使用使用hexo部署博客是，遇到以下错误: 123456fatal: unable to access &apos;https://github.com/silenceboychen/silenceboychen.github.io.git/&apos;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (/Users/chenhao/new_start/nodejs/blog/node_modules/hexo-util/lib/spawn.js:52:19) at ChildProcess.emit (events.js:182:13) at Process.ChildProcess._handle.onexit (internal/child_process.js:239:12) 两种解决方案：方案一取消http代理： 12$ git config --global --unset http.proxy$ git config --global --unset https.proxy 设置env GIT_SSL_NO_VERIFY为true然后再次部署： 1$ env GIT_SSL_NO_VERIFY=true hexo d 问题解决。 方案二在hexo项目的根目录下的_config.yml文件中把仓库链接地址由https修改为ssh的地址。","categories":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://www.silenceboy.com/tags/hexo/"}]},{"title":"统计指定目录里的代码行数","slug":"统计指定目录里的代码行数","date":"2019-03-21T01:34:04.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2019/03/21/统计指定目录里的代码行数/","link":"","permalink":"https://www.silenceboy.com/2019/03/21/统计指定目录里的代码行数/","excerpt":"","text":"codeLineCount一个用来统计项目内代码行数的工具. Installation1$ npm install -g code-rows-count or 1$ yarn global add code-rows-count Usage123456789$ codeLineCount -hUsage: codeLineCount [options]Options: -V, --version output the version number -p, --filePath [filePath] 文件路径 -i, --ignoreFile [ignoreFile] 忽略文件 -h, --help output usage information -p: 需要统计代码行数项目的绝对路径 -i: 不需要参与统计的项目内的文件名, 多个文件名使用逗号分割 example: 12345678910111213141516$ codeLineCount -p /home/silence/nodejs/test -i node_modules,yarn.lock,.git,package.json.lock文件路径:/home/silence/nodejs/test/color.js, 文件行数:19文件路径:/home/silence/nodejs/test/commander.js, 文件行数:14文件路径:/home/silence/nodejs/test/http.js, 文件行数:6文件路径:/home/silence/nodejs/test/package.json, 文件行数:6文件路径:/home/silence/nodejs/test/aaa/color.js, 文件行数:19------------------分割线start------------------done, 总耗时: 5 ms总文件数:5, 总代码行数: 64------------------分割线end------------------","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"express.js中间件说明","slug":"express-js中间件说明","date":"2019-03-19T01:39:06.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2019/03/19/express-js中间件说明/","link":"","permalink":"https://www.silenceboy.com/2019/03/19/express-js中间件说明/","excerpt":"","text":"express的新开发人员往往对路由处理程序和中间件之间的区别感到困惑。因此他们也对app.use(),app.all(),app.get(),app.post(),app.delete()和app.put()方法的区别感到困惑。 在本文中,我将解释中间件和路由处理程序之间的区别。以及如何正确使用app.use(),app.all(),app.get(),app.post(),app.delete()和app.put()方法。 路由处理app.use(),app.all(),app.get(),app.post(),app.delete()和app.put()全部是用来定义路由的。这些方法都用于定义路由。路由用于处理HTTP请求。路由是路径和回调的组合，在请求的路径匹配时执行。回调被称为路由处理程序。 它们之间的区别是处理不同类型的HTTP请求。例如： app.get()方法仅仅处理get请求，而app.all()处理GET、POST等请求。 下面是一个例子,如何定义一个路由： 1234567var app = require(&quot;express&quot;)();app.get(&quot;/&quot;, function(req, res, next)&#123; res.send(&quot;Hello World!!!!&quot;);&#125;);app.listen(8080); 每个路由处理程序都获得对当前正在提供的HTTP请求的请求和响应对象的引用。 可以为单个HTTP请求执行多个路由处理程序。这是一个例子： 12345678910111213var app = require(&quot;express&quot;)();app.get(&quot;/&quot;, function(req, res, next)&#123; res.write(&quot;Hello&quot;); next();&#125;);app.get(&quot;/&quot;, function(req, res, next)&#123; res.write(&quot; World !!!&quot;); res.end();&#125;);app.listen(8080); 这里第一个句柄写入一些响应，然后调用next()。 next()方法用于调用与路径路径匹配的下一个路由处理程序。 路由处理程序必须结束请求或调用下一个路由处理程序。 我们还可以将多个路由处理程序传递给app.all()，app.get()，app.post()，app.delete()和app.put()方法。 这是一个证明这一点的例子： 1234567891011var app = require(&quot;express&quot;)();app.get(&quot;/&quot;, function(req, res, next)&#123; res.write(&quot;Hello&quot;); next();&#125;, function(req, res, next)&#123; res.write(&quot; World !!!&quot;); res.end();&#125;);app.listen(8080); 中间件中间件是一个位于实际请求处理程序之上的回调。它采用与路由处理程序相同的参数。 要了解中间件，我们来看一个带有dashboard和profile页面的示例站点。要访问这些页面，用户必须登录。还会记录对这些页面的请求。 以下是这些页面的路由处理程序的代码： 1234567891011121314151617181920212223242526272829303132333435var app = require(&quot;express&quot;)();function checkLogin()&#123; return false;&#125;function logRequest()&#123; console.log(&quot;New request&quot;);&#125;app.get(&quot;/dashboard&quot;, function(req, res, next)&#123; logRequest(); if(checkLogin())&#123; res.send(&quot;This is the dashboard page&quot;); &#125; else&#123; res.send(&quot;You are not logged in!!!&quot;); &#125;&#125;);app.get(&quot;/profile&quot;, function(req, res, next)&#123; logRequest(); if(checkLogin())&#123; res.send(&quot;This is the dashboard page&quot;); &#125; else&#123; res.send(&quot;You are not logged in!!!&quot;); &#125;&#125;);app.listen(8080); 这里的问题是有很多重复的代码，即我们不得不多次使用logRequest()和checkLogin()函数。这也使得更新代码变得困难。因此，为了解决这个问题，我们可以为这两条路径编写一条通用路径。 这是重写的代码： 123456789101112131415161718192021222324252627282930313233var app = require(&quot;express&quot;)();function checkLogin()&#123; return false;&#125;function logRequest()&#123; console.log(&quot;New request&quot;);&#125;app.get(&quot;/*&quot;, function(req, res, next)&#123; logRequest(); next();&#125;)app.get(&quot;/*&quot;, function(req, res, next)&#123; if(checkLogin())&#123; next(); &#125; else&#123; res(&quot;You are not logged in!!!&quot;); &#125;&#125;)app.get(&quot;/dashboard&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.get(&quot;/profile&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.listen(8080); 这里的代码看起来更清晰，更易于维护和更新。这里将前两个定义的路由处理程序称为中间件，因为它们不处理请求，而是负责预处理请求。 Express为我们提供了app.use()方法，该方法专门用于定义中间件。 app.use()方法可能看起来与app.all()类似，但它们之间存在很多差异，这使得app.use()非常适合于声明中间件。让我们看看app.use()方法是如何工作的： app.use() 和 app.all() 的不同:CALLBACKapp.use()只需要一个回调，而app.all()可以进行多次回调。 PATHapp.use()只查看url是否以指定路径开头,app.all()匹配完整路径。 这里有一个例子来说明: 1234567891011121314app.use( &quot;/product&quot; , mymiddleware);// will match /product// will match /product/cool// will match /product/fooapp.all( &quot;/product&quot; , handler);// will match /product// won&apos;t match /product/cool &lt;-- important// won&apos;t match /product/foo &lt;-- importantapp.all( &quot;/product/*&quot; , handler);// won&apos;t match /product &lt;-- Important// will match /product/cool// will match /product/foo NEXT()中间件内的next()调用下一个中间件或路由处理程序，具体取决于接下来声明的那个。但是路由处理程序中的next()仅调用下一个路由处理程序。如果接下来有中间件，则跳过它。因此，必须在所有路由处理程序之前声明中间件。 这里有一个例子来说明: 1234567891011121314151617181920212223242526272829var express = require(&apos;express&apos;);var app = express();app.use(function frontControllerMiddlewareExecuted(req, res, next)&#123; console.log(&apos;(1) this frontControllerMiddlewareExecuted is executed&apos;); next();&#125;);app.all(&apos;*&apos;, function(req, res, next)&#123; console.log(&apos;(2) route middleware for all method and path pattern &quot;*&quot;, executed first and can do stuff before going next&apos;); next();&#125;);app.all(&apos;/hello&apos;, function(req, res, next)&#123; console.log(&apos;(3) route middleware for all method and path pattern &quot;/hello&quot;, executed second and can do stuff before going next&apos;); next();&#125;);app.use(function frontControllerMiddlewareNotExecuted(req, res, next)&#123; console.log(&apos;(4) this frontControllerMiddlewareNotExecuted is not executed&apos;); next();&#125;);app.get(&apos;/hello&apos;, function(req, res)&#123; console.log(&apos;(5) route middleware for method GET and path patter &quot;/hello&quot;, executed last and I do my stuff sending response&apos;); res.send(&apos;Hello World&apos;);&#125;);app.listen(80); 现在我们看到了app.use()方法的唯一性以及它用于声明中间件的原因。 让我们重写我们的示例站点代码： 12345678910111213141516171819202122232425262728293031323334var app = require(&quot;express&quot;)();function checkLogin()&#123; return false;&#125;function logRequest()&#123; console.log(&quot;New request&quot;);&#125;app.use(function(req, res, next)&#123; logRequest(); next();&#125;)app.use(function(req, res, next)&#123; if(checkLogin())&#123; next(); &#125; else&#123; res.send(&quot;You are not logged in!!!&quot;); &#125;&#125;)app.get(&quot;/dashboard&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.get(&quot;/profile&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.listen(8080);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"express.js","slug":"express-js","permalink":"https://www.silenceboy.com/tags/express-js/"},{"name":"middleware","slug":"middleware","permalink":"https://www.silenceboy.com/tags/middleware/"}]},{"title":"nodejs实现tail -f功能","slug":"nodejs实现tail-f功能","date":"2019-03-15T01:37:54.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2019/03/15/nodejs实现tail-f功能/","link":"","permalink":"https://www.silenceboy.com/2019/03/15/nodejs实现tail-f功能/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&apos;use strict&apos;;const fs = require(&apos;fs&apos;);/** * tailf * * @param &#123;String&#125; filename 文件名 * @param &#123;Number&#125; delay 读取不到内容时等待的时间，ms * @param &#123;Function&#125; onError 操作出错时的回调函数，onError(err) * @param &#123;Function&#125; onData 读取到文件内容时的回调函数，onData(data) */function tailf(filename, delay, onError, onData) &#123; // 每次读取文件块大小，16K const CHUNK_SIZE = 16 * 1024; // 打开文件，获取文件句柄 fs.open(filename, &apos;r&apos;, (err, fd) =&gt; &#123; if (err) return onError(err); // 文件开始位置 fs.fstat(fd, (err, stats) =&gt; &#123; if (err) return onError(err); // 文件开始位置 let position = stats.size; // 循环读取 const loop = () =&gt; &#123; const buf = Buffer.alloc(CHUNK_SIZE); fs.read(fd, buf, 0, CHUNK_SIZE, position, (err, bytesRead, buf) =&gt; &#123; if (err) return onError(err); // 实际读取的内容长度以 bytesRead 为准 // 并且更新 position 位置 position += bytesRead; onData(buf.slice(0, bytesRead)); if (bytesRead &lt; CHUNK_SIZE) &#123; // 如果当前已到达文件末尾，则先等待一段时间再继续 // setTimeout(loop, delay); &#125; else &#123; loop(); &#125; &#125;); &#125;; loop(); // 监听文件变化，如果收到 change 事件则尝试读取文件内容 fs.watch(filename, (event, filename) =&gt; &#123; if (event === &apos;change&apos;) &#123; loop(); &#125; &#125;); &#125;); &#125;);&#125;const filename = process.argv[2];if (filename) &#123; tailf(filename, 100, err =&gt; &#123; if (err) console.error(err); &#125;, data =&gt; &#123; process.stdout.write(data); &#125;);&#125; else &#123; console.log(&apos;使用方法： node tailf &lt;文件名&gt;&apos;);&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"tailf","slug":"tailf","permalink":"https://www.silenceboy.com/tags/tailf/"}]},{"title":"在docker中执行gitlab-runner","slug":"在docker中执行gitlab-runner","date":"2018-05-20T03:45:45.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2018/05/20/在docker中执行gitlab-runner/","link":"","permalink":"https://www.silenceboy.com/2018/05/20/在docker中执行gitlab-runner/","excerpt":"","text":"环境:ubuntu 16.04 LTS目的：使用Docker安装和配置GitLab Runner，搭建GitLab CI持续集成环境。 安装gitlab-runner1234$ docker run -d --name gitlab-runner --restart always \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 参数说明： -d: 设置容器后台运行 –name：容器名称 -restart always：每次启动容器就重启 gitlab-runner -v: 共享目录挂载 安装好后，执行$ docker ps 查看容器是否运行。 注册和初始化1$ docker exec -it gitlab-runner gitlab-ci-multi-runner register gitlab-runner register是进入gitlab-runner容器的执行命令，用于注册和初始化gitlab-runner。以下是我的配置：注意：docker image为满足你项目构建所需环境的镜像。 我们也可以编辑vim /srv/gitlab-runner/config/config.toml，手动修改配置：12345678910111213141516171819concurrent = 1check_interval = 0[[runners]] name = &quot;test&quot; url = &quot;https://xxxx.oooo.com&quot; token = &quot;3894a417b64744e942008bcc51123a&quot; executor = &quot;docker&quot; builds_dir = &quot;/gitlab/runner-builds&quot; cache_dir = &quot;/gitlab/runner-cache&quot; [runners.docker] tls_verify = false image = &quot;node:latest&quot; privileged = false disable_cache = false volumes = [&quot;/data/gitlab-runner:/gitlab&quot;] shm_size = 0 pull_policy = &quot;if-not-present&quot; [runners.cache] gitlab-ci token可以从gitlab上的项目的CI设置中获得。builds_dir 为文件存放位置volumes 挂载目录pull_policy 设置gitlab是否从远程拉去image,如果iamge是本地的需要配置该属性的值为: if-not-present 或者 never 创建.gitlab-ci.yml文件我的项目为nodejs项目，以下为测试配置。 1234567891011121314151617181920212223stages: - installcache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/job-install: stage: install script: - whoami - echo $SHELL - rm -rf node_modules/ - pwd - source ~/.bashrc - nvm use 8 - node -v - yarn only: - preview tags: - test 配置好gitlab-ci文件之后，提交修改，并将最新的修改推送到origin/preview分支，即可触发CI:123456789101112131415161718192021222324252627282930313233343536Running with gitlab-runner 10.2.0 (0a75cdd1) on test (3894a417)Using Docker executor with image followme/node:v1 ...Using docker image sha256:07e33b24b6a9bebc0e0d8ba24f15b4b3c0f6fcf321a3809371a6211ac1afc38e for predefined container...Using locally found image version due to if-not-present pull policyUsing docker image followme/node:v1 ID=sha256:c99c549e8227e2323d1cebb6f988d5d8f6de7f77e1967fe0f02878b85cb72b0f for build container...Running on runner-3894a417-project-643-concurrent-0 via 304e3efed168...Cloning repository...Cloning into &apos;/gitlab/runner-builds/3894a417/0/Frontend/api-member&apos;...Checking out 311e85cb as preview...Skipping Git submodules setupChecking cache for preview...Successfully extracted cache$ whoamiroot$ echo $SHELL/bin/bash$ rm -rf node_modules/$ pwd/gitlab/runner-builds/3894a417/0/Frontend/api-member$ source ~/.bashrc$ nvm use 8Now using node v8.3.0 (npm v5.3.0)$ node -vv8.3.0$ yarnyarn install v1.3.2[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...Done in 7.21s.Creating cache preview...node_modules/: found 5627 matching files Created cacheJob succeeded 注意：之前我是在Ubuntu14.04版本的系统上做这些配置，但是当执行CI的时候总会遇到以下报错:ERROR: Preparation failed: Error reading remote info: json: cannot unmarshal number into Go struct field Info.Debug of type bool 将系统升级为16.04后解决该问题","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"gitlab-runner","slug":"gitlab-runner","permalink":"https://www.silenceboy.com/tags/gitlab-runner/"}]},{"title":"mysql，sql server等数据库连接集成库","slug":"mysql，sql-server等数据库连接集成库","date":"2018-04-08T09:33:08.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2018/04/08/mysql，sql-server等数据库连接集成库/","link":"","permalink":"https://www.silenceboy.com/2018/04/08/mysql，sql-server等数据库连接集成库/","excerpt":"","text":"地址: https://github.com/fmfe/lib-sql Installation1$ npm install @fmfe/lib-sql or 1$ yarn add @fmfe/lib-sql Usage有两种传入配置信息的方式: 使用config来管理我们的配置文件.假设我们的项目目录下有一个config目录,config目录里有一个dev.json文件. config/dev.json 12345678910111213141516171819202122&#123; &quot;mysql&quot;: &#123; &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 3306, &quot;database&quot;: &quot;test&quot;, &quot;user&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot; &#125;, &quot;mssql&quot;: &#123; &quot;user&quot;: &quot;sa&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;server&quot;: &quot;127.0.0.1&quot;, &quot;database&quot;: &quot;test&quot;, &quot;port&quot;: 1433, &quot;pool&quot;: &#123; &quot;min&quot;: 0, &quot;max&quot;: 10, &quot;idleTimeoutMillis&quot;: 3000 &#125; &#125;&#125; mysql.js 12345678910111213141516171819202122232425262728293031const &#123; mysql &#125; = require(&apos;@fmfe/lib-sql&apos;);const mysqlPool = mysql.init();const _getNewSqlParamEntity = mysql._getNewSqlParamEntity;// 执行单条sql语句 // mysql.exec(mysqlPool, sql, params);async function exec() &#123; const sql1 = &apos;select * from ?? limit 2&apos;; const data = await mysql.exec(mysqlPool, sql1, [&apos;tbl_user&apos;]);&#125;// 执行mysql事务,可以传入多条增/删/改sql语句 // mysql.exectrans(mysqlpool, sqlParamsEntity);async function execTrans() &#123; const sqlParamsEntity = []; const sql1 = &apos;insert into ?? (name, age, sex) values (?, ?, ?)&apos;; const param1 = [&apos;tbl_user&apos;, &apos;aaa&apos;, 20, 1]; sqlParamsEntity.push(_getNewSqlParamEntity(sql1, param1)); const sql2 = &apos;insert into ?? (name, age, sex) values (?, ?, ?)&apos;; const param2 = [&apos;tbl_user&apos;, &apos;bbb&apos;, 22, 0]; sqlParamsEntity.push(_getNewSqlParamEntity(sql2, param2)); const sql3 = &apos;update ?? set age = ? where id = ?&apos;; const param3 = [&apos;tbl_user&apos;, 10, 1]; sqlParamsEntity.push(_getNewSqlParamEntity(sql3, param3)); // .... const data = await mysql.execTrans(mysqlPool, sqlParamsEntity); &#125; mssql.js 1234567891011121314151617181920212223const &#123; mssql &#125; = require(&apos;@fmfe/lib-sql&apos;);const _getNewSqlParamEntity = mssql._getNewSqlParamEntity;// 执行单条语句 // mssql.exec(sql)async function exec() &#123; const sql1 = &apos;select Top 3 name, age, sex from tbl_user order by age desc&apos;; const data = await mssql.exec(sql1); &#125;// 执行sql server 事务, 最好执行增/删/改语句,这里只是用select演示使用方法// mssql.exectrans(sqlParamsEntity); async function exectrans() &#123; const sqlParamsEntity = []; const sql1 = &apos;select * from tbl_user where id = 1&apos;; sqlParamsEntity.push(_getNewSqlParamEntity(sql1)); const sql2 = &apos;select * from tbl_user where id = 2&apos;; sqlParamsEntity.push(_getNewSqlParamEntity(sql2)); // ... const data = await mssql.execTrans(sqlParamsEntity); &#125; 由于使用config管理配置文件, 运行项目时通过使用命令: NODE_ENV=dev node ..., @fmfe/lib-sql即可自动获取到数据库相关配置. 通过传入配置文件来调用库我们引用上边的代码示例,只需做一点改动: mysql.js 只需在初始化时传入mysql数据库配置就好. 1234567891011const &#123; mysql &#125; = require(&apos;@fmfe/lib-sql&apos;);const mysqlPool = mysql.init(&#123; host: &apos;127.0.0.1&apos;, port: 3306, database: &apos;test&apos;, user: &apos;root&apos;, password: &apos;123456&apos;&#125;);...... mssql.js 在每次调用方法时传入配置 123456789101112131415161718192021222324const &#123; mssql &#125; = require(&apos;@fmfe/lib-sql&apos;);const config = &#123; user: &apos;sa&apos;, password: &apos;123456&apos;, server: &apos;127.0.0.1&apos;, database: &apos;test&apos;, port: 1433, pool: &#123; min: 0, max: 10, idleTimeoutMillis: 3000 &#125; &#125;async function exec() &#123; ...... const data = await mssql.exec(sql1, config); &#125;async function exectrans() &#123; ...... const data = await mssql.execTrans(sqlParamsEntity, config); &#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"sql server","slug":"sql-server","permalink":"https://www.silenceboy.com/tags/sql-server/"}]},{"title":"docker搭建私有仓库、自签发证书、登录认证","slug":"docker搭建私有仓库、自签发证书、登录认证","date":"2018-03-28T01:24:21.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2018/03/28/docker搭建私有仓库、自签发证书、登录认证/","link":"","permalink":"https://www.silenceboy.com/2018/03/28/docker搭建私有仓库、自签发证书、登录认证/","excerpt":"","text":"docker官方文档对如何搭建私有仓库说的已经很详细了，我在这里主要介绍一下使用自签发证书如何搭建私有仓库并认证成功。 假设registry的域名为：registry.domain.com。 生成自签发证书。12&gt; mkdir -p certs&gt; openssl req -newkey rsa:2048 -nodes -sha256 -keyout certs/domain.key -x509 -days 365 -out certs/domain.crt 执行以上命令，生成证书，Common Name那里要输入我们registry的域名，生成的证书只对该域名有效。其他的可以任意填。生成后可以在certs目录下查看到证书。 生成鉴权密码文件 注意使用时username替换为你自己的用户名，password替换为你自己的密码。123$ mkdir auth$ docker run --entrypoint htpasswd registry:2 -Bbn username password &gt; auth/htpasswd$ ls auth 启动Registry1234567891011docker run -d -p 5000:5000 --restart=always --name registry \\ -v `pwd`/auth:/auth \\ -e &quot;REGISTRY_AUTH=htpasswd&quot; \\ -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ -v `pwd`/data:/var/lib/registry \\ -v `pwd`/certs:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \\ -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \\ registry:2199ad0b3591fb9613b21b1c96f017267f3c39661a7025d30df636c6805e7ab50 如果没有registry镜像会自动下载然后启动，可以使用阿里云提供的加速器。现在完成了registry服务器的搭建，可以尝试pull image到registry：123$ docker pull busybox // 从官方拉去镜像作为我们的测试镜像$ docker tag busybox:latest registry.domain.com:5000/busybox:latest // 为busybox打tag,tag的前缀一定要为我们registry服务器的域名。$ docker push registry.domain.com:5000/busybox:latest // 将镜像推送到我们的registry服务器 如果直接这样去push，会失败，并且出现 no basic auth credentials的错误，这是因为我们没有进行登录认证。12345$ docker login registry.domain.com:5000$ Username: username$ Password: passwordWARNING: login credentials saved in ~/.docker/config.jsonLogin Succeeded 登录成功后再次执行push操作，会出现x509: certificate signed by unknown authority的报错。这是因为docker client认为server传输过来的证书的签署方是一个unknown authority（未知的CA），因此验证失败。我们需要让docker client安装我们的CA证书：123$ sudo mkdir -p /etc/docker/certs.d/registry.domain.com:5000$ sudo cp certs/domain.crt /etc/docker/certs.d/registry.domain.com:5000/ca.crt$ sudo service docker restart //安装证书后，重启Docker Daemon 再次执行push操作，成功推送：1234$ docker push registry.domain.com:5000/busybox:latestThe push refers to a repository [registry.domain.com:5000/busybox]0271b8eebde3: Pushedlatest: digest: sha256:3571ca1b0e90e159de4fc07b3bf94ef189a0645314704f629204adb7035ecf45 size: 527 这里需要注意：如果使用自签署的证书，那么所有要与Registry交互的Docker主机都需要安装registry.domain.com的ca.crt(domain.crt)。但如果你使用知名CA，这一步也就可以忽略。如果是MacOS版的docker也是一样的操作，尽管它连/etc/docker都不存在,一样去创建目录就好了。只是macOS的用户想要认证生效需要执行额外的命令：1$ sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /etc/docker/certs.d/registry.domain.com:5000/ca.crt 此时在mac上执行docker login才可成功。","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"}]},{"title":"容联云发送短信模块","slug":"容联云发送短信模块","date":"2018-01-28T01:22:30.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2018/01/28/容联云发送短信模块/","link":"","permalink":"https://www.silenceboy.com/2018/01/28/容联云发送短信模块/","excerpt":"","text":"rongSMS一个nodejs实现的容联云发送短信模板模块（云联云官方没有提供nodejs实现的版本），支持node7.6以上版本。支持所有短信模板。一些常用的容联云返回码： code 含义 000000 发送成功 160038 短信验证码发送过频繁 160040 该手机号短信验证码发送次数超过当日限制 Installation1$ npm install rongsms or 1$ yarn add rongsms Usage12345678910111213141516const rongSms = require(&apos;rongSms&apos;);//生成验证码，在发送验证码是可以用来生成6位验证码。如果不是发送验证码可以不用。const code = rongSms.generate_code();//初始化//account_sid: 主账户sid，登陆云通讯网站后，可在控制台首页看到开发者主账号ACCOUNT SID//account_token： 主账户Token，登陆云通讯网站后，可在控制台首页看到开发者主账号AUTH TOKEN。//app_id: 请使用管理控制台中已创建应用的APPID。rongSms.init_sms(account_sid, account_token, app_id);//发送短信//phone:接受短信手机号//arr: 数组，对应短信模板中的替换内容。如短信模板为：您的验证码为&#123;1&#125;，请于&#123;2&#125;内正确输入，如非本人操作，请忽略此短信。arr取值为：[&apos;123456&apos;, &apos;10分钟&apos;]//template_id：模板idrongSms.send_sms(phone, arr, template_id);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/tags/npm/"},{"name":"sms","slug":"sms","permalink":"https://www.silenceboy.com/tags/sms/"}]},{"title":"搭建shadowsock服务器","slug":"搭建shadowsock服务器","date":"2018-01-19T01:37:28.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2018/01/19/搭建shadowsock服务器/","link":"","permalink":"https://www.silenceboy.com/2018/01/19/搭建shadowsock服务器/","excerpt":"","text":"安装Debian / Ubuntu: 12$ apt-get install python-pip$ pip install shadowsocks CentOS: 12$ yum install python-setuptools &amp;&amp; easy_install pip$ pip install shadowsocks 启动 有两种启动方式，建议使用配置文件的方式启动 直接启动： 1ssserver -p 8388 -k password -m rc4-md5 -d start 使用配置文件启动： 执行vim /etc/shadowsocks.json添加如下内容： 123456789&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;&#125; 多用户配置如下： 1234567891011121314&#123; &quot;server&quot;:&quot;0.0.0.0&quot;， &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;8388&quot;: &quot;password&quot;, &quot;8387&quot;: &quot;password&quot;, &quot;8386&quot;: &quot;password&quot;, &quot;8385&quot;: &quot;password&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;: false &#125; 然后通过执行一下命令启动： 如果要停止运行，将命令中的start改成stop。 1$ ssserver -c /etc/shadowsocks.json -d start TIPS: 加密方式推荐使用rc4-md5，因为 RC4 比 AES 速度快好几倍，如果用在路由器上会带来显著性能提升。旧的 RC4 加密之所以不安全是因为 Shadowsocks 在每个连接上重复使用 key，没有使用 IV。现在已经重新正确实现，可以放心使用。更多可以看 issue。 开机自启编辑一下/etc/supervisord.conf文件，命令如下： 1$ vim /etc/supervisord.conf 把下面的内容粘贴到文件尾部的空行处，然后保存： 1234567[program:shadowsocks]command=ssserver -c /etc/shadowsocks.jsonautostart=trueautorestart=trueuser=rootlog_stderr=truelogfile=/var/log/shadowsocks.log 接下来需要编辑一下/etc/rc.local文件，请执行以下命令： 1$ vi /etc/rc.local 请把以下内容粘贴到文件中部的空白处，然后保存 1$ service supervisord start 完成以上步骤后，重启之后，shadowsock会自动运行。 问题 如果通过客户端始终代理失败，可以通过一下方法查找问题。 1.客户端通过 telnet ip port 确认 ss-server 是否正常开启，如果没有正常开启，有可能是设定的端口没有开放， 1$ iptables -A INPUT -p tcp --dport 8388 -j ACCEPT 执行上述命令，将 8388 修改为你设定的端口即可。 2.如果第一步中连接正常，可以查看下 ss-server 的日志 1$ ssserver -c /etc/shadowsocks.json --log-file /var/log/shadowsocks.log -d start 启动的时候添加 --log-file 参数，然后通过 1$ tail -f /var/log/shadowsocks.log 查看实时日志，一般可以看出一点端倪。","categories":[{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/categories/shadowsock/"}],"tags":[{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/tags/shadowsock/"}]},{"title":"搭建指定版本node环境的docker镜像","slug":"搭建指定版本node环境的docker镜像","date":"2017-12-07T09:36:12.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2017/12/07/搭建指定版本node环境的docker镜像/","link":"","permalink":"https://www.silenceboy.com/2017/12/07/搭建指定版本node环境的docker镜像/","excerpt":"","text":"基于ubuntu16.04的docker镜像去打包安装了nodejs环境的docker镜像 前置条件1.获取ubuntu16.04镜像1# docker pull ubuntu:16.04 2.基于ubuntu16.04镜像启动容器1# docker run -ti --name ubuntu ubuntu:16.04 /bin/bash 从源代码安装Node.JS 安装node过程均在容器内进行 1.更新源并安装必要工具12# apt-get update# apt-get install git wget python gcc make g++ 2.获取指定版本的node源代码 这里我们使用v8.9.0版,目前为长期支持版,可以使用两中获取源码的方式.123# wget http://nodejs.org/dist/v8.9.0/node-v8.9.0.tar.gz# tar zxvf node-v8.9.0.tar.gz# mv node-v8.9.0 node or1# git clone -b v8.9.0 git@github.com:nodejs/node.git 3.修改目录权限1# chmod -R 755 node 4.编译安装node1234# cd node# ./configure# make# make install 5.查看node版本12# node --versionv8.9.0 安装完成后退出镜像 利用包管理器安装Node.JS 安装在镜像内进行 1.更新源并安装必要工具 setup_8.x为安装8.x版本,若安装9.x版本为:setup_9.x123# apt-get update# apt-get install curl# curl -sL https://deb.nodesource.com/setup_8.x | bash - 2.安装nodejs1# apt-get install -y nodejs 3.查看node版本12# node --versionv8.9.0 安装完成后退出镜像 从容器创建一个新的镜像 注意: 在上一步已经退出容器,下面的操作是在本机上进行的. 1.执行docker ps -a 查看name为ubuntu的ID 2.创建新的镜像12$ docker commit -a &quot;author&quot; -m &quot;commit message&quot; b0084b239645 xxx/node8.9:v1sha256:bc03d86ef63bab18deafe643f99b2aa1da5697860e1432102dbbcbb281fdf335 -a: 作者信息 -m: 提交信息 b0084b239645: docker ps -a中查看的ID xxx/node8.9:v1: 新的镜像名称 3.上传到镜像仓库 镜像制作完成可以将镜像上传到镜像仓库,便于以后使用,可以指定仓库地址,也可以使用官方的仓库.1$ docker push xxx/node8.9:v1","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"使用Dockerfile部署nodejs服务","slug":"使用Dockerfile部署nodejs服务","date":"2017-12-04T09:49:49.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2017/12/04/使用Dockerfile部署nodejs服务/","link":"","permalink":"https://www.silenceboy.com/2017/12/04/使用Dockerfile部署nodejs服务/","excerpt":"","text":"初始化Dockerfile假设我们的项目名为express,在express项目中创建编辑Dockerfile文件：123456789101112131415$ vim DockerfileFROM node:latestRUN mkdir -p /home/www/expressWORKDIR /home/www/expressCOPY . /home/www/expressRUN npm installEXPOSE 3000ENTRYPOINT [&quot;npm&quot;, &quot;run&quot;]CMD [&quot;start&quot;] 这个文件包含了以下命令： FROM node:latest - 指定使用最新版本的node基础镜像 RUN mkdir -p /home/www/express - 在容器内创建/home/www/express目录 WORKDIR /home/www/express - 将容器内工作目录设置为/home/www/express COPY . /home/www/express - 将宿主机当前目录下内容复制到镜像/home/www/express目录下 RUN npm install - npm install安装应用所需的NPM包 EXPOSE 3000 - 对外开放容器的3000端口 ENTRYPOINT [&quot;npm&quot;, &quot;run&quot;] - 容器启动后执行的命令。不可被docker run提供的参数覆盖 CMD [&quot;start&quot;] - 在容器启动时，执行的命令，可被docker run提供的参数覆盖 构建镜像编写完Dockerfile文件后，就可以通过docker build命令来构建镜像：1$ sudo docker build -t test/express . 我们通过-t参数，将镜像命名为test/express。构建过程类似如下：123456789101112131415161718192021222324252627282930313233343536Sending build context to Docker daemon 29.7 kBStep 1/8 : FROM registry.src.followme.com:5000/node:v1 ---&gt; c99c549e8227Step 2/8 : RUN mkdir -p /home/www/express-app ---&gt; Running in 8be9a90629b0 ---&gt; b9f584851225Removing intermediate container 8be9a90629b0Step 3/8 : WORKDIR /home/www/express-app ---&gt; 5072c31f9dd9Removing intermediate container e9dbf4ce3d8bStep 4/8 : COPY . /home/www/express-app ---&gt; a4d1725f15edRemoving intermediate container 30aa49765015Step 5/8 : RUN yarn ---&gt; Running in f181c243deaayarn install v1.3.2[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...Done in 9.46s. ---&gt; d390931d73e6Removing intermediate container f181c243deaaStep 6/8 : EXPOSE 3000 ---&gt; Running in 94101ab38864 ---&gt; 43199a8a5a90Removing intermediate container 94101ab38864Step 7/8 : ENTRYPOINT npm run ---&gt; Running in 80b1318962cf ---&gt; 6b203c50e855Removing intermediate container 80b1318962cfStep 8/8 : CMD start ---&gt; Running in a9909e537f59 ---&gt; d56eae48377cRemoving intermediate container a9909e537f59Successfully built d56eae48377c 运行容器镜像构建完成后，可以通过所构建的镜像创建/运行容器，从而实现express应用的 Docker 化部暑。 使用tets/express镜像运行一个容器：1$ sudo docker run -d --name experss-app -p 3000:3000 test/express 在以上操作中，我们通过test/express镜像运行了容器，并将容器命名为experss-app。运行容器，我们还指定了-d参数，该参数使容器以后台的方式运行。而-p参数将宿主机的3000端口映射到了容器的3000端口。运行容器后，可以通过docker ps命令看到运行中的容器。此时可通过localhost:3000访问服务。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://www.silenceboy.com/tags/dockerfile/"}]},{"title":"JavaScript数组随机排序","slug":"JavaScript数组随机排序","date":"2017-08-08T04:21:39.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2017/08/08/JavaScript数组随机排序/","link":"","permalink":"https://www.silenceboy.com/2017/08/08/JavaScript数组随机排序/","excerpt":"","text":"12345678910111213141516//不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。function randomSort(arr, newArr) &#123; var newArr = newArr || [] if (arr.length == 1) &#123; newArr.push(arr[0]) return newArr; // 相当于递归退出 &#125; var random = Math.ceil(Math.random() * arr.length) - 1 newArr.push(arr[random]) arr.splice(random, 1) return randomSort(arr, newArr)&#125;randomSort([1, 2, 3, 4, 5, 6, 7]); //[2, 3, 1, 5, 6, 7, 4]randomSort([1, 2, 3, 4, 5, 6, 7]); //[3, 4, 2, 5, 1, 6, 7]","categories":[{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"}]},{"title":"JavaScript按概率随机生成事件","slug":"JavaScript按概率随机生成事件","date":"2017-08-02T04:20:03.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2017/08/02/JavaScript按概率随机生成事件/","link":"","permalink":"https://www.silenceboy.com/2017/08/02/JavaScript按概率随机生成事件/","excerpt":"","text":"12345678910111213141516171819202122232425/**在抽奖的活动中经常会用到这个算法，不同奖项的获取概率不同，要按概率去随机生成对应的奖品**/function random(arr1, arr2) &#123; var sum = 0, factor = 0, random = Math.random(); for(var i = arr2.length - 1; i &gt;= 0; i--) &#123; sum += arr2[i]; // 统计概率总和 &#125;; random *= sum; // 生成概率随机数 for(var i = arr2.length - 1; i &gt;= 0; i--) &#123; factor += arr2[i]; if(random &lt;= factor) return arr1[i]; &#125;; return null;&#125;;// testvar a = [&apos;mac&apos;, &apos;iphone&apos;, &apos;vivo&apos;, &apos;OPPO&apos;];var b = [0.1, 0.2, 0.3, 0.4];console.log(random(a, b));","categories":[{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"}]},{"title":"node.js之base64编码解码","slug":"node-js之base64编码解码","date":"2016-09-16T04:15:18.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2016/09/16/node-js之base64编码解码/","link":"","permalink":"https://www.silenceboy.com/2016/09/16/node-js之base64编码解码/","excerpt":"","text":"利用buffer来进行编解码： 123456&gt; var a = new Buffer(&apos;key1=value1&amp;key2=value2&apos;).toString(&apos;base64&apos;);undefined&gt; a&apos;a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTI=&apos;&gt; new Buffer(a, &apos;base64&apos;).toString()&apos;key1=value1&amp;key2=value2&apos; 可以在终端中执行以下命令查看解码后的内容： 1echo a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTI= | base64 -D","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"base64","slug":"base64","permalink":"https://www.silenceboy.com/tags/base64/"}]},{"title":"JavaScript数组函数","slug":"JavaScript数组函数","date":"2016-08-25T01:54:30.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2016/08/25/JavaScript数组函数/","link":"","permalink":"https://www.silenceboy.com/2016/08/25/JavaScript数组函数/","excerpt":"","text":"下面总结了一些JavaScript中常用的数组操作方法。验证是不是数组用 arr instanceof Array 或者Array.isArray(arr)如果是返回truepush()在数组末尾添加并返回数组长度pop()移除数组的最后一项并返回移除的项shift()移除数组中的第一项并返回移除的项unshift()在数组前端添加任意个项并返回新的数组长度reverse()反转数组​join()将数组中的 值合并成字符串默认用,分割，可以自定义如join(‘|’);sort()升序排列数组，调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。可以接受一个比较函数作为参数如果对数值进行排序可以通过如下方法： 123456789101112function compare(value1,value2)&#123; //升序 ​if(value1&lt;value2)&#123; ​ ​return -1; ​&#125;else if(value1 &gt; value2)&#123; ​ ​return 1; ​&#125;else&#123; ​ ​return 0; ​&#125;&#125;var values=[0,1,5,10,15];values.sort(compare);console.log(values);//0,1,5,10,15 如需降序排列升序后使用reverse()即可concat()基于当前数组中的所有项创建一个新数组，如果传入参数，会将参数添加到数组的末尾slice()基于当前数组中的一或多个项创建一个新数组，接受一或两个参数，即要返回项的起始和结束位置，在只有一个参数的情况下返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。 splice(): 删除：删除任意数量的项，只需指定两个参数：要删除的第一项的位置和要删除的项数。例如splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项可以再传入第四、第五，任意多个项。 替换：可以向指定位置插入任意多个项，且同时删除任意数量的项，只需指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。 indexOf()和lastIndexOf()：这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()从前向后查找，lastIndexOf()从后向前查找，没找到的情况下返回-1","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"html5网页录音和语音识别","slug":"html5网页录音和语音识别","date":"2016-08-23T01:48:15.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2016/08/23/html5网页录音和语音识别/","link":"","permalink":"https://www.silenceboy.com/2016/08/23/html5网页录音和语音识别/","excerpt":"","text":"#背景 在输入方式上，人们总是在追寻一种更高效，门槛更低的方式，来降低用户使用产品的学习成本。语音输入也是一种尝试较多的方式，有些直接使用语音（如微信语音聊天），有些需要将语音转化为文字（语音识别）。接下来的内容是一次在pc浏览器上进行语音识别输入的一种尝试。 ### 实现 调研阶段，chrome是支持语音识别的。它支持了一系列的接口，可以进行语音识别。参考HTML5的Speech API相关标准的现状但是使用这些接口有一些困难，连不上服务器。此路不通。 那么，可以使用笨点儿的方法，先录音再上传到指定语音识别服务器，进行语音识别。这里使用的是百度语音开放平台的语音识别接口，支持8k,16k的单声道的wav文件，或者pcm。尝试了8k的识别效果，跟16k的差了好远。就使用了16k,单声道wav文件，上传到语音识别服务器。 关于录音，主要步骤就是使用navigator.getUserMedia来获取用户的输入设备，成功之后使用webkitAudioContext来创建音频实例。在录音结束之后，将录音的流导出为文件，上传即可。录音的可以参考这个recorder.js，只要稍微做一下修改就可以应用。其中需要处理音频采样率，默认的采样率为44.1k,这里需要做一个转换，具体方法可以参考HTML5网页录音和压缩,边猜边做 在浏览器扩展中，没有明确的方式去获取用户对录音的授权。可以在扩展的optionpage里面申请授权，之后在扩展的所有页面都有权限了。在较新的chrome浏览器里测过可以用。参考这里：How do I give webkitGetUserMedia permission in a Chrome Extension popup window #demo 这里有一个chrome扩展的demo，实现了通过语音采样，生成wav文件上传到语音识别服务器的功能。其中做了一个比较简单的端点检测，通过音量的大小来确定输入的完成。http://github.com/veizz/speech_io一些思考 demo其实是用来参与公司举办的一届hackathon比赛，主要实现了语音在线识别，文字播报等功能。在后期还有想法加入了一些自然语音处理的功能，可以识别一些输入指令。如『打开百度首页』、『上淘宝买衣服』等功能。会打开指定网站，自动填写输入词，执行搜索。还可以做一些小功能，比如说语音输入『查询天气』、『买电影票』等常用功能，在popup的窗口里面打开等。一切的想法都看起来很美好，但在大家都熟悉了打字输入的今天，还有多少人愿意使用语音识别做为输入方式？而对于不会打字的人，能否使用标准的普通话来进行语音识别的输入？ 采样率的处理是通过js的文件操作来实现的。html5支持的fileapi强大如此，怪不得有人用js做视频解码器，不考虑性能的话，看起来很美好啊 #参考 http://www.cnblogs.com/jz1108/archive/2012/05/21/2511447.htmlhttps://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.htmlhttp://codeartists.com/post/36746402258/how-to-record-audio-in-chrome-with-native-html5-apishttp://stackoverflow.com/questions/13076272/how-do-i-give-webkitgetusermedia-permission-in-a-chrome-extension-popup-windowhttp://www.cnblogs.com/blqw/p/3782420.htmlhttp://ibillxia.github.io/blog/2013/05/22/audio-signal-processing-time-domain-Voice-Activity-Detection/http://stackoverflow.com/questions/13333378/how-can-javascript-upload-a-blobhttp://www.web-tinker.com/article/20498.html","categories":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/categories/html5/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/tags/html5/"},{"name":"录音","slug":"录音","permalink":"https://www.silenceboy.com/tags/录音/"},{"name":"语言识别","slug":"语言识别","permalink":"https://www.silenceboy.com/tags/语言识别/"}]},{"title":"nodejs通过later实现定时执行任务","slug":"nodejs通过later实现定时执行任务","date":"2016-08-08T01:45:57.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2016/08/08/nodejs通过later实现定时执行任务/","link":"","permalink":"https://www.silenceboy.com/2016/08/08/nodejs通过later实现定时执行任务/","excerpt":"","text":"大多数情况我们都选用使用Linux的cron来控制定时执行的任务。当我们要维护多台计算机，几十个，几百个定时任务的时候，用cron会带来非常大的运维成本。可能写到程序中，就是一个不错的选择了。nodejs有一个later的插件可以简单实现该功能。如果已经安装过npm，可以直接执行npm install later安装该插件。如果没有请先安装npm。 12345678910111213141516var later = require(&apos;later&apos;);var basic = &#123;h:[00],m:[00]&#125;; //设置每天凌晨执行var composite=[ basic];var sched=&#123; schedules:composite&#125;;later.date.localTime(); //设置本地时区//var occurrences = later.schedule(sched).next(10);//for(var i=0;i&lt;10;i++)&#123;// console.log(occurrences[i]);//&#125;var t=later.setInterval(function()&#123; console.log(&quot;asdasd&quot;);&#125;,sched); 可根据自己的需求进行更改。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"MySQL查询表内重复记录","slug":"MySQL查询表内重复记录","date":"2016-08-04T02:02:52.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2016/08/04/MySQL查询表内重复记录/","link":"","permalink":"https://www.silenceboy.com/2016/08/04/MySQL查询表内重复记录/","excerpt":"","text":"1、查找表中多余的重复记录，重复记录是根据单个字段（user_id）来判断 1select * from tbl_user where user_id in (select user_id from people group by user_id having count(user_id) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（user_id）来判断，只留有一个记录 1delete from tbl_user where user_id in (select user_id from people group by user_id having count(user_id) &gt; 1) and min(id) not in (select id from people group by user_id having count(user_id)&gt;1) 3、查找表中多余的重复记录（多个字段） 1select * from table where (user_id,lesson_id) in (select user_id,lesson_id from table group by user_id,lesson_id having count(*) &gt; 1) 4、删除表中多余的重复记录（多个字段），只留有id最小的记录 1delete from table where (user_id,lesson_id) in (select user_id,lesson_id from table group by user_id,lesson_id having count(*) &gt; 1) and id not in (select min(id) from table group by user_id,lesson_id having count(*)&gt;1) 5、查找表中多余的重复记录（多个字段），不包含id最小的记录 1select * from table where (user_id,lesson_id) in (select user_id,lesson_id from table group by user_id,lesson_id having count(*) &gt; 1) and id not in (select min(id) from table group by user_id,lesson_id having count(*)&gt;1)","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"}]},{"title":"服务器时区问题","slug":"服务器时区问题","date":"2016-08-04T01:42:46.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2016/08/04/服务器时区问题/","link":"","permalink":"https://www.silenceboy.com/2016/08/04/服务器时区问题/","excerpt":"","text":"进入测试发现对应的时间不对，查了一下服务器的时间，发现服务器的时区为世界标准时间，简称UTC不属于任意时区，UTC时区默认比北京时间少8个小时。查看服务器时间： 这是服务器上的时区。中国的时区应该为CST。那么如何修改服务器时区为中国时区呐，很简单。 1cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 执行该命令，之后再查看时间： 现在的时间即为正确的中国时间。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"JavaScript获取时间戳与时间戳转化","slug":"JavaScript获取时间戳与时间戳转化","date":"2016-08-03T01:57:19.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2016/08/03/JavaScript获取时间戳与时间戳转化/","link":"","permalink":"https://www.silenceboy.com/2016/08/03/JavaScript获取时间戳与时间戳转化/","excerpt":"","text":"Javascript 获取当前时间戳（毫秒级别）： 第一种方法： 1var timestamp1 = Date.parse( new Date()); 结果：1470220594000 第二种方法： 1var timestamp2 = ( new Date()).valueOf(); 结果：1470220608533 第三种方法： 1var timestamp3 = new Date().getTime(); 结果：1470220608533 第一种获取的时间戳是精确到秒，第二种和第三种是获取的时间戳精确到毫秒。 获取指定时间的时间戳：1new Date(&quot;2016-08-03 00:00:00&quot;).getTime; 时间戳转化成时间：12345678910function timetrans(date)&#123; var date = new Date(date*1000);//如果date为13位不需要乘1000 var Y = date.getFullYear() + &apos;-&apos;; var M = (date.getMonth()+1 &lt; 10 ? &apos;0&apos;+(date.getMonth()+1) : date.getMonth()+1) + &apos;-&apos;; var D = (date.getDate() &lt; 10 ? &apos;0&apos; + (date.getDate()) : date.getDate()) + &apos; &apos;; var h = (date.getHours() &lt; 10 ? &apos;0&apos; + date.getHours() : date.getHours()) + &apos;:&apos;; var m = (date.getMinutes() &lt;10 ? &apos;0&apos; + date.getMinutes() : date.getMinutes()) + &apos;:&apos;; var s = (date.getSeconds() &lt;10 ? &apos;0&apos; + date.getSeconds() : date.getSeconds()); return Y+M+D+h+m+s;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"js利用clipboardData在网页中实现截屏粘贴的功能","slug":"js利用clipboardData在网页中实现截屏粘贴的功能","date":"2016-07-23T01:54:44.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2016/07/23/js利用clipboardData在网页中实现截屏粘贴的功能/","link":"","permalink":"https://www.silenceboy.com/2016/07/23/js利用clipboardData在网页中实现截屏粘贴的功能/","excerpt":"","text":"最近在做一个将屏幕截图直接粘贴发送的功能，于是对此做了一些研究，下面是具体的实现代码：html代码如下，在这里只是简单的做了一个textare框用作演示 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt;截屏粘贴&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea onpaste =&quot;paste()&quot;&gt; &lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt; 具体实现在JavaScript中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function paste(event)&#123; var clipboardData = event.clipboardData; console.log(clipboardData); var items,item,types; if( clipboardData )&#123; items = clipboardData.items; if( !items )&#123; return; &#125; // 保存在剪贴板中的数据类型 types = clipboardData.types || []; for(var i=0 ; i &lt; types.length; i++ )&#123; if( types[i] === &apos;Files&apos; )&#123; item = items[i]; break; &#125; &#125; // 判断是否为图片数据 if( item &amp;&amp; item.kind === &apos;file&apos; &amp;&amp; item.type.match(/^image\\//i) )&#123; // 读取该图片 var file = item.getAsFile(), reader = new FileReader(); reader.readAsDataURL(file); console.log(reader); //下面是讲粘贴的图片内容传送到后端进行处理，如果直接前端处理可以不要后边的代码 var xhr = new XMLHttpRequest(); xhr.open(&apos;post&apos;, &apos;/pasteImage&apos;,true); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); reader.onload = function()&#123; console.log(reader.result); xhr.send(JSON.stringify(&#123; file: reader.result &#125;)); &#125;; //接收返回数据 xhr.onload = function()&#123; var response = JSON.parse(xhr.responseText); if(response.code == 200)&#123; // &#125;else&#123; // &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"JSON.stringify 函数参数分析","slug":"JSON-stringify-函数参数分析","date":"2016-07-16T01:50:57.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2016/07/16/JSON-stringify-函数参数分析/","link":"","permalink":"https://www.silenceboy.com/2016/07/16/JSON-stringify-函数参数分析/","excerpt":"","text":"JSON.stringify是将 JavaScript 值转换为 JavaScript 对象表示法 。语法为：JSON.stringify(value [, replacer] [, space])很多人都只会用到第一个参数，所以导致很多人不知道后两个参数是什么意思，下面对三个参数进行分析： value必需。 要转换的 JavaScript 值（通常为对象或数组）。 replacer可选。 用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。 使用返回值而不是原始值。 如果此函数返回 undefined，则排除成员。 根对象的键是一个空字符串：””。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。 成员的转换顺序与键在数组中的顺序一样。 当 value 参数也为数组时，将忽略 replacer 数组。 space可选。 向返回值 JSON 文本添加缩进、空格和换行符以使其更易于读取。如果省略 space，则将生成返回值文本，而没有任何额外空格。如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格。 如果 space 大于 10，则文本缩进 10 个空格。如果 space 是一个非空字符串（例如“t”），则返回值文本在每个级别中缩进字符串中的字符。如果 space 是长度大于 10 个字符的字符串，则使用前 10 个字符。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"nodejs读写excel内容","slug":"nodejs读写excel内容","date":"2016-07-16T01:47:27.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2016/07/16/nodejs读写excel内容/","link":"","permalink":"https://www.silenceboy.com/2016/07/16/nodejs读写excel内容/","excerpt":"","text":"支持读写Excel的node.js模块 node-xlsx: 基于Node.js解析excel文件数据及生成excel文件，仅支持xlsx格式文件； excel-parser: 基于Node.js解析excel文件数据，支持xls及xlsx格式文件； excel-export : 基于Node.js将数据生成导出excel文件，生成文件格式为xlsx； node-xlrd: 基于node.js从excel文件中提取数据，仅支持xls格式文件。 我将展示通过node-xlsx提取上传上来的excel文件里的数据，以及生成新的excel文件。代码如下： 12345678910111213141516171819202122232425var xlsx = require(&apos;node-xlsx&apos;);var fs = require(&apos;fs&apos;);//读取文件内容var obj = xlsx.parse(__dirname+&apos;/test.xlsx&apos;);var excelObj=obj[0].data;console.log(excelObj);var data = [];for(var i in excelObj)&#123; var arr=[]; var value=excelObj[i]; for(var j in value)&#123; arr.push(value[j]); &#125; data.push(arr);&#125;var buffer = xlsx.build([ &#123; name:&apos;sheet1&apos;, data:data &#125; ]);//将文件内容插入新的文件中fs.writeFileSync(&apos;test1.xlsx&apos;,buffer,&#123;&apos;flag&apos;:&apos;w&apos;&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"excel","slug":"excel","permalink":"https://www.silenceboy.com/tags/excel/"}]},{"title":"web聊天系统的消息通知问题","slug":"web聊天系统的消息通知问题","date":"2016-07-06T06:42:58.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2016/07/06/web聊天系统的消息通知问题/","link":"","permalink":"https://www.silenceboy.com/2016/07/06/web聊天系统的消息通知问题/","excerpt":"","text":"web消息提示无非三种方式：声音提示，桌面弹窗和title闪烁提醒。下面做一一介绍。 声音提示注意声音提示前提示已经加载了声音文件，有文章写的很多是临时create一个audio对象，然后audio.src,这样做是非常不好的，因为你每次调用声音的时候都会去后台请求一下这个声音文件。所以先加载出来是最好的方法。 &lt;audio id=&quot;chat-audio&quot; src=&quot;audio/system.wav&quot; display=&quot;none&quot;&gt;&lt;/audio&gt; function playAudio() { document.getElementById(&apos;chat-audio&apos;).play(); //pause()方法也可以暂停，具体可查html5的audio标签 } //调用方式 playAudio(); 桌面弹窗function palyDeskNotice(theTitle, options) { if (Notification.permission !== &quot;granted&quot;) { //先判断一下用户是否已经开启了桌面提示的权限，如果没有则提醒用户开启 window.Notification.requestPermission(function(permission) { if (permission === &quot;granted&quot;) showNotice(theTitle, options); }); } else { showNotice(theTitle, options); } } function showNotice(theTitle, options) { //这个就是桌面弹窗 var desknotice = new Notification(theTitle, options); desknotice.onclick = function() { //当用户点击弹窗的时候，要定位到聊天窗口 window.focus(); desknotice.close(); }; //页面退出时关闭提醒 window.onbeforeunload = function() { desknotice.close(); } //弹窗3秒后自动消失 setTimeout(desknotice.close.bind(desknotice), 3000); } //调用方式 palyDeskNotice(&apos;来自xxx&apos;, { body: &apos;内容&apos;, icon: &quot;images/xxx.jpg&quot; }); title闪烁提醒的原理var NewMsgNoticeflag = false,//闪烁标识 newMsgNotinceTimer = null; function newMsgCount() { if (NewMsgNoticeflag) { NewMsgNoticeflag = false; document.title = &apos;【☏新消息】您有新的即时消息&apos;; } else { NewMsgNoticeflag = true; document.title = &apos;【 】您有新的即时消息&apos;; } } //兼容性 var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; : &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; : &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; : null; var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;); var onVisibilityChange = function() { if (!document[hiddenProperty]) { clearInterval(newMsgNotinceTimer); newMsgNotinceTimer = null; document.title = &apos;beta-即时消息系统&apos;; //窗口没有消息的时候默认的title内容 } } document.addEventListener(visibilityChangeEvent, onVisibilityChange); //调用方式 if (!newMsgNotinceTimer) newMsgNotinceTimer = setInterval(&quot;newMsgCount()&quot;, 200);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"JavaScript让时间显示为多久以前","slug":"JavaScript让时间显示为多久以前","date":"2016-06-02T06:41:28.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2016/06/02/JavaScript让时间显示为多久以前/","link":"","permalink":"https://www.silenceboy.com/2016/06/02/JavaScript让时间显示为多久以前/","excerpt":"","text":"在做论坛的功能时，要求帖子的发帖时间显示几秒前，几分钟前，几小时前。。。这种功能，于是就把获取到的发帖时间做了如下处理： 12345678910111213141516171819function gettime(createtime)&#123; var now=Date.parse(new Date())/1000; var limit=now-createtime; var content=&quot;&quot;; if(limit&lt;60)&#123; content=&quot;刚刚&quot;; &#125;else if(limit&gt;=60 &amp;&amp; limit&lt;3600)&#123; content=Math.floor(limit/60)+&quot;分钟前&quot;; &#125;else if(limit&gt;=3600 &amp;&amp; limit&lt;86400)&#123; content=Math.floor(limit/3600)+&quot;小时前&quot;; &#125;else if(limit&gt;=86400 &amp;&amp; limit&lt;2592000)&#123; content=Math.floor(limit/86400)+&quot;天前&quot;; &#125;else if(limit&gt;=2592000 &amp;&amp; limit&lt;31104000)&#123; content=Math.floor(limit/2592000)+&quot;个月前&quot;; &#125;else&#123; content=&quot;很久前&quot;; &#125; return content;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"express如何解决request entity too large问题","slug":"express如何解决request-entity-too-large问题","date":"2016-05-30T03:21:33.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2016/05/30/express如何解决request-entity-too-large问题/","link":"","permalink":"https://www.silenceboy.com/2016/05/30/express如何解决request-entity-too-large问题/","excerpt":"","text":"通过js向后台post一些文件信息时，会出现如下图所示的错误。这是express框架的问题，默认的很小，可以通过设置：app.use(express.json({limit: ‘5mb’}));解决该问题。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"Nodejs接收图片base64格式保存为文件","slug":"Nodejs接收图片base64格式保存为文件","date":"2016-05-27T03:19:30.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2016/05/27/Nodejs接收图片base64格式保存为文件/","link":"","permalink":"https://www.silenceboy.com/2016/05/27/Nodejs接收图片base64格式保存为文件/","excerpt":"","text":"base64的形式为“data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0。。。。”；当接收到上边的内容后，需要将data:image/png;base64,这段内容过滤掉，过滤成：“iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0。。。”；然后进行保存。 1234567891011121314app.post(&apos;/upload&apos;, function(req, res)&#123; //接收前台POST过来的base64 var imgData = req.body.imgData; //过滤data:URL var base64Data = imgData.replace(/^data:image\\/\\w+;base64,/, &quot;&quot;); var dataBuffer = new Buffer(base64Data, &apos;base64&apos;); fs.writeFile(&quot;image.png&quot;, dataBuffer, function(err) &#123; if(err)&#123; res.send(err); &#125;else&#123; res.send(&quot;保存成功！&quot;); &#125; &#125;);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"base64","slug":"base64","permalink":"https://www.silenceboy.com/tags/base64/"}]},{"title":"javascript在网页中实现粘贴qq截图功能","slug":"javascript在网页中实现粘贴qq截图功能","date":"2016-05-27T01:41:34.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2016/05/27/javascript在网页中实现粘贴qq截图功能/","link":"","permalink":"https://www.silenceboy.com/2016/05/27/javascript在网页中实现粘贴qq截图功能/","excerpt":"","text":"这篇文章主要介绍了在网页中实现读取剪贴板粘贴截图功能,即可以把剪贴板的截图Ctrl+V粘贴到网页的一个输入框中,例如QQ截图、旺旺截图或者其它截图软件。具体代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE HTML&gt;&lt;html lang=&quot;en-US&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;利用 clipboardData 在网页中实现截屏粘贴的功能&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#box&#123; width:200px; height:200px; border:1px solid #ddd; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;利用 clipboardData 在网页中实现截屏粘贴的功能&lt;/h1&gt; &lt;hr /&gt;&lt;div&gt;&lt;input type=&quot;text&quot; id=&quot;testInput&quot; placeholder=&quot;截屏后粘贴到输入框中&quot; size=&quot;30&quot; /&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;(function()&#123; var imgReader = function( item )&#123; var blob = item.getAsFile(), reader = new FileReader(); // 读取文件后将其显示在网页中 reader.onload = function( e )&#123; var img = new Image(); img.src = e.target.result; document.body.appendChild( img ); &#125;; // 读取文件 reader.readAsDataURL( blob ); &#125;; document.getElementById( &apos;testInput&apos; ).addEventListener( &apos;paste&apos;, function( e )&#123; // 添加到事件对象中的访问系统剪贴板的接口 var clipboardData = e.clipboardData, i = 0, items, item, types; if( clipboardData )&#123; items = clipboardData.items; if( !items )&#123; return; &#125; item = items[0]; // 保存在剪贴板中的数据类型 types = clipboardData.types || []; for( ; i &lt; types.length; i++ )&#123; if( types[i] === &apos;Files&apos; )&#123; item = items[i]; break; &#125; &#125; // 判断是否为图片数据 if( item &amp;&amp; item.kind === &apos;file&apos; &amp;&amp; item.type.match(/^image\\//i) )&#123; imgReader( item ); &#125; &#125; &#125;);&#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"js获取内容中的url链接，并设置a标签","slug":"js获取内容中的url链接，并设置a标签","date":"2016-05-24T01:39:27.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2016/05/24/js获取内容中的url链接，并设置a标签/","link":"","permalink":"https://www.silenceboy.com/2016/05/24/js获取内容中的url链接，并设置a标签/","excerpt":"","text":"12345var regexp = /(http:\\/\\/|https:\\/\\/)((\\w|=|\\?|\\.|\\/|\\&amp;|-)+)/g;content = content.replace(regexp, function($url)&#123; return &quot;&lt;a href=&apos;&quot; + $url + &quot;&apos; target=&apos;_blank&apos;&gt;&quot; + $url + &quot;&lt;/a&gt;&quot;;&#125;);console.log(content);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.silenceboy.com/tags/正则表达式/"}]},{"title":"vi/vim多行注释和取消注释","slug":"vi-vim多行注释和取消注释","date":"2016-05-21T01:37:05.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2016/05/21/vi-vim多行注释和取消注释/","link":"","permalink":"https://www.silenceboy.com/2016/05/21/vi-vim多行注释和取消注释/","excerpt":"","text":"多行注释： 进入命令行模式，按ctrl + v进入 visual block模式（可视快模式），然后按j, 或者k选中多行，把需要注释的行标记起来 按大写字母I，再插入注释符，例如// 按esc键就会全部注释了（我的是按两下） 取消多行注释： 进入命令行模式，按ctrl + v进入 visual block模式（可视快模式），按小写字母l横向选中列的个数，例如 // 需要选中2列 按字母j，或者k选中注释符号 按d键就可全部取消注释","categories":[{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/tags/vim/"},{"name":"vi","slug":"vi","permalink":"https://www.silenceboy.com/tags/vi/"}]},{"title":"nodejs如何获取form表单post方法提交的数据","slug":"nodejs如何获取form表单post方法提交的数据","date":"2016-05-18T05:41:40.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2016/05/18/nodejs如何获取form表单post方法提交的数据/","link":"","permalink":"https://www.silenceboy.com/2016/05/18/nodejs如何获取form表单post方法提交的数据/","excerpt":"","text":"首先通过：npm install formidable安装所需的包。下面给出一个测试的例子： 12345678910111213141516171819202122232425262728var formidable = require(&apos;formidable&apos;), http = require(&apos;http&apos;), util = require(&apos;util&apos;);http.createServer(function(req, res) &#123; if (req.url == &apos;/upload&apos; &amp;&amp; req.method.toLowerCase() == &apos;post&apos;) &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/plain&apos;&#125;); res.write(&apos;received upload:\\n\\n&apos;); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; // show a file upload form res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/html&apos;&#125;); res.end( &apos;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;&apos;+ &apos;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;br&gt;&apos;+ &apos;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&lt;br&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&apos;+ &apos;&lt;/form&gt;&apos; );&#125;).listen(8080); 通过formidable可以成功获取表单 提交的内容。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"连接Buffer对象的正确方法","slug":"连接Buffer对象的正确方法","date":"2016-04-12T05:39:41.000Z","updated":"2021-09-27T07:27:40.449Z","comments":true,"path":"2016/04/12/连接Buffer对象的正确方法/","link":"","permalink":"https://www.silenceboy.com/2016/04/12/连接Buffer对象的正确方法/","excerpt":"","text":"1234567891011121314151617181920212223var buffers = [];var nread = 0;readStream.on(&apos;data&apos;, function (chunk) &#123; buffers.push(chunk); nread += chunk.length;&#125;);readStream.on(&apos;end&apos;, function () &#123; var buffer = null; switch(buffers.length) &#123; case 0: buffer = new Buffer(0); break; case 1: buffer = buffers[0]; break; default: buffer = new Buffer(nread); for (var i = 0, pos = 0, l = buffers.length; i &lt; l; i++) &#123; var chunk = buffers[i]; chunk.copy(buffer, pos); pos += chunk.length; &#125; break; &#125;&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"buffer","slug":"buffer","permalink":"https://www.silenceboy.com/tags/buffer/"}]},{"title":"html5 实现网页截屏 页面生成图片","slug":"html5-实现网页截屏-页面生成图片","date":"2016-03-21T05:37:41.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2016/03/21/html5-实现网页截屏-页面生成图片/","link":"","permalink":"https://www.silenceboy.com/2016/03/21/html5-实现网页截屏-页面生成图片/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;layout&quot; content=&quot;main&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://html2canvas.hertzen.com/build/html2canvas.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready( function()&#123; $(&quot;.example1&quot;).on(&quot;click&quot;, function(event) &#123; event.preventDefault(); html2canvas(document.body, &#123; allowTaint: true, taintTest: false, onrendered: function(canvas) &#123; canvas.id = &quot;mycanvas&quot;; //document.body.appendChild(canvas); //生成base64图片数据 var dataUrl = canvas.toDataURL(); var newImg = document.createElement(&quot;img&quot;); newImg.src = dataUrl; document.body.appendChild(newImg); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello! &lt;div class=&quot;&quot; style=&quot;background-color: #abc;&quot;&gt; html5页面截图 &lt;/div&gt; &lt;textArea id=&quot;textArea&quot; col=&quot;20&quot; rows=&quot;10&quot; &gt;&lt;/textArea&gt; &lt;input class=&quot;example1&quot; type=&quot;button&quot; value=&quot;截图&quot;&gt; 生成界面如下： &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/categories/html5/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/tags/html5/"}]},{"title":"php根据IP地址获取地理位置","slug":"php根据IP地址获取地理位置","date":"2016-01-24T14:35:15.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2016/01/24/php根据IP地址获取地理位置/","link":"","permalink":"https://www.silenceboy.com/2016/01/24/php根据IP地址获取地理位置/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpheader(&quot;Content-type: text/html; charset=utf-8&quot;); //获取IP地址的方法function getIP()&#123; if (isset($_SERVER)) &#123; if (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; &#125; elseif (isset($_SERVER[&apos;HTTP_CLIENT_IP&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_CLIENT_IP&apos;]; &#125; else &#123; $realip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; &#125; else &#123; if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;)) &#123; $realip = getenv( &quot;HTTP_X_FORWARDED_FOR&quot;); &#125; elseif (getenv(&quot;HTTP_CLIENT_IP&quot;)) &#123; $realip = getenv(&quot;HTTP_CLIENT_IP&quot;); &#125; else &#123; $realip = getenv(&quot;REMOTE_ADDR&quot;); &#125; &#125; return $realip;&#125;echo $ip = getIP();//通过php的file_get_contents()方法获取地理位置//新浪接口根据ip查询所在区域信息$res0 = file_get_contents(&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&quot;);$res0 = json_decode($res0,true);print_r($res0);echo &quot;&lt;br/&gt;&quot;;//淘宝接口根据ip查询所在区域信息$res1 = file_get_contents(&quot;http://ip.taobao.com/service/getIpInfo.php?ip=$ip&quot;);$res1 = json_decode($res1,true);print_r($res1);echo &quot;&lt;br/&gt;&quot;;//通过php的curl获取地理位置//新浪根据IP获取地理位置API$url = &apos;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&apos;; $ch = curl_init($url); curl_setopt($ch,CURLOPT_ENCODING ,&apos;utf8&apos;); curl_setopt($ch, CURLOPT_TIMEOUT, 10); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true) ; // 获取数据返回 $location = curl_exec($ch); $location = json_decode($location); print_r($location);curl_close($ch); $loc = &quot;&quot;; if($location===FALSE) return &quot;&quot;; if (empty($location-&gt;desc)) &#123; $loc = $location-&gt;province.$location-&gt;city.$location-&gt;district.$location-&gt;isp; &#125;else&#123; $loc = $location-&gt;desc; &#125; echo $loc; //腾讯根据IP获取地理位置API$url = &apos;http://ip.qq.com/cgi-bin/searchip?searchip1=$ip&apos;; $ch = curl_init($url); curl_setopt($ch,CURLOPT_ENCODING ,&apos;gb2312&apos;); curl_setopt($ch, CURLOPT_TIMEOUT, 10); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true) ; // 获取数据返回 $result = curl_exec($ch); $result = mb_convert_encoding($result, &quot;utf-8&quot;, &quot;gb2312&quot;); // 编码转换，否则乱码 curl_close($ch); preg_match(&quot;@&lt;span&gt;(.*)&lt;/span&gt;&lt;/p&gt;@iU&quot;,$result,$ipArray); $loc = $ipArray[1]; echo $loc;","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"}]},{"title":"express简单测试连接mysql","slug":"express简单测试连接mysql","date":"2016-01-06T14:11:16.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2016/01/06/express简单测试连接mysql/","link":"","permalink":"https://www.silenceboy.com/2016/01/06/express简单测试连接mysql/","excerpt":"","text":"使用express应用生成器生成express模板后，先写package.json { &quot;name&quot;: &quot;mysql-test&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;start&quot;: &quot;node ./bin/www&quot; }, &quot;dependencies&quot;: { &quot;body-parser&quot;: &quot;~1.13.2&quot;, &quot;cookie-parser&quot;: &quot;~1.3.5&quot;, &quot;debug&quot;: &quot;~2.2.0&quot;, &quot;ejs&quot;: &quot;~2.3.3&quot;, &quot;express&quot;: &quot;~4.13.1&quot;, &quot;morgan&quot;: &quot;~1.6.1&quot;, &quot;serve-favicon&quot;: &quot;~2.3.0&quot;, &quot;mysql&quot;:&quot;*&quot; } } npm install安装依赖 新建立两个文件夹，models和config 写一个config配置文件，去连接mysql的: module.exports = { mysql_dev: { host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;your password&apos;, database: &apos;your db name&apos;, connectionLimit: 10, supportBigNumbers: true } }; 再写上一个database.js文件： var mysql = require(&apos;mysql&apos;); var config = require(&apos;../config/config&apos;); var pool = mysql.createPool(config.mysql_dev); exports.pool = pool; 在models里建立一个User.js文件作为model： var db = require(&apos;./database&apos;); var User = function() {}; User.prototype.find = function(id, callback) { var sql = &quot;SELECT * FROM users WHERE id =?&quot;; // get a connection from the pool db.pool.getConnection(function(err, connection) { if (err) { callback(true); return; } // make the query connection.query(sql, [id], function(err, results) { if (err) { callback(true); return; } callback(false, results); }); }); }; module.exports = User; 最后在app.js里引入，再调用： var User = require(&apos;./models/User&apos;); //....... app.get(&apos;/users/:userid&apos;,function(req,res){ var userid = req.params.userid; var user = new User(); user.find(userid,function(err,result){ if(err){ res.send(&apos;not found&apos;); } res.send(result.length === 1 ? result[0]:result); }); }); 这样就简单地完成一个后端的node.js分级结构，前端提供rest请求。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"express.js","slug":"express-js","permalink":"https://www.silenceboy.com/tags/express-js/"}]},{"title":"Chrome 浏览器中的插件Vimium","slug":"Chrome-浏览器中的插件Vimium","date":"2015-12-24T02:44:59.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2015/12/24/Chrome-浏览器中的插件Vimium/","link":"","permalink":"https://www.silenceboy.com/2015/12/24/Chrome-浏览器中的插件Vimium/","excerpt":"","text":"像使用vim一样使用浏览器，完全键盘操作，脱离鼠标。 Vimium 常用的按键功能解释：j：向下细微滚动窗口 k：向上细微滚动窗口J：(Shift+j的意思，以下大写全部表示加Shift) 下一个标签页 K：上一个标签页d：向下滚动半个屏幕 u：向上移动半个屏幕g+g（连续按两下g）：回到顶部G：到达页面底部H：后退 L： 前进f：将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框。如果按的是F，那么将在新窗口中打开页面（见上图）g+i：将光标 定位到输入框，如果有多个可以按Tab键切换x：关闭当前页面 X：恢复刚刚关闭的页面o：相当于Chrome中的地址栏，可以匹配历史记录、收藏夹并在当前窗口打开，或者直接打开一个网址或者搜索一个关键字（Chrome在全屏的时候地址栏死都出不来，有了它就解决这个一直困扰我的问题了！～），如果按的是O，则可以在新窗口中打开，非常非常方便！g+s：查看网页的源代码r：重新载入当前网页（顺便提一句，这点上新浪微博和它是一样的，光标没有定位在发送框时，即便没有安装这个插件你也可以用j/k来控制页面上下滚动，用r在刷新，用f或者p来定位到发送框。而Gmail的快捷键如j,k上下移动光标也是类似，有兴趣大家可以再自己去了解一下一些常用web应用的快捷键）Vimium / Vimperator 的快捷键远远不止我上面写的这些，想要把它玩得炉火纯青的话，按 shift+/ （chrome）或者是进入设置页面（firefox+chrome），可以找到更详细的的帮助。甚至，你还可以在设置中按照你自己的习惯替换掉一些键。","categories":[{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/categories/chrome/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/tags/chrome/"},{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/tags/vim/"}]},{"title":"phpmailer发送邮件 SMTP Error: Could not authenticate 错误","slug":"phpmailer发送邮件-SMTP-Error-Could-not-authenticate-错误","date":"2015-12-24T02:40:37.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2015/12/24/phpmailer发送邮件-SMTP-Error-Could-not-authenticate-错误/","link":"","permalink":"https://www.silenceboy.com/2015/12/24/phpmailer发送邮件-SMTP-Error-Could-not-authenticate-错误/","excerpt":"","text":"今天在使用phpmailer发送smtp邮件时提示 SMTP Error: Could not authenticate 错误，其中密码帐号都是正确的，邮箱也设置开启了SMTP功能。 上谷歌百度了一遍，有的说是服务器禁用了端口，有的说把class.phpmailer.php中的 代码如下 function IsSMTP() { $this-&gt;Mailer = &apos;smtp&apos;; } 改为 function IsSMTP() { $this-&gt;Mailer = &apos;SMTP&apos;; } （我的问题通过以上修改解决）如果解决不了还有一些解决方法可供参考：这个错误说明虚拟主机不支持PHPMailer默认调用的fsockopen函数，找到class.smtp.php文件，搜索fsockopen，就找到了这样一段代码： 代码如下 // connect to the smtp server $this-&gt;smtp_conn = @fsockopen($host,// the host of the server $port,// the port to use $errno, // error number if any $errstr, // error message if any $tval); // give up after ? secs 方法1：将fsockopen函数替换成pfsockopen函数 首先，在php.ini中去掉下面的两个分号 ;extension=php_sockets.dll ;extension=php_openssl.dll 然后重启一下 因为pfsockopen的参数与fsockopen基本一致，所以只需要将@fsockopen替换成@pfsockopen就可以了。 方法2：使用stream_socket_client函数 一般fsockopen()被禁，pfsockopen也有可能被禁，所以这里介绍另一个函数stream_socket_client()。 stream_socket_client的参数与fsockopen有所不同，所以代码要修改为： 代码如下 $this-&gt;smtp_conn = stream_socket_client(&quot;tcp://&quot;.$host.&quot;:&quot;.$port, $errno, $errstr, $tval); 这样就可以了。","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"}]},{"title":"php中如何使用phpredis","slug":"php中如何使用phpredis","date":"2015-12-24T02:34:10.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2015/12/24/php中如何使用phpredis/","link":"","permalink":"https://www.silenceboy.com/2015/12/24/php中如何使用phpredis/","excerpt":"","text":"安装redis服务：下载地址：http://redis.io/download，下载最新文档版本。本教程使用的最新文档版本为 2.8.17，下载并安装： $ wget http://download.redis.io/releases/redis-2.8.17.tar.gz $ tar xzf redis-2.8.17.tar.gz $ cd redis-2.8.17 $ make make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：下面启动redis服务. $ cd src $ ./redis-server 注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 $ cd src $ ./redis-server redis.conf redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如： $ cd src $ ./redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; 安装PHP redis 驱动装 PHP redis 驱动：下载地址为:https://github.com/nicolasff/phpredis。首先git clone 项目到本地，切换到phpredis目录下在shell中输入 phpize 然后 ./configure 进行配置（ps:可能找不到phpize，phpize是属于php-devel的内容，因此在centos中只要运行如下命令：yum install php-devel 然后就会安装上phpize了。）接下来就是最后的make 和make install了，make 之后记得跑一下 make test，在make install中遇到点权限问题，所以要加上sudo这样就完成了phpredis的编译工作，接下来我们需要来配置了。 然后，在PHP.INI 配置文件中添加一条extension = redis.so 就OK 对了，别忘了重启Apache","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"},{"name":"redis","slug":"redis","permalink":"https://www.silenceboy.com/tags/redis/"}]},{"title":"PHP获取IP地址以及IP地址所在位置","slug":"PHP获取IP地址以及IP地址所在位置","date":"2015-12-22T02:29:45.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2015/12/22/PHP获取IP地址以及IP地址所在位置/","link":"","permalink":"https://www.silenceboy.com/2015/12/22/PHP获取IP地址以及IP地址所在位置/","excerpt":"","text":"获取IP地址：12345678910111213141516171819202122function getIP()&#123; if (isset($_SERVER)) &#123; if (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; &#125; elseif (isset($_SERVER[&apos;HTTP_CLIENT_IP&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_CLIENT_IP&apos;]; &#125; else &#123; $realip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; &#125; else &#123; if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;)) &#123; $realip = getenv( &quot;HTTP_X_FORWARDED_FOR&quot;); &#125; elseif (getenv(&quot;HTTP_CLIENT_IP&quot;)) &#123; $realip = getenv(&quot;HTTP_CLIENT_IP&quot;); &#125; else &#123; $realip = getenv(&quot;REMOTE_ADDR&quot;); &#125; &#125; return $realip;&#125;echo $ip = getIP(); 新浪接口根据ip查询所在区域信息 1234$res0 = file_get_contents(&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&quot;);$res0 = json_decode($res0,true);print_r($res0);echo &quot;&lt;br/&gt;&quot;; 淘宝接口根据ip查询所在区域信息 1234$res1 = file_get_contents(&quot;http://ip.taobao.com/service/getIpInfo.php?ip=$ip&quot;);$res1 = json_decode($res1,true);print_r($res1);echo &quot;&lt;br/&gt;&quot;;","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"}]}],"categories":[{"name":"mcp","slug":"mcp","permalink":"https://www.silenceboy.com/categories/mcp/"},{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"},{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/categories/python/"},{"name":"ASIL","slug":"ASIL","permalink":"https://www.silenceboy.com/categories/ASIL/"},{"name":"SoC","slug":"SoC","permalink":"https://www.silenceboy.com/categories/SoC/"},{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"},{"name":"代码扫描","slug":"代码扫描","permalink":"https://www.silenceboy.com/categories/代码扫描/"},{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/categories/go/"},{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"},{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/categories/mac/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"},{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/categories/npm/"},{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"},{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/categories/ssh/"},{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"},{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/categories/shadowsock/"},{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/categories/html5/"},{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/categories/vim/"},{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"},{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/categories/chrome/"}],"tags":[{"name":"mcp","slug":"mcp","permalink":"https://www.silenceboy.com/tags/mcp/"},{"name":"AI","slug":"AI","permalink":"https://www.silenceboy.com/tags/AI/"},{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/tags/shell/"},{"name":"python","slug":"python","permalink":"https://www.silenceboy.com/tags/python/"},{"name":"ASIL","slug":"ASIL","permalink":"https://www.silenceboy.com/tags/ASIL/"},{"name":"SoC","slug":"SoC","permalink":"https://www.silenceboy.com/tags/SoC/"},{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"代码扫描","slug":"代码扫描","permalink":"https://www.silenceboy.com/tags/代码扫描/"},{"name":"go","slug":"go","permalink":"https://www.silenceboy.com/tags/go/"},{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"},{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"天空卫士","slug":"天空卫士","permalink":"https://www.silenceboy.com/tags/天空卫士/"},{"name":"jdk","slug":"jdk","permalink":"https://www.silenceboy.com/tags/jdk/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"M1","slug":"M1","permalink":"https://www.silenceboy.com/tags/M1/"},{"name":"i3wm","slug":"i3wm","permalink":"https://www.silenceboy.com/tags/i3wm/"},{"name":"i3","slug":"i3","permalink":"https://www.silenceboy.com/tags/i3/"},{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"java","slug":"java","permalink":"https://www.silenceboy.com/tags/java/"},{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/tags/npm/"},{"name":"scp","slug":"scp","permalink":"https://www.silenceboy.com/tags/scp/"},{"name":"zsh","slug":"zsh","permalink":"https://www.silenceboy.com/tags/zsh/"},{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"},{"name":"pm2","slug":"pm2","permalink":"https://www.silenceboy.com/tags/pm2/"},{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/tags/ssh/"},{"name":"jira","slug":"jira","permalink":"https://www.silenceboy.com/tags/jira/"},{"name":"portainer","slug":"portainer","permalink":"https://www.silenceboy.com/tags/portainer/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.silenceboy.com/tags/gitlab/"},{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"},{"name":"hexo","slug":"hexo","permalink":"https://www.silenceboy.com/tags/hexo/"},{"name":"express.js","slug":"express-js","permalink":"https://www.silenceboy.com/tags/express-js/"},{"name":"middleware","slug":"middleware","permalink":"https://www.silenceboy.com/tags/middleware/"},{"name":"tailf","slug":"tailf","permalink":"https://www.silenceboy.com/tags/tailf/"},{"name":"gitlab-runner","slug":"gitlab-runner","permalink":"https://www.silenceboy.com/tags/gitlab-runner/"},{"name":"sql server","slug":"sql-server","permalink":"https://www.silenceboy.com/tags/sql-server/"},{"name":"sms","slug":"sms","permalink":"https://www.silenceboy.com/tags/sms/"},{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/tags/shadowsock/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://www.silenceboy.com/tags/dockerfile/"},{"name":"base64","slug":"base64","permalink":"https://www.silenceboy.com/tags/base64/"},{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/tags/html5/"},{"name":"录音","slug":"录音","permalink":"https://www.silenceboy.com/tags/录音/"},{"name":"语言识别","slug":"语言识别","permalink":"https://www.silenceboy.com/tags/语言识别/"},{"name":"excel","slug":"excel","permalink":"https://www.silenceboy.com/tags/excel/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.silenceboy.com/tags/正则表达式/"},{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/tags/vim/"},{"name":"vi","slug":"vi","permalink":"https://www.silenceboy.com/tags/vi/"},{"name":"buffer","slug":"buffer","permalink":"https://www.silenceboy.com/tags/buffer/"},{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"},{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/tags/chrome/"},{"name":"redis","slug":"redis","permalink":"https://www.silenceboy.com/tags/redis/"}]}