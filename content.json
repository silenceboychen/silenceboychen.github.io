{"meta":{"title":"blog","subtitle":"silenceboychen's blog","description":"silenceboychen的个人博客","author":"chenhao","url":"https://www.silenceboy.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-09-27T07:27:40.433Z","updated":"2021-09-27T07:27:40.433Z","comments":false,"path":"/404.html","permalink":"https://www.silenceboy.com//404.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-09-27T07:27:40.457Z","updated":"2021-09-27T07:27:40.457Z","comments":true,"path":"links/index.html","permalink":"https://www.silenceboy.com/links/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-09-27T07:27:40.450Z","updated":"2021-09-27T07:27:40.450Z","comments":false,"path":"about/index.html","permalink":"https://www.silenceboy.com/about/index.html","excerpt":"","text":"简介 nodejs开发工程师 17839718588（微信同） | chenhao_312@126.com https://github.com/silenceboychen 博客： https://segmentfault.com/u/silenceboy/articles 河南大学 | 软件工程 | 本科 | 2012 - 2016 工作经验: 4年 期望职位: nodejs 后端开发工程师 期望工作地点: 杭州 现居地: 深圳 技能 3年+ nodejs开发经验，熟练使用nodejs框架：express,koa。正在学习框架：nest.js。 熟练使用typescript进行项目开发。 熟练掌握 MySQL 的使用，能够写出符合要求的 SQL 语句，掌握常见的 SQL 优化。 基于Linux开发，熟悉 Linux 环境的使用，掌握常用的 Linux 命令。 熟悉 Redis 等缓存技术的使用。 熟悉mongodb的基本查询，聚合查询。 熟练掌握 Git 的使用，善长多分支的管理。 熟练使用consul + grpc的微服务开发。 熟悉使用docker构建项目并自动化打包发布。 工作经验深圳点猫科技有限公司（2015年9月-2017年5月）编程猫官网项目地址：https://www.codemao.cn/ 项目描述：基于图形化的少儿编程项目，在线学编程。 责任描述： 担任后端开发组组长。 参与产品功能评审，整理项目需求，制定开发计划和方案，把控项目进度。 负责后端项目架构设计，数据库表结构设计以及大部分接口开发。 项目内推广使用typescript。 监督项目成员使用apidoc或swagger编写接口文档。 负责维护服务的正常访问，数据库的正常连接。 负责项目的docker化，编写dockerfile和docker-compose.yml。 使用到的技能：nodejs，typescript，git， mysql， redis， Linux， docker 猫老祖系统项目描述： 这是一个实时聊天系统,实现一对一，多对一，多对多的聊天。由最初的人工手动聊天到最后实现了系统自动化的聊天，节省了公司的人力成本。这个系统大致经历过四次技术选型上的迭代，websocket-&gt; 微信公众号 -&gt; 网易云信 -&gt; 融云。 责任描述： 项目唯一技术负责人，负责前后端开发。 参与产品功能评审，制定开发计划和方案，把控项目进度。 基于微信公众号开发，打通公众号和微信用户的实时聊天。 技术调研，根据功能需求，以及稳定性要求选择合适的第三方业务。 第三方IM服务对接。 负责项目后期维护。 负责项目的docker化，编写dockerfile和docker-compose.yml。 使用到的技能：nodejs，微信开发，WebSocket， MySQL， vue， redis， git, Linux 编程猫APP项目描述：官网对应的app版本（在移动化如此普及的今天，当然要做app）。 责任描述： 参与产品功能评审，制定开发计划和方案，把控项目进度。 封装第三方登录接口，提高代码复用性。 负责项目docker化。 使用到的技能：nodejs, express, mysql, git, linux 万汇互联（深圳）科技有限公司（2017年5月至今）公司官网地址：https://www.followme.com/ 项目描述：外汇交易平台，自主研发跟随系统，实现自主跟随下单，平仓等功能。 责任描述： 参与产品功能评审，制定开发计划和方案。 负责平台大部分接口开发。 使用rpc技术实现微服务架构，并使用consul管理微服务。 负责后端所有nodejs项目的docker化。 封装日志系统以及rpc相关方法，供所有项目使用。 输出详细的接口文档。 项目按照dev-&gt;beta-&gt;production的严格要求开发、测试、上线。 部门内多次开展技术分享。 使用到的技能：nodejs， express， koa， redis， docker， consul， grpc， git， linux 交易量化项目项目描述：该项目是公司最重要的一个项目，由我带领团队负责该项目的开发。该项目不对外公开，公司内部使用以及出售给其他企业使用，基于经纪商的交易数据，分析交易行情。目前在研发2.1版本，售价在50万左右。 责任描述： 项目部前端负责人，负责管理团队，合理分配工作。 参与产品功能设计和评审，制定开发计划和方案，并对功能质量和开发进度负责。 负责项目后端架构设计，服务端接口开发。 负责数据库表结构设计，以及数据库模型搭建。 负责项目docker化，通过docker-compose实现一键部署。 负责使用sql语句进行统计并以图表形式展示出来，数据量为400多万。 使用到的技能：nodejs，koa，mongodb，mysql, git, docker 自我评价 热爱计算机行业，热爱编程，追求代码质量，不畏挑战。 求知欲强、为新技术和自我提升而自豪。 责任心强，高效且有质量的完成工作。 对加班的态度： 不加班是能力问题，加班是态度问题，当能力不行的时候用态度来弥补。"},{"title":"Repositories","date":"2021-09-27T07:27:40.458Z","updated":"2021-09-27T07:27:40.458Z","comments":false,"path":"repository/index.html","permalink":"https://www.silenceboy.com/repository/index.html","excerpt":"","text":""},{"title":"爱","date":"2021-09-27T07:27:40.458Z","updated":"2021-09-27T07:27:40.458Z","comments":false,"path":"love/index.html","permalink":"https://www.silenceboy.com/love/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-27T07:27:40.458Z","updated":"2021-09-27T07:27:40.458Z","comments":false,"path":"tags/index.html","permalink":"https://www.silenceboy.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-27T07:27:40.450Z","updated":"2021-09-27T07:27:40.450Z","comments":false,"path":"categories/index.html","permalink":"https://www.silenceboy.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-09-27T07:27:40.450Z","updated":"2021-09-27T07:27:40.450Z","comments":false,"path":"books/index.html","permalink":"https://www.silenceboy.com/books/index.html","excerpt":"","text":""}],"posts":[{"title":"mac电脑M1芯片如何安装低版本node环境","slug":"mac电脑M1芯片如何安装低版本node环境","date":"2021-10-22T09:15:17.000Z","updated":"2021-10-22T09:25:13.767Z","comments":true,"path":"2021/10/22/mac电脑M1芯片如何安装低版本node环境/","link":"","permalink":"https://www.silenceboy.com/2021/10/22/mac电脑M1芯片如何安装低版本node环境/","excerpt":"","text":"在mac M1上安装v14 及以下的老版本 Node会出现闪退问题，究其原因还是因为低版本的 node 并不是基于 arm64 架构的，所以不适配 M1 芯片。在这里教大家两个方法，就能成功安装上低版本 Node。 方法一在终端中，输入： 1arch -x86_64 zsh 通过这个命令可以让 shell 运行在Rosetta2下。之后你可以通过 nvm install v14 来安装低版本 Node。在此之后，您可以不用在 Rosetta2 中就可以使用安装的可执行文件，也就是说，您可以将 Node v15与其他节点版本互换使用。 方法二方法二就是通过 Rosetta2 来启动终端，这样通过 Rosetta2 转译到 x86 架构中执行安装，也一样可以安装成功。 在 finder 中，点击应用程序，并在实用工具中找到终端 (Terminal) 右键终端，点击获取信息 勾选 Open using Rosetta 重启终端，并执行 nvm install v14 命令","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"M1","slug":"M1","permalink":"https://www.silenceboy.com/tags/M1/"}]},{"title":"Arch linux i3wm运行企业微信和微信","slug":"Arch-linux-i3wm运行企业微信和微信","date":"2021-05-26T14:05:02.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2021/05/26/Arch-linux-i3wm运行企业微信和微信/","link":"","permalink":"https://www.silenceboy.com/2021/05/26/Arch-linux-i3wm运行企业微信和微信/","excerpt":"","text":"当你运行在i3wm环境下时，运行通过deepin-wine安装的企业微信和微信时，打开软件时会出现闪退的现象，启动不了软件。或直接在命令行里执行命令也启动不了程序，会出现以下提示： 12345X Error of failed request: BadWindow (invalid Window parameter) Major opcode of failed request: 20 (X_GetProperty) Resource id in failed request: 0x0 Serial number of failed request: 10 Current serial number in output stream: 10 解决方案 这个问题其实和 KDE 无关, 应该是 deepin 在打包 deepin-wine 的过程中有意或者无意加入了 GNOME 依赖。 执行 /usr/lib/gnome-settings-daemon/gsd-xsettings 即可.或者后台运行： 1nohup /usr/lib/gnome-settings-daemon/gsd-xsettings &gt; /dev/null 2&gt;&amp;1 &amp; 如果 GNOME 的版本较低(比如Debian 9), 没有单独的 gsd-xsettings 可执行文件, 则执行 gnome-settings-daemon. 然后切换到对应目录 cd /opt/deepinwine/apps/Deepin-WXWork 或者 /opt/deepinwine/apps/Deepin-WeChat运行 ./run.sh即可启动软件。 由于每次都执行上边的命令很繁琐，可以将其加入i3的启动项，每次开机制动设置即可。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"},{"name":"i3wm","slug":"i3wm","permalink":"https://www.silenceboy.com/tags/i3wm/"},{"name":"i3","slug":"i3","permalink":"https://www.silenceboy.com/tags/i3/"}]},{"title":"MySQL TEXT数据类型的最大长度","slug":"MySQL-TEXT数据类型的最大长度","date":"2020-12-22T04:33:17.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2020/12/22/MySQL-TEXT数据类型的最大长度/","link":"","permalink":"https://www.silenceboy.com/2020/12/22/MySQL-TEXT数据类型的最大长度/","excerpt":"","text":"类型 长度 TINYTEXT 256 bytes TEXT 65,535 bytes ~64kb MEDIUMTEXT 16,777,215 bytes ~16MB LONGTEXT 4,294,967,295 bytes ~4GB","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"}]},{"title":"ubuntu18.04安装jdk1.8","slug":"ubuntu18-04安装jdk1-8","date":"2020-11-28T06:30:31.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2020/11/28/ubuntu18-04安装jdk1-8/","link":"","permalink":"https://www.silenceboy.com/2020/11/28/ubuntu18-04安装jdk1-8/","excerpt":"","text":"下载jdk安装包https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 解压1tar -zxvf jdk-8u171-linux-x64.tar.gz 移动到自己想放的位置12##将文件从下载目录 挪到/usr/local下sudo mv jdk1.8.0_171 /usr/local/jdk1.8 设置环境变量 设置全局生效 修改全局配置文件，作用与所有用户： vim /etc/profile 1234 export JAVA_HOME=/usr/local/jdk1.8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 设置当前用户生效 修改当前用户配置文件，只作用于当前用户：vim ~/.bashrc 1234 export JAVA_HOME=/usr/local/jdk1.8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 使修改的配置立刻生效1234##对应方法一：source /etc/profile ##对应方法二：source ~/.bashrc 检查是否安装成功1java -version","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"},{"name":"java","slug":"java","permalink":"https://www.silenceboy.com/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.silenceboy.com/tags/jdk/"}]},{"title":"alsamixer控制音量","slug":"alsamixer控制音量","date":"2020-11-28T05:51:40.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2020/11/28/alsamixer控制音量/","link":"","permalink":"https://www.silenceboy.com/2020/11/28/alsamixer控制音量/","excerpt":"","text":"解除各声道的静音目前版本的 ALSA 安装后，所有声道默认是静音的，必须手动解除。 使用 alsamixer 的 ncurses 界面，配置十分简单： 1$ alsamixer 此外，还可以在命令行下使用 amixer： 1$ amixer sset Master unmute 在alsamixer 中，下方标有 MM 的声道是静音的，而标有 00 的通道已经启用。 使用 ← 和 → 方向键，选中 Master 和 PCM 声道。按下 m 键解除静音。使用 ↑ 方向键增加音量，直到增益值为0。该值显示在左上方Item: 字段后。过高的增益值会导致声音失真。 要启用麦克风，切换至 Capture 选项卡，按下 F4，按下 空格 启用其中一个声道即可。 按下 Esc 键退出 alsamixer。 alsamixer 终端交互式设置音量123F6 选择网卡F2 显示系统信息，可以看到系统中已有网卡信息Esc 后退 123M 静音状态切换Q,W,E 增大 左,右,通道 的音量Z,X,C 减小 左,右,通道 的音量 amixer 命令行控制系统声音1cat /proc/asound/cards # 查看系统声卡 输出如下： 120 [PCH ]: HDA-Intel - HDA Intel PCH HDA Intel PCH at 0xe1340000 irq 130 设置声音 1amixer -c 1 -q set Master 2dB+ unmute 12-c 制定声卡id, 默认为0-q 安静模式，不输出结果","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"使用npm安装依赖时报错：gyp: No Xcode or CLT version detected!","slug":"使用npm安装依赖时报错：gyp-No-Xcode-or-CLT-version-detected","date":"2020-05-05T08:47:52.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2020/05/05/使用npm安装依赖时报错：gyp-No-Xcode-or-CLT-version-detected/","link":"","permalink":"https://www.silenceboy.com/2020/05/05/使用npm安装依赖时报错：gyp-No-Xcode-or-CLT-version-detected/","excerpt":"","text":"最近在macOS中使用npm安装模块，出现如下错误： 1234567891011121314151617181920212223npm WARN deprecated fsevents@1.2.12: fsevents 1 will break on node v14+. Upgrade to fsevents 2 with massive improvements.&gt; fsevents@1.2.12 install /Users/chenhao/outsourcing/egg-car/node_modules/fsevents&gt; node-gyp rebuildNo receipt for &apos;com.apple.pkg.CLTools_Executables&apos; found at &apos;/&apos;.No receipt for &apos;com.apple.pkg.DeveloperToolsCLILeo&apos; found at &apos;/&apos;.No receipt for &apos;com.apple.pkg.DeveloperToolsCLI&apos; found at &apos;/&apos;.gyp: No Xcode or CLT version detected!gyp ERR! configure errorgyp ERR! stack Error: `gyp` failed with exit code: 1gyp ERR! stack at ChildProcess.onCpExit (/Users/chenhao/.nvm/versions/node/v10.16.0/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)gyp ERR! stack at ChildProcess.emit (events.js:198:13)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12)gyp ERR! System Darwin 19.4.0gyp ERR! command &quot;/Users/chenhao/.nvm/versions/node/v10.16.0/bin/node&quot; &quot;/Users/chenhao/.nvm/versions/node/v10.16.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot;gyp ERR! cwd /Users/chenhao/outsourcing/egg-car/node_modules/fseventsgyp ERR! node -v v10.16.0gyp ERR! node-gyp -v v5.0.5gyp ERR! not ok 网上查找解决方案，都是通过执行xcode-select --install命令修复，但是执行该命令时会出现如下提示： 1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 最终的解决办法是先卸载之前安装的xcode-select，并重新安装： 12$ sudo rm -rf $(xcode-select -print-path)$ xcode-select --install","categories":[{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/tags/npm/"}]},{"title":"zsh在scp时不能使用通配符的原因和解决方案","slug":"zsh在scp时不能使用通配符的原因和解决方案","date":"2020-03-06T07:14:33.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2020/03/06/zsh在scp时不能使用通配符的原因和解决方案/","link":"","permalink":"https://www.silenceboy.com/2020/03/06/zsh在scp时不能使用通配符的原因和解决方案/","excerpt":"","text":"问题scp是经常使用的一个本地与远程服务器相互拷贝数据的命令，zsh是我最喜欢的shell，但是在zsh下使用scp来拷贝远程服务器的文件时，却出现这样的错误。 12$ scp -r test-server:/etc/nginx/conf.d/* .zsh: no matches found: test-server:/etc/nginx/conf.d/* 同样地命令，在bash下确实可以执行的，这个原因是什么呢？ 由于zsh不会按照远程地址上的文件去扩展参数，当你使用test-server:/etc/nginx/conf.d/*，因为本地当前目录中，是不存在test-server:/etc/nginx/conf.d/*，所以匹配失败。默认情况下，bash 在匹配失败时就使用原来的内容，zsh 则报告一个no matches的错误。 解决方案在zsh中执行setopt nonomatch，告诉它不要报告no matches的错误，而是当匹配失败时直接使用原来的内容。 实际上，不管是 bash 还是 zsh，不管设置了什么选项，只要把test-server:/etc/nginx/conf.d/*加上引号，如&quot;test-server:/etc/nginx/conf.d/*&quot;，就可解决问题。 当然根本的解决办法还是告诉zsh不要报告no matches错误。 执行下面的命令可以一劳永逸： 123$ echo &quot;setopt nonomatch&quot; &gt;&gt; ~/.zshrc或$ echo &quot;set -o nonomatch&quot; &gt;&gt; ~/.zshrc","categories":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"}],"tags":[{"name":"scp","slug":"scp","permalink":"https://www.silenceboy.com/tags/scp/"},{"name":"zsh","slug":"zsh","permalink":"https://www.silenceboy.com/tags/zsh/"}]},{"title":"git clone 出现ssh: connect to host github.com port 22: Connection timed out解决方案","slug":"git-clone-出现ssh-connect-to-host-github-com-port-22-Connection-timed-out解决方案","date":"2020-03-04T05:07:40.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2020/03/04/git-clone-出现ssh-connect-to-host-github-com-port-22-Connection-timed-out解决方案/","link":"","permalink":"https://www.silenceboy.com/2020/03/04/git-clone-出现ssh-connect-to-host-github-com-port-22-Connection-timed-out解决方案/","excerpt":"","text":"物理机服务器，安装git之后，想从github上clone自己的项目运行，ssh key已经配置过, 但在执行git clone命令时出现了如下报错： 1234ssh: connect to host github.com port 22: Connection timed outfatal: 无法读取远程仓库。请确认您有正确的访问权限并且仓库存在。 解决方案在系统~/.ssh目录下执行touch config命令新建config文件，并修改文件权限： 1sudo chmod 600 config 然后在config文件中添加如下内容： 123456Host github.comUser email@qq.com // 替换成自己的github登录邮箱Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 然后设置： 12git config --global user.name &quot;XXX&quot;git config --global user.email XXX@xx.com 此时再去执行git clone命令，一切正常。","categories":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"}]},{"title":"mysql5.7 ibtmp1文件过大","slug":"mysql5-7-ibtmp1文件过大","date":"2019-12-26T08:29:14.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2019/12/26/mysql5-7-ibtmp1文件过大/","link":"","permalink":"https://www.silenceboy.com/2019/12/26/mysql5-7-ibtmp1文件过大/","excerpt":"","text":"服务器上的磁盘被占满，通过一下命令查找服务器上的大文件： 1$ sudo find / -type f -size +800M -print0 | xargs -0 du -h | sort -nr 经过排查后发现，/var/lib/mysql目录下面有一个ibtmp1的文件特别大，有64G 。 ibtmp1是个什么东西呢？查看官方文档后发现这是非压缩的innodb临时表的独立表空间。通过innodb_temp_data_file_path参数指定文件的路径，文件名和大小，默认配置为ibtmp1:12M:autoextend，也就是说在支持大文件的系统这个文件大小是可以无限增长的。 解决办法： 修改my.cnf配置文件： 1innodb_temp_data_file_path = ibtmp1:12M:autoextend:max:5G 设置innodb_fast_shutdown参数 1SET GLOBAL innodb_fast_shutdown = 0; #InnoDB does a slow shutdown, a full purge and a change buffer merge before shutting down 关闭mysql服务 1systemctl stop mysqld.service 删除ibtmp1文件 启动mysql服务 1systemctl start mysqld.service","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"}]},{"title":"pm2日志拆分","slug":"pm2日志拆分","date":"2019-12-20T03:41:48.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2019/12/20/pm2日志拆分/","link":"","permalink":"https://www.silenceboy.com/2019/12/20/pm2日志拆分/","excerpt":"","text":"pm2默认会将日志文件写入家目录下的 .pm2/logs 目录中，但是pm2的日志文件不能自动分割，这会导致一个文件不断变大，不但影响性能，查看这些日志也会带来麻烦。 pm2的日志切割模块pm2-logrotate 安装pm2-logrotate： 1$ pm2 install pm2-logrotate 设置切割规则 12345678910111213141. 设置文件大小为100M，大于等于开始切割pm2 set pm2-logrotate:max_size 100M2.设置文件切割的监控间，监控间隔比较大，可能会使切割出的文件大小和max_size有出入pm2 set pm2-logrotate:workerInterval 13. 设置文件最多多少个，超过则删除pm2 set pm2-logrotate:retain 104. 设置文件是否压缩$ pm2 set pm2-logrotate:compress false5. 设置文件命名格式$ pm2 set pm2-logrotate:dateFormat YYYY-MM-DD_HH-mm-ss 更新pm2 执行一下命令使pm2配置生效 1$ pm2 update","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"pm2","slug":"pm2","permalink":"https://www.silenceboy.com/tags/pm2/"}]},{"title":"ssh使用ProxyCommand连接阿里云内网服务器","slug":"ssh使用ProxyCommand连接阿里云内网服务器","date":"2019-10-21T05:44:57.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2019/10/21/ssh使用ProxyCommand连接阿里云内网服务器/","link":"","permalink":"https://www.silenceboy.com/2019/10/21/ssh使用ProxyCommand连接阿里云内网服务器/","excerpt":"","text":"在没有发现proxyCommand命令的好处之前，本地连接想要访问内网服务器，需要先ssh连接开放外网ip并且与我们要访问的目标主机在同一个内网环境的esc服务器，然后将该服务器作为跳板机，在该服务器上ssh连接内网服务器。该操作非常麻烦。使用proxyCommand能够很方便的解决该问题。 proxyCommand配置修改~/.ssh/config： 123456789Host tiaobanHostname 跳板机的ipPort 跳板机的端口(如果是非22的需要填写)User root(如果非root,换成跳板机的用户)Host targetHostname 目标机的IPPort 跳板机的端口(如果是非22的需要填写)User root(如果非root,换成跳板机的用户)ProxyCommand ssh -q -x -W %h:%p tiaoban 这儿的%h表示要连接的目标机,也就是Hostname指定的ip或者主机名,%p表示要连接到目标机的端口.这儿可以直接写死固定值,但是使用%h和%p可以保证在Hostname和Port变化的情况下ProxyCommand这行不用跟着变化. 然后我们直接ssh target,可以看到直接就连接上了.","categories":[{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/categories/ssh/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/tags/ssh/"}]},{"title":"linux 添加只读用户","slug":"linux-添加只读用户","date":"2019-10-16T08:31:43.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2019/10/16/linux-添加只读用户/","link":"","permalink":"https://www.silenceboy.com/2019/10/16/linux-添加只读用户/","excerpt":"","text":"这里未使用rbash新建用户，使用rbash新建只读用户不能使用cd等内置命令。 添加用户 1# useradd -m test 设置密码 1# passwd test 修改用户的shell配置文件 12# chown root. /home/test/.bash_profile# chmod 755 /home/test/.bash_profile 修改/home/test/.bash_profile配置文件 将PATH改为$HOME/.bin 123456789101112# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then . ~/.bashrcfi# User specific environment and startup programs# PATH=$PATH:$HOME/.local/bin:$HOME/binPATH=$HOME/.binexport PATH 创建用户.bin目录 1# mkdir /home/test/.bin 将允许执行的命令链接到/home/test/.bin目录 123456789ln -s /usr/bin/wc /home/test/.bin/wcln -s /usr/bin/tail /home/test/.bin/tailln -s /usr/bin/more /home/test/.bin/moreln -s /usr/bin/cat /home/test/.bin/catln -s /usr/bin/grep /home/test/.bin/grepln -s /usr/bin/find /home/test/.bin/findln -s /usr/bin/pwd /home/test/.bin/pwdln -s /usr/bin/ls /home/test/.bin/lsln -s /usr/bin/less /home/test/.bin/less 之后使用创建的用户登录系统，用户只拥有只读权限，只能使用软连接的命令。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"Docker启用TLS进行安全配置","slug":"Docker启用TLS进行安全配置","date":"2019-09-29T01:56:59.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2019/09/29/Docker启用TLS进行安全配置/","link":"","permalink":"https://www.silenceboy.com/2019/09/29/Docker启用TLS进行安全配置/","excerpt":"","text":"之前开启了docker的2375 Remote API，由于没有启用TLS，导致服务器被入侵，安装了挖矿程序。所以如果想开通docker远程访问，就必须做好安全验证。 文中出现的$HOST指的是主机ip， 实际执行时用主机ip替换即可。 在Docker守护程序的主机上，生成CA私钥和公钥：1234567891011121314151617181920212223242526272829// 生成 CA 私钥root@docker-manager:~# openssl genrsa -aes256 -out ca-key.pem 4096Generating RSA private key, 4096 bit long modulus (2 primes).........................................................................++++.............................................++++e is 65537 (0x010001)// 需要输入两次自定义密码Enter pass phrase for ca-key.pem:Verifying - Enter pass phrase for ca-key.pem:// 生成 CA 公钥root@docker-manager:~# openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem// 这里需要输入第一步设置的密码Enter pass phrase for ca-key.pem:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:zhejiangLocality Name (eg, city) []:hangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Docker IncOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []: $HOSTEmail Address []: 创建服务器密钥和证书签名请求(CSR)1234567root@docker-manager:~# openssl genrsa -out server-key.pem 4096Generating RSA private key, 4096 bit long modulus (2 primes)......................................................................................................++++................++++e is 65537 (0x010001)root@docker-manager:~# openssl req -subj &quot;/CN=$HOST&quot; -sha256 -new -key server-key.pem -out server.csr 用CA签署公钥由于可以通过IP地址和DNS名称建立TLS连接，因此在创建证书时需要指定IP地址。例如，允许使用172.16.132.200和127.0.0.1进行连接： 这里遇到一个坑，如果IP后不指定本机ip，远程无法连接，不知道是不是配置哪里有问题，目前我会在下面的命令中添加IP:$HOST去解决问题 1root@docker-manager:~# echo subjectAltName = DNS:$HOST,IP:172.16.132.200,IP:127.0.0.1 &gt;&gt; extfile.cnf 将Docker守护程序密钥的扩展用法属性设置为仅用于服务器身份验证： 1root@docker-manager:~# echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf 生成服务端签名证书123456root@docker-manager:~# openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnfSignature oksubject=CN = 172.16.132.200Getting CA Private Key// 输入最开始设置的密码Enter pass phrase for ca-key.pem: 创建客户端密钥和证书签名请求1234567root@docker-manager:~# openssl genrsa -out key.pem 4096Generating RSA private key, 4096 bit long modulus (2 primes)..++++...............................................................................................................................................................................................................++++e is 65537 (0x010001)root@docker-manager:~# openssl req -subj &apos;/CN=client&apos; -new -key key.pem -out client.csr 为了使密钥适合客户端身份验证，请创建一个新的扩展配置文件： 1root@docker-manager:~# echo extendedKeyUsage = clientAuth &gt; extfile-client.cnf 生成客户端签名证书123456root@docker-manager:~# openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnfSignature oksubject=CN = clientGetting CA Private Key// 输入最开始设置的密码Enter pass phrase for ca-key.pem: 删除和修改文件权限生成后cert.pem，server-cert.pem您可以安全地删除两个证书签名请求和扩展配置文件： 12345root@docker-manager:~# rm -v client.csr server.csr extfile.cnf extfile-client.cnfremoved &apos;client.csr&apos;removed &apos;server.csr&apos;removed &apos;extfile.cnf&apos;removed &apos;extfile-client.cnf&apos; 为了保护您的钥匙免遭意外损坏，请删除其写权限。要使它们仅供您阅读，请按以下方式更改文件模式： 1234root@docker-manager:~# chmod -v 0400 ca-key.pem key.pem server-key.pemmode of &apos;ca-key.pem&apos; changed from 0600 (rw-------) to 0400 (r--------)mode of &apos;key.pem&apos; changed from 0600 (rw-------) to 0400 (r--------)mode of &apos;server-key.pem&apos; changed from 0600 (rw-------) to 0400 (r--------) 证书可以在世界范围内读取，但您可能希望删除写访问权限以防止意外损坏： 1234root@docker-manager:~# chmod -v 0444 ca.pem server-cert.pem cert.pemmode of &apos;ca.pem&apos; changed from 0644 (rw-r--r--) to 0444 (r--r--r--)mode of &apos;server-cert.pem&apos; changed from 0644 (rw-r--r--) to 0444 (r--r--r--)mode of &apos;cert.pem&apos; changed from 0644 (rw-r--r--) to 0444 (r--r--r--) 修改docker配置并重启docker编辑docker配置文件（我的是ubuntu机器）：vim /lib/systemd/system/docker.service 添加如下行： 1ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/root/docker/ca.pem --tlscert=/root/docker/server-cert.pem --tlskey=/root/docker/server-key.pem -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 重启docker服务： 12systemctl daemon-reloadsystemctl restart docker 查看端口号： 1234567root@docker-manager:~# netstat -plntActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp6 0 0 :::80 :::* LISTEN 858/nginx: master p tcp6 0 0 :::25 :::* LISTEN 1662/master tcp6 0 0 :::2375 :::* LISTEN 25582/dockerd tcp6 0 0 :::2377 :::* LISTEN 25582/dockerd 客户端远程安全连接将 ca.pem cert.pem key.pem三个文件通过 scp 下载到 客户端机器。 远程连接命令，路径根据实际情况填写： 123456docker --tlsverify \\ --tlscacert=/home/docker/ca.pem \\ --tlscert=/home/docker/cert.pem \\ --tlskey=/home/docker/key.pem \\ -H=172.16.132.200:2375 \\ info 把密钥放入 ~/.docker 文件夹中： 每次操作需要跟那么多参数，太麻烦了。我们可以把ca.pem cert.pem key.pem三个文件放入客户端~/.docker中，然后配置环境变量就可以简化命令了。 123$ export DOCKER_HOST=tcp://172.16.132.200:2375 DOCKER_TLS_VERIFY=1$ docker info","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"}]},{"title":"docker安装jira并破解","slug":"docker安装jira并破解","date":"2019-09-03T12:15:22.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2019/09/03/docker安装jira并破解/","link":"","permalink":"https://www.silenceboy.com/2019/09/03/docker安装jira并破解/","excerpt":"","text":"下载镜像1$ docker pull cptactionhank/atlassian-jira 运行容器12$ docker volume create jira_home$ docker run -d -p 8080:8080 --name jira --restart always -v jira_home:/var/atlassian/jira cptactionhank/atlassian-jira:latest 下载破解文件123$ wget https://github.com/silenceboychen/some-software/raw/master/Jira/mysql-connector-java-5.1.25-bin.jar$ wget https://github.com/silenceboychen/some-software/raw/master/Jira/atlassian-universal-plugin-manager-plugin-2.22.4.jar$ wget https://github.com/silenceboychen/some-software/raw/master/Jira/atlassian-extras-3.2.jar 添加mysql驱动程序mysql配置 12$ docker cp mysql-connector-java-5.1.25-bin.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/$ docker restart jira nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657upstream jira&#123; server 127.0.0.1:8080;&#125;# http配置#server &#123;# listen 80;# server_name jira.domain.com;# access_log /var/log/nginx/jira.domain.com-access.log;# error_log /var/log/nginx/jira.domain.com-error.log;# location / &#123;# proxy_pass_header Server;# proxy_set_header Host $http_host;# proxy_set_header X-Real-IP $remote_addr;# proxy_set_header X-Scheme $scheme;# proxy_pass http://jira;# &#125;#&#125;# https配置server &#123; #侦听443端口，这个是ssl访问端口 listen 443; #定义使用 访问域名 server_name jira.iblackvip.com; access_log /var/log/nginx/jira.domain.com.access.log; error_log /var/log/nginx/jira.domain.com.error.log; ssl on; ssl_certificate /etc/nginx/cert/jira.domain.com.pem; ssl_certificate_key /etc/nginx/cert/jira.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://jira; &#125; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;&#125;server &#123; # 80端口是http正常访问的接口 listen 80; server_name jira.domain.com; # 在这里，我做了https全加密处理，在访问http的时候自动跳转到https rewrite ^(.*) https://$host$1 permanent;&#125; Web设置 浏览器访问JiraWeb，语言可以设为中文，选择「我将设置它自己」——「下一步」 数据库设置，数据库类型选择「MySQL」，接着填入你的MySQL连接信息（需要你在你的MySQL数据库中创建数据库，数据库的字符类型必须是utf8），测试可以连接之后点击「下一步」 设置应用程序的属性——「下一步」 申请许可证关键字，点击「生成Jira试用许可证」 需要注册账号，注册完之后重新回到这个页面，选择相关信息，点击「Generate License」 点击「Yes」 页面就会带着你的许可证关键字回到Jira的设置页面，接着点击「下一步」 等待一会就进入设置管理员页面，填入一些信息即可，接着「下一步」 点击「完成」即完成设置 破解jira拷贝文件到容器内： 12$ docker cp atlassian-extras-3.2.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/$ docker cp atlassian-universal-plugin-manager-plugin-2.22.4.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/ 重启容器，破解结束： 1$ docker restart jira 查看jira页面设置-》应用程序，我们可以很明显的看到jira我们可以使用到2033年。","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"jira","slug":"jira","permalink":"https://www.silenceboy.com/tags/jira/"}]},{"title":"linux系统中root用户被提示：Operation not permitted","slug":"linux系统中root用户被提示：Operation-not-permitted","date":"2019-08-27T08:01:26.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2019/08/27/linux系统中root用户被提示：Operation-not-permitted/","link":"","permalink":"https://www.silenceboy.com/2019/08/27/linux系统中root用户被提示：Operation-not-permitted/","excerpt":"","text":"问题在修改文件权限时遇到如下报错： 12root@docker-manager:~/.ssh# chmod 600 authorized_keys chmod: changing permissions of &apos;authorized_keys&apos;: Operation not permitted 解决方法这里涉及到chattr和lsattr的知识： chattr是用来更改文件属性，lsattr可用来查看文件的属性，执行命令lsattr authorized_keys便可以看到当前文件的属性； 12root@docker-manager:~/.ssh# lsattr authorized_keys ----ia--------e--- authorized_keys 可以发现当前文件有个i属性，查阅命令帮助文档可以看到有i属性的文件是不能修改的，更不可被删除，即使是root用户也不可。 这里只需要去除i属性就可以修改文件权限。 123root@docker-manager:~/.ssh# chattr -i authorized_keys root@docker-manager:~/.ssh# lsattr authorized_keys -----a--------e--- authorized_keys chattr命令Linux chattr命令用于改变文件属性。 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： 12345678a：让文件或目录仅供附加用途。b：不更新文件或目录的最后存取时间。c：将文件或目录压缩后存放。d：将文件或目录排除在倾倒操作之外。i：不得任意更动文件或目录。s：保密性删除文件或目录。S：即时更新文件或目录。u：预防意外删除。 参数 1234567891011-R 递归处理，将指定目录下的所有文件及子目录一并处理。-v&lt;版本编号&gt; 设置文件或目录版本。-V 显示指令执行过程。+&lt;属性&gt; 开启文件或目录的该项属性。-&lt;属性&gt; 关闭文件或目录的该项属性。=&lt;属性&gt; 指定文件或目录的该项属性。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"部署Docker集群并使用Portainer管理","slug":"部署Docker集群并使用Portainer管理","date":"2019-08-14T04:34:06.000Z","updated":"2021-09-27T07:27:40.449Z","comments":true,"path":"2019/08/14/部署Docker集群并使用Portainer管理/","link":"","permalink":"https://www.silenceboy.com/2019/08/14/部署Docker集群并使用Portainer管理/","excerpt":"","text":"在有多台Docker的情况下，进行集群管理就十分重要了，Portainer也支持集群管理，Portainer可以和Swarm一起来进行集群管理操作。 环境要求 需要提前安装docker环境，docker安装教程。 使用docker安装portainer， 安装教程 搭建Swarm集群环境基本环境 用两台机器来搭建(都是ubuntu18.04系统) 12172.16.132.200 docker-manager172.16.132.201 dcoker-worker01 修改两台机器的主机名并做hosts 172.16.132.200机器 12345# hostnamectl set-hostname docker-manager# echo &quot;docker-manager&quot; &gt; /etc/hostname# vim /etc/hosts172.16.132.200 docker-manager172.16.132.201 dcoker-worker01 172.16.132.201机器 12345# hostnamectl set-hostname docker-worker01# echo &quot;docker-worker01&quot; &gt; /etc/hostname# vim /etc/hosts172.16.132.200 docker-manager172.16.132.201 dcoker-worker01 开通对外2375端口（方便portainer管理）12345678910111213// 先做备份# cp /lib/systemd/system/docker.service /lib/systemd/system/docker.service.bak # vim /lib/systemd/system/docker.service 找到ExecStart行改成这样的： ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375# systemctl daemon-reload# systemctl restart docker 重启docker服务，使用service docker restart也可以# netstat -plnt 查看端口号使用Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 20917/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 742/sshd tcp6 0 0 :::2375 :::* LISTEN 5836/dockerd tcp6 0 0 :::7946 :::* LISTEN 5836/dockerd tcp6 0 0 :::80 :::* LISTEN 20917/nginx: master Swarm集群创建初始化Swarm 12345678# docker swarm init --advertise-addr 172.16.132.200Swarm initialized: current node (7ggeai3dlqn0j8gkxjs46y250) is now a manager.To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-0n04bao3bkte48prmcf1xfmlfrk9zh19b9u16ysb63yhvgjiyi-3w0rd58keboh52zul8xcjfrof 172.16.132.200:2377To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions. 上面命令执行后，该机器自动加入到swarm集群。这个会创建一个集群token，获取全球唯一的 token，作为集群唯一标识。后续将其他节点加入集群都会用到这个token值。 123456789--advertise-addr 指定与其他 node 通信的地址。docker swarm init 输出告诉我们：① swarm 创建成功，swarm-manager 成为 manager node。② 添加 worker node 需要执行的命令。③ 添加 manager node 需要执行的命令。 添加集群节点 在docker-worker01机器上执行以下添加集群节点的操作命令: 1# docker swarm join --token SWMTKN-1-0n04bao3bkte48prmcf1xfmlfrk9zh19b9u16ysb63yhvgjiyi-3w0rd58keboh52zul8xcjfrof 172.16.132.200:2377 如后续要加入其他更多的节点,添加操作也是执行这个命令. 查看集群节点 在docker-manager机器上执行查看,因为此时它是swarm集群的leader节点: 1234root@docker-manager:~# docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION7ggeai3dlqn0j8gkxjs46y250 * docker-manager Ready Active Leader 18.09.71v09483w8dczd36bmtruzm2ix docker-node01 Ready Active 19.03.1 最后查看下两个机器上的2375端口是否都已经开启了 1234567[root@docker-manager ~]# lsof -i:2375COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdockerd 13785 root 5u IPv6 4518841 0t0 TCP *:2375 (LISTEN)[root@docker-woeker01 ~]# lsof -i:2375COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdockerd-c 2966 root 5u IPv6 3602947 0t0 TCP *:2375 (LISTEN) 部署Portainer12345$ docker volume create portainer_data$ docker run -d -p 8000:8000 -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9b051147a4c2 portainer/portainer &quot;/portainer&quot; 20 hours ago Up 18 hours 0.0.0.0:9000-&gt;9000/tcp portainer 访问http://172.16.132.200:9000, 同样首次登陆需要注册用户，给admin用户设置密码： 集群模式, 这样一定要选择Remote, 输入docker-worker01的ip，然后点击Connect。 同样点击左边栏的”Endpoints” - “+add endpoint”, 添加集群节点: 添加之后,点击左边栏的”Home”, 右边就可以看到节点信息了,可以进行切换操作.","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"portainer","slug":"portainer","permalink":"https://www.silenceboy.com/tags/portainer/"}]},{"title":"ubuntu18.04安装mysql并允许远程访问","slug":"ubuntu18-04安装mysql并允许远程访问","date":"2019-07-23T10:29:37.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2019/07/23/ubuntu18-04安装mysql并允许远程访问/","link":"","permalink":"https://www.silenceboy.com/2019/07/23/ubuntu18-04安装mysql并允许远程访问/","excerpt":"","text":"安装1$ apt-get install mysql-server mysql-client 字符集修改utf8进入mysql命令终端：（默认root密码为空）: 1$ mysql -u root -p 12345678910111213mysql&gt; show variables like &apos;char%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 12345678mysql&gt; show variables like &apos;collation%&apos;;+----------------------+-------------------+| Variable_name | Value |+----------------------+-------------------+| collation_connection | utf8_general_ci || collation_database | latin1_swedish_ci || collation_server | latin1_swedish_ci |+----------------------+-------------------+ 修改字符集： 123456$ vim /etc/mysql/mysql.conf.d/mysqld.cnf// 在文件末尾添加以下内容：collation-server = utf8_unicode_ciinit-connect=&apos;SET NAMES utf8&apos;character-set-server = utf8 重启后字符集修改为utf8： 1$ service mysql restart 修改端口号修改mysql配置文件，然后重启即可生效： 1234$ vim /etc/mysql/mysql.conf.d/mysqld.cnf// 修改以下内容：port = 6033 登录权限问题查看当前用户： 12345678910mysql&gt; SELECT User,Host FROM mysql.user;+------------------+-----------+| User | Host |+------------------+-----------+| debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+------------------+-----------+4 rows in set (0.00 sec) 删除root账号： 123456789101112mysql&gt; DROP USER &apos;root&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT User,Host FROM mysql.user;+------------------+-----------+| User | Host |+------------------+-----------+| debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost |+------------------+-----------+3 rows in set (0.00 sec) 重新创建root： 12345678910111213mysql&gt; CREATE USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT User,Host FROM mysql.user;+------------------+-----------+| User | Host |+------------------+-----------+| root | % || debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost |+------------------+-----------+4 rows in set (0.00 sec) 授权： 12345mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; WITH GRANT OPTION;Query OK, 0 rows affected (0.01 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 退出mysql，修改配置文件： 12$ vim /etc/mysql/mysql.conf.d/mysqld.cnf注释这一行：bind-address:127.0.0.1 重新启动mysql: 1$ service mysql restart","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"}]},{"title":"docker安装gitlab","slug":"docker安装gitlab","date":"2019-07-15T02:49:01.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2019/07/15/docker安装gitlab/","link":"","permalink":"https://www.silenceboy.com/2019/07/15/docker安装gitlab/","excerpt":"","text":"docker安装gitlabGitLab 分为 社区版（Community Edition，缩写为 CE）和 企业版（Enterprise Edition，缩写为 EE）。社区版是免费的，而企业版包含一些收费服务，一般来说个人开发者用社区版就足够了。 下载镜像 首先需要先下载 GitLab CE 的镜像，使用下面的命令进行下载，因为文件较大，所以可能需要一点时间，耐心等待即可。 12# 不加 tag 则默认为最新版本 latest$ docker pull gitlab/gitlab-ce 启动运行123456789$ docker run --detach \\ --hostname gitlab.example.com \\ --publish 8443:443 --publish 8880:80 --publish 8222:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 说明: –hostname gitlab.example.com: 设置主机名或域名 –publish 8443:443：将http：443映射到外部端口8443 –publish 8880:80：将web：80映射到外部端口8880 –publish 8222:22：将ssh：22映射到外部端口8222 –name gitlab: 运行容器名 –restart always: 自动重启 –volume /srv/gitlab/config:/etc/gitlab: 挂载目录 –volume /srv/gitlab/logs:/var/log/gitlab: 挂载目录 –volume /srv/gitlab/data:/var/opt/gitlab: 挂载目录 运行成功之后，可以使用下面的命令查看容器运行状态： 1$ docker ps 可以看到 GitLab 已经在运行了，有一个属性 STATUS 为 health: starting，说明 gitlab 的服务正在启动中，还没有启动完毕。等这个状态变成 healthy 时则说明已经部署完成，可以访问了。 访问gitlab启动成功后，浏览器访问http://ip:8880, 即可访问。为了使用域名访问，需要配置nginx： 1234567891011121314151617upstream gitlab&#123; server 127.0.0.1:8880;&#125;server &#123; listen 80; server_name gitlab.example.com; access_log /var/log/nginx/gitlab.example.com-access.log; error_log /var/log/nginx/gitlab.example.com-error.log; location / &#123; proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://gitlab; &#125;&#125; nginx重启配置生效后，浏览器访问http://gitlab.example.com 即可正常访问。 首次访问需要为root用户设置密码，设置完成后需要登录，默认用户名为：root， 密码为刚刚设置的密码。 配置邮件服务器想要让 GitLab 给你发送邮件，还要配置一下邮件服务器，这里以QQ邮箱的 IMAP/SMTP服务 来配置。 打开邮箱-&gt;设置-&gt;账户，然后开启 IMAP/SMTP服务，然后根据文档获取 授权码 ，这步比较重要。 然后跳转至挂载目录 /srv/gitlab/config/ 编辑gitlab.rb 文件，找到 Email Settings的注释位置，然后修改以下内容： 1234567891011### Email Settingsgitlab_rails[&apos;smtp_enable&apos;] = true # 开启 SMTP 功能gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.qq.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 465 # 端口不可以选择587，测试过会发送邮件失败gitlab_rails[&apos;smtp_user_name&apos;] = &quot;test@qq.com&quot; # 你的邮箱账号gitlab_rails[&apos;smtp_password&apos;] = &quot;1324dasd&quot; # 授权码，不是密码gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;smtp_tls&apos;] = truegitlab_rails[&apos;gitlab_email_from&apos;] = &apos;test@qq.com&apos; # 发件人信息，必须跟‘smtp_user_name’保持一致，否则报错gitlab_rails[&apos;smtp_domain&apos;] = &quot;qq.com&quot; # 修改并不影响 配置完成后保存，然后输入下面的命令使配置生效。 1$ docker exec gitlab gitlab-ctl reconfigure 使配置生效之后我们可以使用 gitlab 自带的工具进行一下测试。依次执行下面的命令： 12345678# 开启 gitlab 的 bash 工具$ docker exec -it gitlab bash# 开启 gitlab-rails 工具$ gitlab-rails console production# 发送邮件进行测试Notify.test_email(&apos;test_001@123.com&apos;, &apos;Message Subject&apos;, &apos;Message Body&apos;).deliver_now 测试完成之后退出gitlab的bash工具，重启 gitlab 即可。 1$ docker restart gitlab 修改SSH因为项目启动时gitlab内部的22端口号映射到宿主机的端口号是8222，所以需要配置gitlab的ssh端口号： 找到如下内容，将端口号修改为8222. 1gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 8222 配置完成后保存，然后输入下面的命令使配置生效。 12$ docker exec gitlab gitlab-ctl reconfigure$ docker restart gitlab 配置 Git 仓库访问路径在之前第一次运行 gitlab 容器的时候，有一个参数 hostname 为 gitlab.example.com , 如果配置了域名可以忽略这一步，如果你没有配置相应域名的话，你的仓库的地址将会变为下面这样： 12ssh : git@gitlab.example.com:test/test.githttp：gitlab.example.com/test/test.git 如果域名不存在的话，这个地址是无法进行 clone 的。 为了解决这个问题，我们可以设置成 IP 或 你配置了的域名来访问。 打开文件 /srv/gitlab/config/gitlab.rb 文件并找到 1# external_url &apos;GENERATED_EXTERNAL_URL&apos; 这行，去掉注释，并按照下面的格式修改。 1234567891011# ip 形式external_url &apos;http://192.168.1.44&apos;# 域名形式external_url &apos;http://JemGeek.com&apos;# 子域名external_url &apos;http://gitlab.JemGeek.com&apos;# 其他形式external_url &apos;http://JemGeek.com/gitlab&apos; 以上形式都是可以的。修改完成后，输入命令: 1$ docker exec gitlab gitlab-ctl reconfigure 使配置生效，然后重启 gitlab 即可。 升级参照官方的说明， 将原来的容器停止， 然后删除： 12$ docker stop gitlab$ docker rm gitlab 然后重新拉一个新版本的镜像下来， 1$ docker pull gitlab/gitlab-ce 使用原来的运行命令运行： 12345678910$ docker run --detach \\ --hostname gitlab.example.com \\ --publish 8443:443 --publish 8880:80 --publish 8222:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ --privileged=true \\ gitlab/gitlab-ce:latest GitLab 在初次运行的时候会自动升级， 为了预防万一， 还是建议先备份一下 /srv/gitlab/ 这个目录。 大版本升级（例如从 8.7.x 升级到 8.8.x）用上面的操作有可能会出现错误， 如果出现错误可以尝试登录到容器内部, 依次执行下面的命令： 12$ gitlab-ctl reconfigure$ gitlab-ctl restart","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.silenceboy.com/tags/gitlab/"}]},{"title":"js打印带颜色的 console 信息","slug":"js打印带颜色的-console-信息","date":"2019-07-12T06:30:24.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2019/07/12/js打印带颜色的-console-信息/","link":"","permalink":"https://www.silenceboy.com/2019/07/12/js打印带颜色的-console-信息/","excerpt":"","text":"打印红色的hello world: 1console.log(`\\x1b[31mhello world\\x1b[31m`) 以下是可以使用的文本命令的参考： 前景色（文字颜色）： 12345678\\x1b[30m = 黑色\\x1b[31m = 红色\\x1b[32m = 绿色\\x1b[33m = 黄色\\x1b[34m = 蓝色\\x1b[35m = 洋红色\\x1b[36m = 青色\\x1b[37m = 白色 背景色： 12345678\\x1b[40m = 黑色\\x1b[41m = 红色\\x1b[42m = 绿色\\x1b[43m = 黄色\\x1b[44m = 蓝色\\x1b[45m = 洋红色\\x1b[46m = 青色\\x1b[47m = 白色 其他： 1234567\\x1b[0m = 清除样式\\x1b[1m = 加粗\\x1b[2m = 半透明\\x1b[4m = 下划线\\x1b[5m = 闪动\\x1b[7m = 取反：背景色变前景色 前景色变背景色\\x1b[8m = 看不见 但位置还留着","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"eval()与new Function()","slug":"eval-与new-Function","date":"2019-04-14T12:55:54.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2019/04/14/eval-与new-Function/","link":"","permalink":"https://www.silenceboy.com/2019/04/14/eval-与new-Function/","excerpt":"","text":"evaleval接受字符串参数，解析其中的js代码。如果编译失败，会抛出异常，否则执行其中的代码，计算返回值。 12eval(&apos;2+2&apos;); // 4eval(&apos;console.log(&quot;ok&quot;)&apos;); // ok 在实际应用中，通常这样转换JSON。 12var jsonStr = &apos;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&apos;;eval(&apos;(&apos; + jsonStr + &apos;)&apos;); 为什么要加括号呢？ 因为js中{}通常是表示一个语句块，eval只会计算语句块内的值进行返回。加上括号就变成一个整体的表达式。 12console.log( eval(&apos;&#123;&#125;&apos;) ); // undefindconsole.log( eval(&apos;(&#123;&#125;)&apos;) ); // Object &#123;&#125; 使用eval需要注意执行作用域 1234567var s = 1;function a() &#123; eval(&apos;var s=2&apos;); console.log(s);&#125;a(); // 2console.log(s); // 1 在局部环境使用eval便会创建局部变量。可以显示指定eval调用者来改变上下文环境。 1234567var s = &apos;global&apos;;function a() &#123; eval(&apos;var s = &quot;local&quot;&apos;); console.log(s); // local console.log(eval(&apos;s&apos;)); // local console.log(window.eval(&apos;s&apos;)); // global&#125; Function在之前我对于Function的了解只限于“定义方法的一种非主流方式”。却忽略了Function与eval相同的字符串参数特性。 语法：var func = new Function(arg1, arg2, ..., functionBody); 实例： 12var add = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a+b;&apos;);console.log( add(2, 3) ); // 5 由于其形参使用字符串的方式表示，也可以使用1个字符串来描述多个形参。 12var add = new Function(&apos;a, b&apos;, &apos;return a+b;&apos;);console.log( add(2, 3) ); // 5 在转换JSON的实际应用中，只需要这么做。 12var jsonStr = &apos;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&apos;, json = (new Function(&apos;return &apos; + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。如果可以，请用更好的方法替代。 在一些特殊的运用场合，也有一些合理运用的实践。比如模板解析等。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"js实现凯撒密码 (Caesars Cipher)","slug":"js实现凯撒密码-Caesars-Cipher","date":"2019-04-04T09:31:04.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2019/04/04/js实现凯撒密码-Caesars-Cipher/","link":"","permalink":"https://www.silenceboy.com/2019/04/04/js实现凯撒密码-Caesars-Cipher/","excerpt":"","text":"凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。 所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 判断是否为大写也不难，我们可以通过 .charCodeAt() 返回的 ASCII 码来判断 至于加密的实现，我们可以像这样分情况讨论： 如果当前字符为 A - M 之间，对应的 ASCII 码范围就是 65 - 77，那么 ROT13 加密应该给它的 ASCII 码加 13 如果当前字符为 N - Z 之间，对应的 ASCII 码范围就是 78 - 90，那么 ROT13 加密应该给它的 ASCII 码减 13 如果当前字符为其他 (小写，空格或特殊符号)，那就不应该执行任何操作 12345678910111213141516171819function rot13(str) &#123; let result = &quot;&quot;; for (let i = 0; i &lt; str.length; i++) &#123; const currentCode = str[i].charCodeAt(); if (currentCode &gt; 90 || currentCode &lt; 65) &#123; // 非大写字符 result += String.fromCharCode(currentCode); &#125; else if (currentCode &lt; 78) &#123; // 大写字符 A - M result += String.fromCharCode(currentCode + 13); &#125; else &#123; // 大写字符 N - Z result += String.fromCharCode(currentCode - 13); &#125; &#125; return result;&#125; 通过求余数来进行优化： 123function rot13(str) &#123; return str.replace(/[A-Z]/g, char =&gt; String.fromCharCode(char.charCodeAt() % 26 + 65));&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"}]},{"title":"使用git进行远程分支同步","slug":"使用git进行远程分支同步","date":"2019-04-03T02:48:12.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2019/04/03/使用git进行远程分支同步/","link":"","permalink":"https://www.silenceboy.com/2019/04/03/使用git进行远程分支同步/","excerpt":"","text":"在git项目目录下执行git remote show origin命令： 12345678910111213➜ api git:(419788c) ✗ git remote show origin* remote origin Fetch URL: git@github.com:silenceboychen/blog.git Push URL: git@github.com:silenceboychen/blog.git HEAD branch: master Remote branches: alibeta tracked dev tracked master tracked production tracked refs/remotes/origin/feat-10.9 stale (use &apos;git remote prune&apos; to remove) refs/remotes/origin/feat-docker stale (use &apos;git remote prune&apos; to remove) refs/remotes/origin/feat_avatar stale (use &apos;git remote prune&apos; to remove) 可以看到有一些状态为stale的分支，这些分支都已经被删除了，但是我们本机上还有记录，这些记录不会通过git pull自动清除。 为了删除这些分支，实现和远程分支的同步，可以执行git remote prune origin 123456➜ api git:(419788c) ✗ git remote prune originPruning originURL: git@github.com:silenceboychen/blog.git * [pruned] origin/feat-10.9 * [pruned] origin/feat-docker * [pruned] origin/feat_avatar 再次查看，发现那些无效分支已经在本机被删除： 1234567891011121314➜ api git:(419788c) ✗ git remote show origin* remote origin Fetch URL: git@github.com:silenceboychen/blog.git Push URL: git@github.com:silenceboychen/blog.git HEAD branch: master Remote branches: alibeta tracked dev tracked master tracked production tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (local out of date)","categories":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"}]},{"title":"关于js的浅拷贝与深拷贝","slug":"关于js的浅拷贝与深拷贝","date":"2019-04-02T03:10:59.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2019/04/02/关于js的浅拷贝与深拷贝/","link":"","permalink":"https://www.silenceboy.com/2019/04/02/关于js的浅拷贝与深拷贝/","excerpt":"","text":"浅拷贝和深拷贝只针对像Object, Array这样的复杂对象的.简单来说，浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。 浅拷贝通过 Object.assign 来实现浅拷贝。123456let a = &#123; num: 1&#125;let b = Object.assign(&#123;&#125;, a)a.num = 2console.log(b.num) // 1 通过展开运算符(…)来实现浅拷贝123456let a = &#123; num: 1&#125;let b = &#123;...a&#125;a.num = 2console.log(b.num) // 1 通过属性赋值来实现浅拷贝:123456789101112const obj = &#123; a:1, arr: [2,3] &#125;;const shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 该方法体现了浅拷贝的问题．因为浅拷贝只会将对象的各个属性进行依次拷贝，并不会进行递归拷贝，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址． 导致的结果就是： 12shallowObj.arr[1] = 5;obj.arr[1] // = 5 这种情况就需要用到深拷贝了． 深拷贝通过JSON序列化实现深拷贝许多JavaScript框架都提出了自己的解决办法,但是Javascript应该采用那种方法作为标准呐? 在很长一段时间里,这个问题都没有明确的答案.对于JSON安全(也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象来说,有一种巧妙的复制方法: var newObj = JSON.parse(JSON.stringify(someObj)); 当然,这种方法需要保证对象是JSON安全的,所以只适用于部分情况. 你不知道的JavaScript(上) 该方法的局限性: 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 递归完成深拷贝1234567891011121314function deepCopy(obj)&#123; //判断是否是简单数据类型， if(typeof obj == &quot;object&quot;)&#123; //复杂数据类型 var result = obj.constructor == Array ? [] : &#123;&#125;; for(let i in obj)&#123; result[i] = typeof obj[i] == &quot;object&quot; ? deepCopy(obj[i]) : obj[i]; &#125; &#125;else &#123; //简单数据类型 直接 == 赋值 var result = obj; &#125; return result;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"Linux Shell >/dev/null 2>&1 &含义","slug":"Linux-Shell-dev-null-2-1-含义","date":"2019-04-01T10:04:28.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2019/04/01/Linux-Shell-dev-null-2-1-含义/","link":"","permalink":"https://www.silenceboy.com/2019/04/01/Linux-Shell-dev-null-2-1-含义/","excerpt":"","text":"shell中可能经常能看到：echo log &gt; /dev/null 2&gt;&amp;1 &amp;!, 但具体代表什么意思，很多人都不理解，下面对此进行一一讲解： &gt;: 代表重定向到哪里，例如：echo &quot;123&quot; &gt; /home/123.txt, 表示将字符串&#39;123&#39;写入文件/home/123.txt中, /dev/null: 代表空设备文件. %&gt;: 用来定义输出形式，其中&#39;%&#39;有几种可选值: 0: 标准输入 1: 表示stdout标准输出，系统默认值是1，所以&quot;&gt;/dev/null&quot;等同于&quot;1&gt;/dev/null“ 2: 表示stderr标准错误 &amp;: 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 所以&gt; /dev/null 2&gt;&amp;1可以分两步理解为: 1 &gt; /dev/null: 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1: 接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 最后一个&amp;! ， 是让该命令在后台执行，并且关闭终端后不退出。","categories":[{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/tags/shell/"}]},{"title":"[转]Node.js的模块-exports和module.exports","slug":"转-Node-js的模块-exports和module-exports","date":"2019-03-26T03:41:32.000Z","updated":"2021-09-27T07:27:40.449Z","comments":true,"path":"2019/03/26/转-Node-js的模块-exports和module-exports/","link":"","permalink":"https://www.silenceboy.com/2019/03/26/转-Node-js的模块-exports和module-exports/","excerpt":"","text":"原文链接： http://zhanglun.xyz/2014/04/26/%E8%AF%91-node-js%E7%9A%84%E6%A8%A1%E5%9D%97-exports-%E5%92%8C-module-exports/ exports 和 module.exports 有什么区别？你一定很熟悉 Node.js 模块中的用来在你的模块中创建函数的 exports 对象，就像下面这样。 创建一个叫做 rocker.js 的文件： 123exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 然后可以在另外一个文件中调用 rocker.js : 12var rocker = require(&apos;./rocker.js&apos;);rocker.name(); // &apos;My name is Lemmy Kilmister&apos; 但是，module.exports 到底什么？它是合法的吗？ 令人吃惊的是：module.exports 是真实存在的。exports 只不过是 module.exports 的帮手而已。你的模块直接返回返回 module.exports 给调用者，而不是 exports 。所有的 exports 做的工作实际上是收集属性，如果 module.exports 当前没有任何属性，exports便将收集到的属性添加到 module.exports 上。如果 module.exports已经存在若干属性，所以 exports 上的属性都会被忽略。 修改 rocker.js 文件： 1234module.exports = &apos;ROCK IT!&apos;;exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 在另一个文件中调用 rocker.js: 12var rocker = require(&apos;./rocker.js&apos;);rocker.name(); // TypeError: Object ROCK IT! has no method &apos;name&apos; 上述例子中的 rocker 模块完全将 exports.name 忽略了，只返回了一个 String 字符串：‘ROCK IT!’ 。 从这个例子你大概明白了：你的模块并不一定总是一个模块的实例(module instance)，它可以是任何合法的 JavaScript 对象——boolean, number, date, JSON, string, function, array 和其他的。你的模块可以是任何你设置的 module.exports 的值。如果你没有明确地为 module.exports 设置任何值，那么 exports 中的属性会自动添加到 module.exports 中，然后并返回它。 在这种情况下，你的模块是一个类： 1234567module.exports = function(name, age) &#123; this.name = name; this.age = age; this.about = function() &#123; console.log(this.name +&apos; is &apos;+ this.age +&apos; years old&apos;); &#125;;&#125;; 而你可以像这样使用： 123var Rocker = require(&apos;./rocker.js&apos;);var r = new Rocker(&apos;Ozzy&apos;, 62);r.about(); // Ozzy is 62 years old 在这时候你的模块是一个数组： 1234567module.exports = [ &apos;Lemmy Kilmister&apos;, &apos;Ozzy Osbourne&apos;, &apos;Ronnie James Dio&apos;, &apos;Steven Tyler&apos;, &apos;Mick Jagger&apos;]; 而你可以这样使用： 12var rocker = require(&apos;./rocker.js&apos;);console.log(&apos;Rockin in heaven: &apos; + rocker[2]); //Rockin in heaven: Ronnie James Dio 现在你应该明白了点什么：如果你想让你的模块返回一个特殊的对象类型，比如构造函数，那么你得使用 module.exports ；如果你只想模块作为一个典型的模块实例（module instance），那么就用exports。 把属性添加到 module.exports 中和添加到 exports 中的结果是一样的。比如像这样： 123module.exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 其实和下面的是一样的： 123exports.name = function() &#123; console.log(&apos;My name is Lemmy Kilmister&apos;);&#125;; 但是要注意，他们不是同一个东西。就像之前说的一样，exports 只不过是 module.exports 的帮手而已。话虽如此，exports还是推荐的对象，除非你想把你模块的对象类型从传统的模块实例（module instance）修改为其他的。 只要你没有使用赋值运算重写module.exports对象，任何添加到 module.exports和exports的属性都能够在 require模块中。 比如这是你的模块中的内容： 12module.exports.age = 68;exports.name = &apos;Lemmy Kilmister&apos;; 下面的代码可以很好的工作： 12var rocker = require(&apos;./rocker.js&apos;);console.log(&apos;%s is %s&apos;, rocker.name, rocker.age); // Lemmy Kilmister is 68 但是，如果你在你的模块中重写了module.exports中的任何地方，代码便会出错： 123module.exports = &apos;LOL&apos;;module.exports.age = 68;exports.name = &apos;Lemmy Kilmister&apos;; 或者这样： 123module.exports.age = 68;exports.name = &apos;Lemmy Kilmister&apos;;module.exports = &apos;WTF&apos;; 顺序没有关系，rocker.age 和 rocker.name 将显示为 undefined。 并且注意：只是因为 module.exports 和 exports 都能输出模块，并不意味这你可以组合使用。我的建议是，坚持使用 exports.*，明白module.exports 我希望这篇文章能帮助你理解exports和module.exports之间的不同，并且能进一步的理解模块在Node.js中是怎么工作的。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"关于LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443错误的两种解决方案","slug":"关于LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443错误的两种解决方案","date":"2019-03-23T04:54:30.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2019/03/23/关于LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443错误的两种解决方案/","link":"","permalink":"https://www.silenceboy.com/2019/03/23/关于LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443错误的两种解决方案/","excerpt":"","text":"错误来源使用使用hexo部署博客是，遇到以下错误: 123456fatal: unable to access &apos;https://github.com/silenceboychen/silenceboychen.github.io.git/&apos;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (/Users/chenhao/new_start/nodejs/blog/node_modules/hexo-util/lib/spawn.js:52:19) at ChildProcess.emit (events.js:182:13) at Process.ChildProcess._handle.onexit (internal/child_process.js:239:12) 两种解决方案：方案一取消http代理： 12$ git config --global --unset http.proxy$ git config --global --unset https.proxy 设置env GIT_SSL_NO_VERIFY为true然后再次部署： 1$ env GIT_SSL_NO_VERIFY=true hexo d 问题解决。 方案二在hexo项目的根目录下的_config.yml文件中把仓库链接地址由https修改为ssh的地址。","categories":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://www.silenceboy.com/tags/hexo/"}]},{"title":"统计指定目录里的代码行数","slug":"统计指定目录里的代码行数","date":"2019-03-21T01:34:04.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2019/03/21/统计指定目录里的代码行数/","link":"","permalink":"https://www.silenceboy.com/2019/03/21/统计指定目录里的代码行数/","excerpt":"","text":"codeLineCount一个用来统计项目内代码行数的工具. Installation1$ npm install -g code-rows-count or 1$ yarn global add code-rows-count Usage123456789$ codeLineCount -hUsage: codeLineCount [options]Options: -V, --version output the version number -p, --filePath [filePath] 文件路径 -i, --ignoreFile [ignoreFile] 忽略文件 -h, --help output usage information -p: 需要统计代码行数项目的绝对路径 -i: 不需要参与统计的项目内的文件名, 多个文件名使用逗号分割 example: 12345678910111213141516$ codeLineCount -p /home/silence/nodejs/test -i node_modules,yarn.lock,.git,package.json.lock文件路径:/home/silence/nodejs/test/color.js, 文件行数:19文件路径:/home/silence/nodejs/test/commander.js, 文件行数:14文件路径:/home/silence/nodejs/test/http.js, 文件行数:6文件路径:/home/silence/nodejs/test/package.json, 文件行数:6文件路径:/home/silence/nodejs/test/aaa/color.js, 文件行数:19------------------分割线start------------------done, 总耗时: 5 ms总文件数:5, 总代码行数: 64------------------分割线end------------------","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"express.js中间件说明","slug":"express-js中间件说明","date":"2019-03-19T01:39:06.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2019/03/19/express-js中间件说明/","link":"","permalink":"https://www.silenceboy.com/2019/03/19/express-js中间件说明/","excerpt":"","text":"express的新开发人员往往对路由处理程序和中间件之间的区别感到困惑。因此他们也对app.use(),app.all(),app.get(),app.post(),app.delete()和app.put()方法的区别感到困惑。 在本文中,我将解释中间件和路由处理程序之间的区别。以及如何正确使用app.use(),app.all(),app.get(),app.post(),app.delete()和app.put()方法。 路由处理app.use(),app.all(),app.get(),app.post(),app.delete()和app.put()全部是用来定义路由的。这些方法都用于定义路由。路由用于处理HTTP请求。路由是路径和回调的组合，在请求的路径匹配时执行。回调被称为路由处理程序。 它们之间的区别是处理不同类型的HTTP请求。例如： app.get()方法仅仅处理get请求，而app.all()处理GET、POST等请求。 下面是一个例子,如何定义一个路由： 1234567var app = require(&quot;express&quot;)();app.get(&quot;/&quot;, function(req, res, next)&#123; res.send(&quot;Hello World!!!!&quot;);&#125;);app.listen(8080); 每个路由处理程序都获得对当前正在提供的HTTP请求的请求和响应对象的引用。 可以为单个HTTP请求执行多个路由处理程序。这是一个例子： 12345678910111213var app = require(&quot;express&quot;)();app.get(&quot;/&quot;, function(req, res, next)&#123; res.write(&quot;Hello&quot;); next();&#125;);app.get(&quot;/&quot;, function(req, res, next)&#123; res.write(&quot; World !!!&quot;); res.end();&#125;);app.listen(8080); 这里第一个句柄写入一些响应，然后调用next()。 next()方法用于调用与路径路径匹配的下一个路由处理程序。 路由处理程序必须结束请求或调用下一个路由处理程序。 我们还可以将多个路由处理程序传递给app.all()，app.get()，app.post()，app.delete()和app.put()方法。 这是一个证明这一点的例子： 1234567891011var app = require(&quot;express&quot;)();app.get(&quot;/&quot;, function(req, res, next)&#123; res.write(&quot;Hello&quot;); next();&#125;, function(req, res, next)&#123; res.write(&quot; World !!!&quot;); res.end();&#125;);app.listen(8080); 中间件中间件是一个位于实际请求处理程序之上的回调。它采用与路由处理程序相同的参数。 要了解中间件，我们来看一个带有dashboard和profile页面的示例站点。要访问这些页面，用户必须登录。还会记录对这些页面的请求。 以下是这些页面的路由处理程序的代码： 1234567891011121314151617181920212223242526272829303132333435var app = require(&quot;express&quot;)();function checkLogin()&#123; return false;&#125;function logRequest()&#123; console.log(&quot;New request&quot;);&#125;app.get(&quot;/dashboard&quot;, function(req, res, next)&#123; logRequest(); if(checkLogin())&#123; res.send(&quot;This is the dashboard page&quot;); &#125; else&#123; res.send(&quot;You are not logged in!!!&quot;); &#125;&#125;);app.get(&quot;/profile&quot;, function(req, res, next)&#123; logRequest(); if(checkLogin())&#123; res.send(&quot;This is the dashboard page&quot;); &#125; else&#123; res.send(&quot;You are not logged in!!!&quot;); &#125;&#125;);app.listen(8080); 这里的问题是有很多重复的代码，即我们不得不多次使用logRequest()和checkLogin()函数。这也使得更新代码变得困难。因此，为了解决这个问题，我们可以为这两条路径编写一条通用路径。 这是重写的代码： 123456789101112131415161718192021222324252627282930313233var app = require(&quot;express&quot;)();function checkLogin()&#123; return false;&#125;function logRequest()&#123; console.log(&quot;New request&quot;);&#125;app.get(&quot;/*&quot;, function(req, res, next)&#123; logRequest(); next();&#125;)app.get(&quot;/*&quot;, function(req, res, next)&#123; if(checkLogin())&#123; next(); &#125; else&#123; res(&quot;You are not logged in!!!&quot;); &#125;&#125;)app.get(&quot;/dashboard&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.get(&quot;/profile&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.listen(8080); 这里的代码看起来更清晰，更易于维护和更新。这里将前两个定义的路由处理程序称为中间件，因为它们不处理请求，而是负责预处理请求。 Express为我们提供了app.use()方法，该方法专门用于定义中间件。 app.use()方法可能看起来与app.all()类似，但它们之间存在很多差异，这使得app.use()非常适合于声明中间件。让我们看看app.use()方法是如何工作的： app.use() 和 app.all() 的不同:CALLBACKapp.use()只需要一个回调，而app.all()可以进行多次回调。 PATHapp.use()只查看url是否以指定路径开头,app.all()匹配完整路径。 这里有一个例子来说明: 1234567891011121314app.use( &quot;/product&quot; , mymiddleware);// will match /product// will match /product/cool// will match /product/fooapp.all( &quot;/product&quot; , handler);// will match /product// won&apos;t match /product/cool &lt;-- important// won&apos;t match /product/foo &lt;-- importantapp.all( &quot;/product/*&quot; , handler);// won&apos;t match /product &lt;-- Important// will match /product/cool// will match /product/foo NEXT()中间件内的next()调用下一个中间件或路由处理程序，具体取决于接下来声明的那个。但是路由处理程序中的next()仅调用下一个路由处理程序。如果接下来有中间件，则跳过它。因此，必须在所有路由处理程序之前声明中间件。 这里有一个例子来说明: 1234567891011121314151617181920212223242526272829var express = require(&apos;express&apos;);var app = express();app.use(function frontControllerMiddlewareExecuted(req, res, next)&#123; console.log(&apos;(1) this frontControllerMiddlewareExecuted is executed&apos;); next();&#125;);app.all(&apos;*&apos;, function(req, res, next)&#123; console.log(&apos;(2) route middleware for all method and path pattern &quot;*&quot;, executed first and can do stuff before going next&apos;); next();&#125;);app.all(&apos;/hello&apos;, function(req, res, next)&#123; console.log(&apos;(3) route middleware for all method and path pattern &quot;/hello&quot;, executed second and can do stuff before going next&apos;); next();&#125;);app.use(function frontControllerMiddlewareNotExecuted(req, res, next)&#123; console.log(&apos;(4) this frontControllerMiddlewareNotExecuted is not executed&apos;); next();&#125;);app.get(&apos;/hello&apos;, function(req, res)&#123; console.log(&apos;(5) route middleware for method GET and path patter &quot;/hello&quot;, executed last and I do my stuff sending response&apos;); res.send(&apos;Hello World&apos;);&#125;);app.listen(80); 现在我们看到了app.use()方法的唯一性以及它用于声明中间件的原因。 让我们重写我们的示例站点代码： 12345678910111213141516171819202122232425262728293031323334var app = require(&quot;express&quot;)();function checkLogin()&#123; return false;&#125;function logRequest()&#123; console.log(&quot;New request&quot;);&#125;app.use(function(req, res, next)&#123; logRequest(); next();&#125;)app.use(function(req, res, next)&#123; if(checkLogin())&#123; next(); &#125; else&#123; res.send(&quot;You are not logged in!!!&quot;); &#125;&#125;)app.get(&quot;/dashboard&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.get(&quot;/profile&quot;, function(req, res, next)&#123; res.send(&quot;This is the dashboard page&quot;);&#125;);app.listen(8080);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"express.js","slug":"express-js","permalink":"https://www.silenceboy.com/tags/express-js/"},{"name":"middleware","slug":"middleware","permalink":"https://www.silenceboy.com/tags/middleware/"}]},{"title":"nodejs实现tail -f功能","slug":"nodejs实现tail-f功能","date":"2019-03-15T01:37:54.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2019/03/15/nodejs实现tail-f功能/","link":"","permalink":"https://www.silenceboy.com/2019/03/15/nodejs实现tail-f功能/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&apos;use strict&apos;;const fs = require(&apos;fs&apos;);/** * tailf * * @param &#123;String&#125; filename 文件名 * @param &#123;Number&#125; delay 读取不到内容时等待的时间，ms * @param &#123;Function&#125; onError 操作出错时的回调函数，onError(err) * @param &#123;Function&#125; onData 读取到文件内容时的回调函数，onData(data) */function tailf(filename, delay, onError, onData) &#123; // 每次读取文件块大小，16K const CHUNK_SIZE = 16 * 1024; // 打开文件，获取文件句柄 fs.open(filename, &apos;r&apos;, (err, fd) =&gt; &#123; if (err) return onError(err); // 文件开始位置 fs.fstat(fd, (err, stats) =&gt; &#123; if (err) return onError(err); // 文件开始位置 let position = stats.size; // 循环读取 const loop = () =&gt; &#123; const buf = Buffer.alloc(CHUNK_SIZE); fs.read(fd, buf, 0, CHUNK_SIZE, position, (err, bytesRead, buf) =&gt; &#123; if (err) return onError(err); // 实际读取的内容长度以 bytesRead 为准 // 并且更新 position 位置 position += bytesRead; onData(buf.slice(0, bytesRead)); if (bytesRead &lt; CHUNK_SIZE) &#123; // 如果当前已到达文件末尾，则先等待一段时间再继续 // setTimeout(loop, delay); &#125; else &#123; loop(); &#125; &#125;); &#125;; loop(); // 监听文件变化，如果收到 change 事件则尝试读取文件内容 fs.watch(filename, (event, filename) =&gt; &#123; if (event === &apos;change&apos;) &#123; loop(); &#125; &#125;); &#125;); &#125;);&#125;const filename = process.argv[2];if (filename) &#123; tailf(filename, 100, err =&gt; &#123; if (err) console.error(err); &#125;, data =&gt; &#123; process.stdout.write(data); &#125;);&#125; else &#123; console.log(&apos;使用方法： node tailf &lt;文件名&gt;&apos;);&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"tailf","slug":"tailf","permalink":"https://www.silenceboy.com/tags/tailf/"}]},{"title":"在docker中执行gitlab-runner","slug":"在docker中执行gitlab-runner","date":"2018-05-20T03:45:45.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2018/05/20/在docker中执行gitlab-runner/","link":"","permalink":"https://www.silenceboy.com/2018/05/20/在docker中执行gitlab-runner/","excerpt":"","text":"环境:ubuntu 16.04 LTS目的：使用Docker安装和配置GitLab Runner，搭建GitLab CI持续集成环境。 安装gitlab-runner1234$ docker run -d --name gitlab-runner --restart always \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 参数说明： -d: 设置容器后台运行 –name：容器名称 -restart always：每次启动容器就重启 gitlab-runner -v: 共享目录挂载 安装好后，执行$ docker ps 查看容器是否运行。 注册和初始化1$ docker exec -it gitlab-runner gitlab-ci-multi-runner register gitlab-runner register是进入gitlab-runner容器的执行命令，用于注册和初始化gitlab-runner。以下是我的配置：注意：docker image为满足你项目构建所需环境的镜像。 我们也可以编辑vim /srv/gitlab-runner/config/config.toml，手动修改配置：12345678910111213141516171819concurrent = 1check_interval = 0[[runners]] name = &quot;test&quot; url = &quot;https://xxxx.oooo.com&quot; token = &quot;3894a417b64744e942008bcc51123a&quot; executor = &quot;docker&quot; builds_dir = &quot;/gitlab/runner-builds&quot; cache_dir = &quot;/gitlab/runner-cache&quot; [runners.docker] tls_verify = false image = &quot;node:latest&quot; privileged = false disable_cache = false volumes = [&quot;/data/gitlab-runner:/gitlab&quot;] shm_size = 0 pull_policy = &quot;if-not-present&quot; [runners.cache] gitlab-ci token可以从gitlab上的项目的CI设置中获得。builds_dir 为文件存放位置volumes 挂载目录pull_policy 设置gitlab是否从远程拉去image,如果iamge是本地的需要配置该属性的值为: if-not-present 或者 never 创建.gitlab-ci.yml文件我的项目为nodejs项目，以下为测试配置。 1234567891011121314151617181920212223stages: - installcache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/job-install: stage: install script: - whoami - echo $SHELL - rm -rf node_modules/ - pwd - source ~/.bashrc - nvm use 8 - node -v - yarn only: - preview tags: - test 配置好gitlab-ci文件之后，提交修改，并将最新的修改推送到origin/preview分支，即可触发CI:123456789101112131415161718192021222324252627282930313233343536Running with gitlab-runner 10.2.0 (0a75cdd1) on test (3894a417)Using Docker executor with image followme/node:v1 ...Using docker image sha256:07e33b24b6a9bebc0e0d8ba24f15b4b3c0f6fcf321a3809371a6211ac1afc38e for predefined container...Using locally found image version due to if-not-present pull policyUsing docker image followme/node:v1 ID=sha256:c99c549e8227e2323d1cebb6f988d5d8f6de7f77e1967fe0f02878b85cb72b0f for build container...Running on runner-3894a417-project-643-concurrent-0 via 304e3efed168...Cloning repository...Cloning into &apos;/gitlab/runner-builds/3894a417/0/Frontend/api-member&apos;...Checking out 311e85cb as preview...Skipping Git submodules setupChecking cache for preview...Successfully extracted cache$ whoamiroot$ echo $SHELL/bin/bash$ rm -rf node_modules/$ pwd/gitlab/runner-builds/3894a417/0/Frontend/api-member$ source ~/.bashrc$ nvm use 8Now using node v8.3.0 (npm v5.3.0)$ node -vv8.3.0$ yarnyarn install v1.3.2[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...Done in 7.21s.Creating cache preview...node_modules/: found 5627 matching files Created cacheJob succeeded 注意：之前我是在Ubuntu14.04版本的系统上做这些配置，但是当执行CI的时候总会遇到以下报错:ERROR: Preparation failed: Error reading remote info: json: cannot unmarshal number into Go struct field Info.Debug of type bool 将系统升级为16.04后解决该问题","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"gitlab-runner","slug":"gitlab-runner","permalink":"https://www.silenceboy.com/tags/gitlab-runner/"}]},{"title":"mysql，sql server等数据库连接集成库","slug":"mysql，sql-server等数据库连接集成库","date":"2018-04-08T09:33:08.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2018/04/08/mysql，sql-server等数据库连接集成库/","link":"","permalink":"https://www.silenceboy.com/2018/04/08/mysql，sql-server等数据库连接集成库/","excerpt":"","text":"地址: https://github.com/fmfe/lib-sql Installation1$ npm install @fmfe/lib-sql or 1$ yarn add @fmfe/lib-sql Usage有两种传入配置信息的方式: 使用config来管理我们的配置文件.假设我们的项目目录下有一个config目录,config目录里有一个dev.json文件. config/dev.json 12345678910111213141516171819202122&#123; &quot;mysql&quot;: &#123; &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 3306, &quot;database&quot;: &quot;test&quot;, &quot;user&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot; &#125;, &quot;mssql&quot;: &#123; &quot;user&quot;: &quot;sa&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;server&quot;: &quot;127.0.0.1&quot;, &quot;database&quot;: &quot;test&quot;, &quot;port&quot;: 1433, &quot;pool&quot;: &#123; &quot;min&quot;: 0, &quot;max&quot;: 10, &quot;idleTimeoutMillis&quot;: 3000 &#125; &#125;&#125; mysql.js 12345678910111213141516171819202122232425262728293031const &#123; mysql &#125; = require(&apos;@fmfe/lib-sql&apos;);const mysqlPool = mysql.init();const _getNewSqlParamEntity = mysql._getNewSqlParamEntity;// 执行单条sql语句 // mysql.exec(mysqlPool, sql, params);async function exec() &#123; const sql1 = &apos;select * from ?? limit 2&apos;; const data = await mysql.exec(mysqlPool, sql1, [&apos;tbl_user&apos;]);&#125;// 执行mysql事务,可以传入多条增/删/改sql语句 // mysql.exectrans(mysqlpool, sqlParamsEntity);async function execTrans() &#123; const sqlParamsEntity = []; const sql1 = &apos;insert into ?? (name, age, sex) values (?, ?, ?)&apos;; const param1 = [&apos;tbl_user&apos;, &apos;aaa&apos;, 20, 1]; sqlParamsEntity.push(_getNewSqlParamEntity(sql1, param1)); const sql2 = &apos;insert into ?? (name, age, sex) values (?, ?, ?)&apos;; const param2 = [&apos;tbl_user&apos;, &apos;bbb&apos;, 22, 0]; sqlParamsEntity.push(_getNewSqlParamEntity(sql2, param2)); const sql3 = &apos;update ?? set age = ? where id = ?&apos;; const param3 = [&apos;tbl_user&apos;, 10, 1]; sqlParamsEntity.push(_getNewSqlParamEntity(sql3, param3)); // .... const data = await mysql.execTrans(mysqlPool, sqlParamsEntity); &#125; mssql.js 1234567891011121314151617181920212223const &#123; mssql &#125; = require(&apos;@fmfe/lib-sql&apos;);const _getNewSqlParamEntity = mssql._getNewSqlParamEntity;// 执行单条语句 // mssql.exec(sql)async function exec() &#123; const sql1 = &apos;select Top 3 name, age, sex from tbl_user order by age desc&apos;; const data = await mssql.exec(sql1); &#125;// 执行sql server 事务, 最好执行增/删/改语句,这里只是用select演示使用方法// mssql.exectrans(sqlParamsEntity); async function exectrans() &#123; const sqlParamsEntity = []; const sql1 = &apos;select * from tbl_user where id = 1&apos;; sqlParamsEntity.push(_getNewSqlParamEntity(sql1)); const sql2 = &apos;select * from tbl_user where id = 2&apos;; sqlParamsEntity.push(_getNewSqlParamEntity(sql2)); // ... const data = await mssql.execTrans(sqlParamsEntity); &#125; 由于使用config管理配置文件, 运行项目时通过使用命令: NODE_ENV=dev node ..., @fmfe/lib-sql即可自动获取到数据库相关配置. 通过传入配置文件来调用库我们引用上边的代码示例,只需做一点改动: mysql.js 只需在初始化时传入mysql数据库配置就好. 1234567891011const &#123; mysql &#125; = require(&apos;@fmfe/lib-sql&apos;);const mysqlPool = mysql.init(&#123; host: &apos;127.0.0.1&apos;, port: 3306, database: &apos;test&apos;, user: &apos;root&apos;, password: &apos;123456&apos;&#125;);...... mssql.js 在每次调用方法时传入配置 123456789101112131415161718192021222324const &#123; mssql &#125; = require(&apos;@fmfe/lib-sql&apos;);const config = &#123; user: &apos;sa&apos;, password: &apos;123456&apos;, server: &apos;127.0.0.1&apos;, database: &apos;test&apos;, port: 1433, pool: &#123; min: 0, max: 10, idleTimeoutMillis: 3000 &#125; &#125;async function exec() &#123; ...... const data = await mssql.exec(sql1, config); &#125;async function exectrans() &#123; ...... const data = await mssql.execTrans(sqlParamsEntity, config); &#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"sql server","slug":"sql-server","permalink":"https://www.silenceboy.com/tags/sql-server/"}]},{"title":"docker搭建私有仓库、自签发证书、登录认证","slug":"docker搭建私有仓库、自签发证书、登录认证","date":"2018-03-28T01:24:21.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2018/03/28/docker搭建私有仓库、自签发证书、登录认证/","link":"","permalink":"https://www.silenceboy.com/2018/03/28/docker搭建私有仓库、自签发证书、登录认证/","excerpt":"","text":"docker官方文档对如何搭建私有仓库说的已经很详细了，我在这里主要介绍一下使用自签发证书如何搭建私有仓库并认证成功。 假设registry的域名为：registry.domain.com。 生成自签发证书。12&gt; mkdir -p certs&gt; openssl req -newkey rsa:2048 -nodes -sha256 -keyout certs/domain.key -x509 -days 365 -out certs/domain.crt 执行以上命令，生成证书，Common Name那里要输入我们registry的域名，生成的证书只对该域名有效。其他的可以任意填。生成后可以在certs目录下查看到证书。 生成鉴权密码文件 注意使用时username替换为你自己的用户名，password替换为你自己的密码。123$ mkdir auth$ docker run --entrypoint htpasswd registry:2 -Bbn username password &gt; auth/htpasswd$ ls auth 启动Registry1234567891011docker run -d -p 5000:5000 --restart=always --name registry \\ -v `pwd`/auth:/auth \\ -e &quot;REGISTRY_AUTH=htpasswd&quot; \\ -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ -v `pwd`/data:/var/lib/registry \\ -v `pwd`/certs:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \\ -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \\ registry:2199ad0b3591fb9613b21b1c96f017267f3c39661a7025d30df636c6805e7ab50 如果没有registry镜像会自动下载然后启动，可以使用阿里云提供的加速器。现在完成了registry服务器的搭建，可以尝试pull image到registry：123$ docker pull busybox // 从官方拉去镜像作为我们的测试镜像$ docker tag busybox:latest registry.domain.com:5000/busybox:latest // 为busybox打tag,tag的前缀一定要为我们registry服务器的域名。$ docker push registry.domain.com:5000/busybox:latest // 将镜像推送到我们的registry服务器 如果直接这样去push，会失败，并且出现 no basic auth credentials的错误，这是因为我们没有进行登录认证。12345$ docker login registry.domain.com:5000$ Username: username$ Password: passwordWARNING: login credentials saved in ~/.docker/config.jsonLogin Succeeded 登录成功后再次执行push操作，会出现x509: certificate signed by unknown authority的报错。这是因为docker client认为server传输过来的证书的签署方是一个unknown authority（未知的CA），因此验证失败。我们需要让docker client安装我们的CA证书：123$ sudo mkdir -p /etc/docker/certs.d/registry.domain.com:5000$ sudo cp certs/domain.crt /etc/docker/certs.d/registry.domain.com:5000/ca.crt$ sudo service docker restart //安装证书后，重启Docker Daemon 再次执行push操作，成功推送：1234$ docker push registry.domain.com:5000/busybox:latestThe push refers to a repository [registry.domain.com:5000/busybox]0271b8eebde3: Pushedlatest: digest: sha256:3571ca1b0e90e159de4fc07b3bf94ef189a0645314704f629204adb7035ecf45 size: 527 这里需要注意：如果使用自签署的证书，那么所有要与Registry交互的Docker主机都需要安装registry.domain.com的ca.crt(domain.crt)。但如果你使用知名CA，这一步也就可以忽略。如果是MacOS版的docker也是一样的操作，尽管它连/etc/docker都不存在,一样去创建目录就好了。只是macOS的用户想要认证生效需要执行额外的命令：1$ sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /etc/docker/certs.d/registry.domain.com:5000/ca.crt 此时在mac上执行docker login才可成功。","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"}]},{"title":"容联云发送短信模块","slug":"容联云发送短信模块","date":"2018-01-28T01:22:30.000Z","updated":"2021-09-27T07:27:40.447Z","comments":true,"path":"2018/01/28/容联云发送短信模块/","link":"","permalink":"https://www.silenceboy.com/2018/01/28/容联云发送短信模块/","excerpt":"","text":"rongSMS一个nodejs实现的容联云发送短信模板模块（云联云官方没有提供nodejs实现的版本），支持node7.6以上版本。支持所有短信模板。一些常用的容联云返回码： code 含义 000000 发送成功 160038 短信验证码发送过频繁 160040 该手机号短信验证码发送次数超过当日限制 Installation1$ npm install rongsms or 1$ yarn add rongsms Usage12345678910111213141516const rongSms = require(&apos;rongSms&apos;);//生成验证码，在发送验证码是可以用来生成6位验证码。如果不是发送验证码可以不用。const code = rongSms.generate_code();//初始化//account_sid: 主账户sid，登陆云通讯网站后，可在控制台首页看到开发者主账号ACCOUNT SID//account_token： 主账户Token，登陆云通讯网站后，可在控制台首页看到开发者主账号AUTH TOKEN。//app_id: 请使用管理控制台中已创建应用的APPID。rongSms.init_sms(account_sid, account_token, app_id);//发送短信//phone:接受短信手机号//arr: 数组，对应短信模板中的替换内容。如短信模板为：您的验证码为&#123;1&#125;，请于&#123;2&#125;内正确输入，如非本人操作，请忽略此短信。arr取值为：[&apos;123456&apos;, &apos;10分钟&apos;]//template_id：模板idrongSms.send_sms(phone, arr, template_id);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/tags/npm/"},{"name":"sms","slug":"sms","permalink":"https://www.silenceboy.com/tags/sms/"}]},{"title":"搭建shadowsock服务器","slug":"搭建shadowsock服务器","date":"2018-01-19T01:37:28.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2018/01/19/搭建shadowsock服务器/","link":"","permalink":"https://www.silenceboy.com/2018/01/19/搭建shadowsock服务器/","excerpt":"","text":"安装Debian / Ubuntu: 12$ apt-get install python-pip$ pip install shadowsocks CentOS: 12$ yum install python-setuptools &amp;&amp; easy_install pip$ pip install shadowsocks 启动 有两种启动方式，建议使用配置文件的方式启动 直接启动： 1ssserver -p 8388 -k password -m rc4-md5 -d start 使用配置文件启动： 执行vim /etc/shadowsocks.json添加如下内容： 123456789&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;&#125; 多用户配置如下： 1234567891011121314&#123; &quot;server&quot;:&quot;0.0.0.0&quot;， &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;8388&quot;: &quot;password&quot;, &quot;8387&quot;: &quot;password&quot;, &quot;8386&quot;: &quot;password&quot;, &quot;8385&quot;: &quot;password&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;: false &#125; 然后通过执行一下命令启动： 如果要停止运行，将命令中的start改成stop。 1$ ssserver -c /etc/shadowsocks.json -d start TIPS: 加密方式推荐使用rc4-md5，因为 RC4 比 AES 速度快好几倍，如果用在路由器上会带来显著性能提升。旧的 RC4 加密之所以不安全是因为 Shadowsocks 在每个连接上重复使用 key，没有使用 IV。现在已经重新正确实现，可以放心使用。更多可以看 issue。 开机自启编辑一下/etc/supervisord.conf文件，命令如下： 1$ vim /etc/supervisord.conf 把下面的内容粘贴到文件尾部的空行处，然后保存： 1234567[program:shadowsocks]command=ssserver -c /etc/shadowsocks.jsonautostart=trueautorestart=trueuser=rootlog_stderr=truelogfile=/var/log/shadowsocks.log 接下来需要编辑一下/etc/rc.local文件，请执行以下命令： 1$ vi /etc/rc.local 请把以下内容粘贴到文件中部的空白处，然后保存 1$ service supervisord start 完成以上步骤后，重启之后，shadowsock会自动运行。 问题 如果通过客户端始终代理失败，可以通过一下方法查找问题。 1.客户端通过 telnet ip port 确认 ss-server 是否正常开启，如果没有正常开启，有可能是设定的端口没有开放， 1$ iptables -A INPUT -p tcp --dport 8388 -j ACCEPT 执行上述命令，将 8388 修改为你设定的端口即可。 2.如果第一步中连接正常，可以查看下 ss-server 的日志 1$ ssserver -c /etc/shadowsocks.json --log-file /var/log/shadowsocks.log -d start 启动的时候添加 --log-file 参数，然后通过 1$ tail -f /var/log/shadowsocks.log 查看实时日志，一般可以看出一点端倪。","categories":[{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/categories/shadowsock/"}],"tags":[{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/tags/shadowsock/"}]},{"title":"搭建指定版本node环境的docker镜像","slug":"搭建指定版本node环境的docker镜像","date":"2017-12-07T09:36:12.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2017/12/07/搭建指定版本node环境的docker镜像/","link":"","permalink":"https://www.silenceboy.com/2017/12/07/搭建指定版本node环境的docker镜像/","excerpt":"","text":"基于ubuntu16.04的docker镜像去打包安装了nodejs环境的docker镜像 前置条件1.获取ubuntu16.04镜像1# docker pull ubuntu:16.04 2.基于ubuntu16.04镜像启动容器1# docker run -ti --name ubuntu ubuntu:16.04 /bin/bash 从源代码安装Node.JS 安装node过程均在容器内进行 1.更新源并安装必要工具12# apt-get update# apt-get install git wget python gcc make g++ 2.获取指定版本的node源代码 这里我们使用v8.9.0版,目前为长期支持版,可以使用两中获取源码的方式.123# wget http://nodejs.org/dist/v8.9.0/node-v8.9.0.tar.gz# tar zxvf node-v8.9.0.tar.gz# mv node-v8.9.0 node or1# git clone -b v8.9.0 git@github.com:nodejs/node.git 3.修改目录权限1# chmod -R 755 node 4.编译安装node1234# cd node# ./configure# make# make install 5.查看node版本12# node --versionv8.9.0 安装完成后退出镜像 利用包管理器安装Node.JS 安装在镜像内进行 1.更新源并安装必要工具 setup_8.x为安装8.x版本,若安装9.x版本为:setup_9.x123# apt-get update# apt-get install curl# curl -sL https://deb.nodesource.com/setup_8.x | bash - 2.安装nodejs1# apt-get install -y nodejs 3.查看node版本12# node --versionv8.9.0 安装完成后退出镜像 从容器创建一个新的镜像 注意: 在上一步已经退出容器,下面的操作是在本机上进行的. 1.执行docker ps -a 查看name为ubuntu的ID 2.创建新的镜像12$ docker commit -a &quot;author&quot; -m &quot;commit message&quot; b0084b239645 xxx/node8.9:v1sha256:bc03d86ef63bab18deafe643f99b2aa1da5697860e1432102dbbcbb281fdf335 -a: 作者信息 -m: 提交信息 b0084b239645: docker ps -a中查看的ID xxx/node8.9:v1: 新的镜像名称 3.上传到镜像仓库 镜像制作完成可以将镜像上传到镜像仓库,便于以后使用,可以指定仓库地址,也可以使用官方的仓库.1$ docker push xxx/node8.9:v1","categories":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"使用Dockerfile部署nodejs服务","slug":"使用Dockerfile部署nodejs服务","date":"2017-12-04T09:49:49.000Z","updated":"2021-09-27T07:27:40.446Z","comments":true,"path":"2017/12/04/使用Dockerfile部署nodejs服务/","link":"","permalink":"https://www.silenceboy.com/2017/12/04/使用Dockerfile部署nodejs服务/","excerpt":"","text":"初始化Dockerfile假设我们的项目名为express,在express项目中创建编辑Dockerfile文件：123456789101112131415$ vim DockerfileFROM node:latestRUN mkdir -p /home/www/expressWORKDIR /home/www/expressCOPY . /home/www/expressRUN npm installEXPOSE 3000ENTRYPOINT [&quot;npm&quot;, &quot;run&quot;]CMD [&quot;start&quot;] 这个文件包含了以下命令： FROM node:latest - 指定使用最新版本的node基础镜像 RUN mkdir -p /home/www/express - 在容器内创建/home/www/express目录 WORKDIR /home/www/express - 将容器内工作目录设置为/home/www/express COPY . /home/www/express - 将宿主机当前目录下内容复制到镜像/home/www/express目录下 RUN npm install - npm install安装应用所需的NPM包 EXPOSE 3000 - 对外开放容器的3000端口 ENTRYPOINT [&quot;npm&quot;, &quot;run&quot;] - 容器启动后执行的命令。不可被docker run提供的参数覆盖 CMD [&quot;start&quot;] - 在容器启动时，执行的命令，可被docker run提供的参数覆盖 构建镜像编写完Dockerfile文件后，就可以通过docker build命令来构建镜像：1$ sudo docker build -t test/express . 我们通过-t参数，将镜像命名为test/express。构建过程类似如下：123456789101112131415161718192021222324252627282930313233343536Sending build context to Docker daemon 29.7 kBStep 1/8 : FROM registry.src.followme.com:5000/node:v1 ---&gt; c99c549e8227Step 2/8 : RUN mkdir -p /home/www/express-app ---&gt; Running in 8be9a90629b0 ---&gt; b9f584851225Removing intermediate container 8be9a90629b0Step 3/8 : WORKDIR /home/www/express-app ---&gt; 5072c31f9dd9Removing intermediate container e9dbf4ce3d8bStep 4/8 : COPY . /home/www/express-app ---&gt; a4d1725f15edRemoving intermediate container 30aa49765015Step 5/8 : RUN yarn ---&gt; Running in f181c243deaayarn install v1.3.2[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...Done in 9.46s. ---&gt; d390931d73e6Removing intermediate container f181c243deaaStep 6/8 : EXPOSE 3000 ---&gt; Running in 94101ab38864 ---&gt; 43199a8a5a90Removing intermediate container 94101ab38864Step 7/8 : ENTRYPOINT npm run ---&gt; Running in 80b1318962cf ---&gt; 6b203c50e855Removing intermediate container 80b1318962cfStep 8/8 : CMD start ---&gt; Running in a9909e537f59 ---&gt; d56eae48377cRemoving intermediate container a9909e537f59Successfully built d56eae48377c 运行容器镜像构建完成后，可以通过所构建的镜像创建/运行容器，从而实现express应用的 Docker 化部暑。 使用tets/express镜像运行一个容器：1$ sudo docker run -d --name experss-app -p 3000:3000 test/express 在以上操作中，我们通过test/express镜像运行了容器，并将容器命名为experss-app。运行容器，我们还指定了-d参数，该参数使容器以后台的方式运行。而-p参数将宿主机的3000端口映射到了容器的3000端口。运行容器后，可以通过docker ps命令看到运行中的容器。此时可通过localhost:3000访问服务。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://www.silenceboy.com/tags/dockerfile/"}]},{"title":"JavaScript数组随机排序","slug":"JavaScript数组随机排序","date":"2017-08-08T04:21:39.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2017/08/08/JavaScript数组随机排序/","link":"","permalink":"https://www.silenceboy.com/2017/08/08/JavaScript数组随机排序/","excerpt":"","text":"12345678910111213141516//不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。function randomSort(arr, newArr) &#123; var newArr = newArr || [] if (arr.length == 1) &#123; newArr.push(arr[0]) return newArr; // 相当于递归退出 &#125; var random = Math.ceil(Math.random() * arr.length) - 1 newArr.push(arr[random]) arr.splice(random, 1) return randomSort(arr, newArr)&#125;randomSort([1, 2, 3, 4, 5, 6, 7]); //[2, 3, 1, 5, 6, 7, 4]randomSort([1, 2, 3, 4, 5, 6, 7]); //[3, 4, 2, 5, 1, 6, 7]","categories":[{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"}]},{"title":"JavaScript按概率随机生成事件","slug":"JavaScript按概率随机生成事件","date":"2017-08-02T04:20:03.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2017/08/02/JavaScript按概率随机生成事件/","link":"","permalink":"https://www.silenceboy.com/2017/08/02/JavaScript按概率随机生成事件/","excerpt":"","text":"12345678910111213141516171819202122232425/**在抽奖的活动中经常会用到这个算法，不同奖项的获取概率不同，要按概率去随机生成对应的奖品**/function random(arr1, arr2) &#123; var sum = 0, factor = 0, random = Math.random(); for(var i = arr2.length - 1; i &gt;= 0; i--) &#123; sum += arr2[i]; // 统计概率总和 &#125;; random *= sum; // 生成概率随机数 for(var i = arr2.length - 1; i &gt;= 0; i--) &#123; factor += arr2[i]; if(random &lt;= factor) return arr1[i]; &#125;; return null;&#125;;// testvar a = [&apos;mac&apos;, &apos;iphone&apos;, &apos;vivo&apos;, &apos;OPPO&apos;];var b = [0.1, 0.2, 0.3, 0.4];console.log(random(a, b));","categories":[{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"}]},{"title":"node.js之base64编码解码","slug":"node-js之base64编码解码","date":"2016-09-16T04:15:18.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2016/09/16/node-js之base64编码解码/","link":"","permalink":"https://www.silenceboy.com/2016/09/16/node-js之base64编码解码/","excerpt":"","text":"利用buffer来进行编解码： 123456&gt; var a = new Buffer(&apos;key1=value1&amp;key2=value2&apos;).toString(&apos;base64&apos;);undefined&gt; a&apos;a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTI=&apos;&gt; new Buffer(a, &apos;base64&apos;).toString()&apos;key1=value1&amp;key2=value2&apos; 可以在终端中执行以下命令查看解码后的内容： 1echo a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTI= | base64 -D","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"base64","slug":"base64","permalink":"https://www.silenceboy.com/tags/base64/"}]},{"title":"JavaScript数组函数","slug":"JavaScript数组函数","date":"2016-08-25T01:54:30.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2016/08/25/JavaScript数组函数/","link":"","permalink":"https://www.silenceboy.com/2016/08/25/JavaScript数组函数/","excerpt":"","text":"下面总结了一些JavaScript中常用的数组操作方法。验证是不是数组用 arr instanceof Array 或者Array.isArray(arr)如果是返回truepush()在数组末尾添加并返回数组长度pop()移除数组的最后一项并返回移除的项shift()移除数组中的第一项并返回移除的项unshift()在数组前端添加任意个项并返回新的数组长度reverse()反转数组​join()将数组中的 值合并成字符串默认用,分割，可以自定义如join(‘|’);sort()升序排列数组，调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。可以接受一个比较函数作为参数如果对数值进行排序可以通过如下方法： 123456789101112function compare(value1,value2)&#123; //升序 ​if(value1&lt;value2)&#123; ​ ​return -1; ​&#125;else if(value1 &gt; value2)&#123; ​ ​return 1; ​&#125;else&#123; ​ ​return 0; ​&#125;&#125;var values=[0,1,5,10,15];values.sort(compare);console.log(values);//0,1,5,10,15 如需降序排列升序后使用reverse()即可concat()基于当前数组中的所有项创建一个新数组，如果传入参数，会将参数添加到数组的末尾slice()基于当前数组中的一或多个项创建一个新数组，接受一或两个参数，即要返回项的起始和结束位置，在只有一个参数的情况下返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。 splice(): 删除：删除任意数量的项，只需指定两个参数：要删除的第一项的位置和要删除的项数。例如splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项可以再传入第四、第五，任意多个项。 替换：可以向指定位置插入任意多个项，且同时删除任意数量的项，只需指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。 indexOf()和lastIndexOf()：这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()从前向后查找，lastIndexOf()从后向前查找，没找到的情况下返回-1","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"html5网页录音和语音识别","slug":"html5网页录音和语音识别","date":"2016-08-23T01:48:15.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2016/08/23/html5网页录音和语音识别/","link":"","permalink":"https://www.silenceboy.com/2016/08/23/html5网页录音和语音识别/","excerpt":"","text":"#背景 在输入方式上，人们总是在追寻一种更高效，门槛更低的方式，来降低用户使用产品的学习成本。语音输入也是一种尝试较多的方式，有些直接使用语音（如微信语音聊天），有些需要将语音转化为文字（语音识别）。接下来的内容是一次在pc浏览器上进行语音识别输入的一种尝试。 ### 实现 调研阶段，chrome是支持语音识别的。它支持了一系列的接口，可以进行语音识别。参考HTML5的Speech API相关标准的现状但是使用这些接口有一些困难，连不上服务器。此路不通。 那么，可以使用笨点儿的方法，先录音再上传到指定语音识别服务器，进行语音识别。这里使用的是百度语音开放平台的语音识别接口，支持8k,16k的单声道的wav文件，或者pcm。尝试了8k的识别效果，跟16k的差了好远。就使用了16k,单声道wav文件，上传到语音识别服务器。 关于录音，主要步骤就是使用navigator.getUserMedia来获取用户的输入设备，成功之后使用webkitAudioContext来创建音频实例。在录音结束之后，将录音的流导出为文件，上传即可。录音的可以参考这个recorder.js，只要稍微做一下修改就可以应用。其中需要处理音频采样率，默认的采样率为44.1k,这里需要做一个转换，具体方法可以参考HTML5网页录音和压缩,边猜边做 在浏览器扩展中，没有明确的方式去获取用户对录音的授权。可以在扩展的optionpage里面申请授权，之后在扩展的所有页面都有权限了。在较新的chrome浏览器里测过可以用。参考这里：How do I give webkitGetUserMedia permission in a Chrome Extension popup window #demo 这里有一个chrome扩展的demo，实现了通过语音采样，生成wav文件上传到语音识别服务器的功能。其中做了一个比较简单的端点检测，通过音量的大小来确定输入的完成。http://github.com/veizz/speech_io一些思考 demo其实是用来参与公司举办的一届hackathon比赛，主要实现了语音在线识别，文字播报等功能。在后期还有想法加入了一些自然语音处理的功能，可以识别一些输入指令。如『打开百度首页』、『上淘宝买衣服』等功能。会打开指定网站，自动填写输入词，执行搜索。还可以做一些小功能，比如说语音输入『查询天气』、『买电影票』等常用功能，在popup的窗口里面打开等。一切的想法都看起来很美好，但在大家都熟悉了打字输入的今天，还有多少人愿意使用语音识别做为输入方式？而对于不会打字的人，能否使用标准的普通话来进行语音识别的输入？ 采样率的处理是通过js的文件操作来实现的。html5支持的fileapi强大如此，怪不得有人用js做视频解码器，不考虑性能的话，看起来很美好啊 #参考 http://www.cnblogs.com/jz1108/archive/2012/05/21/2511447.htmlhttps://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.htmlhttp://codeartists.com/post/36746402258/how-to-record-audio-in-chrome-with-native-html5-apishttp://stackoverflow.com/questions/13076272/how-do-i-give-webkitgetusermedia-permission-in-a-chrome-extension-popup-windowhttp://www.cnblogs.com/blqw/p/3782420.htmlhttp://ibillxia.github.io/blog/2013/05/22/audio-signal-processing-time-domain-Voice-Activity-Detection/http://stackoverflow.com/questions/13333378/how-can-javascript-upload-a-blobhttp://www.web-tinker.com/article/20498.html","categories":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/categories/html5/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/tags/html5/"},{"name":"录音","slug":"录音","permalink":"https://www.silenceboy.com/tags/录音/"},{"name":"语言识别","slug":"语言识别","permalink":"https://www.silenceboy.com/tags/语言识别/"}]},{"title":"nodejs通过later实现定时执行任务","slug":"nodejs通过later实现定时执行任务","date":"2016-08-08T01:45:57.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2016/08/08/nodejs通过later实现定时执行任务/","link":"","permalink":"https://www.silenceboy.com/2016/08/08/nodejs通过later实现定时执行任务/","excerpt":"","text":"大多数情况我们都选用使用Linux的cron来控制定时执行的任务。当我们要维护多台计算机，几十个，几百个定时任务的时候，用cron会带来非常大的运维成本。可能写到程序中，就是一个不错的选择了。nodejs有一个later的插件可以简单实现该功能。如果已经安装过npm，可以直接执行npm install later安装该插件。如果没有请先安装npm。 12345678910111213141516var later = require(&apos;later&apos;);var basic = &#123;h:[00],m:[00]&#125;; //设置每天凌晨执行var composite=[ basic];var sched=&#123; schedules:composite&#125;;later.date.localTime(); //设置本地时区//var occurrences = later.schedule(sched).next(10);//for(var i=0;i&lt;10;i++)&#123;// console.log(occurrences[i]);//&#125;var t=later.setInterval(function()&#123; console.log(&quot;asdasd&quot;);&#125;,sched); 可根据自己的需求进行更改。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"MySQL查询表内重复记录","slug":"MySQL查询表内重复记录","date":"2016-08-04T02:02:52.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2016/08/04/MySQL查询表内重复记录/","link":"","permalink":"https://www.silenceboy.com/2016/08/04/MySQL查询表内重复记录/","excerpt":"","text":"1、查找表中多余的重复记录，重复记录是根据单个字段（user_id）来判断 1select * from tbl_user where user_id in (select user_id from people group by user_id having count(user_id) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（user_id）来判断，只留有一个记录 1delete from tbl_user where user_id in (select user_id from people group by user_id having count(user_id) &gt; 1) and min(id) not in (select id from people group by user_id having count(user_id)&gt;1) 3、查找表中多余的重复记录（多个字段） 1select * from table where (user_id,lesson_id) in (select user_id,lesson_id from table group by user_id,lesson_id having count(*) &gt; 1) 4、删除表中多余的重复记录（多个字段），只留有id最小的记录 1delete from table where (user_id,lesson_id) in (select user_id,lesson_id from table group by user_id,lesson_id having count(*) &gt; 1) and id not in (select min(id) from table group by user_id,lesson_id having count(*)&gt;1) 5、查找表中多余的重复记录（多个字段），不包含id最小的记录 1select * from table where (user_id,lesson_id) in (select user_id,lesson_id from table group by user_id,lesson_id having count(*) &gt; 1) and id not in (select min(id) from table group by user_id,lesson_id having count(*)&gt;1)","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"}]},{"title":"服务器时区问题","slug":"服务器时区问题","date":"2016-08-04T01:42:46.000Z","updated":"2021-09-27T07:27:40.448Z","comments":true,"path":"2016/08/04/服务器时区问题/","link":"","permalink":"https://www.silenceboy.com/2016/08/04/服务器时区问题/","excerpt":"","text":"进入测试发现对应的时间不对，查了一下服务器的时间，发现服务器的时区为世界标准时间，简称UTC不属于任意时区，UTC时区默认比北京时间少8个小时。查看服务器时间： 这是服务器上的时区。中国的时区应该为CST。那么如何修改服务器时区为中国时区呐，很简单。 1cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 执行该命令，之后再查看时间： 现在的时间即为正确的中国时间。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"}]},{"title":"JavaScript获取时间戳与时间戳转化","slug":"JavaScript获取时间戳与时间戳转化","date":"2016-08-03T01:57:19.000Z","updated":"2021-09-27T07:27:40.436Z","comments":true,"path":"2016/08/03/JavaScript获取时间戳与时间戳转化/","link":"","permalink":"https://www.silenceboy.com/2016/08/03/JavaScript获取时间戳与时间戳转化/","excerpt":"","text":"Javascript 获取当前时间戳（毫秒级别）： 第一种方法： 1var timestamp1 = Date.parse( new Date()); 结果：1470220594000 第二种方法： 1var timestamp2 = ( new Date()).valueOf(); 结果：1470220608533 第三种方法： 1var timestamp3 = new Date().getTime(); 结果：1470220608533 第一种获取的时间戳是精确到秒，第二种和第三种是获取的时间戳精确到毫秒。 获取指定时间的时间戳：1new Date(&quot;2016-08-03 00:00:00&quot;).getTime; 时间戳转化成时间：12345678910function timetrans(date)&#123; var date = new Date(date*1000);//如果date为13位不需要乘1000 var Y = date.getFullYear() + &apos;-&apos;; var M = (date.getMonth()+1 &lt; 10 ? &apos;0&apos;+(date.getMonth()+1) : date.getMonth()+1) + &apos;-&apos;; var D = (date.getDate() &lt; 10 ? &apos;0&apos; + (date.getDate()) : date.getDate()) + &apos; &apos;; var h = (date.getHours() &lt; 10 ? &apos;0&apos; + date.getHours() : date.getHours()) + &apos;:&apos;; var m = (date.getMinutes() &lt;10 ? &apos;0&apos; + date.getMinutes() : date.getMinutes()) + &apos;:&apos;; var s = (date.getSeconds() &lt;10 ? &apos;0&apos; + date.getSeconds() : date.getSeconds()); return Y+M+D+h+m+s;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"js利用clipboardData在网页中实现截屏粘贴的功能","slug":"js利用clipboardData在网页中实现截屏粘贴的功能","date":"2016-07-23T01:54:44.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2016/07/23/js利用clipboardData在网页中实现截屏粘贴的功能/","link":"","permalink":"https://www.silenceboy.com/2016/07/23/js利用clipboardData在网页中实现截屏粘贴的功能/","excerpt":"","text":"最近在做一个将屏幕截图直接粘贴发送的功能，于是对此做了一些研究，下面是具体的实现代码：html代码如下，在这里只是简单的做了一个textare框用作演示 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt;截屏粘贴&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea onpaste =&quot;paste()&quot;&gt; &lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt; 具体实现在JavaScript中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function paste(event)&#123; var clipboardData = event.clipboardData; console.log(clipboardData); var items,item,types; if( clipboardData )&#123; items = clipboardData.items; if( !items )&#123; return; &#125; // 保存在剪贴板中的数据类型 types = clipboardData.types || []; for(var i=0 ; i &lt; types.length; i++ )&#123; if( types[i] === &apos;Files&apos; )&#123; item = items[i]; break; &#125; &#125; // 判断是否为图片数据 if( item &amp;&amp; item.kind === &apos;file&apos; &amp;&amp; item.type.match(/^image\\//i) )&#123; // 读取该图片 var file = item.getAsFile(), reader = new FileReader(); reader.readAsDataURL(file); console.log(reader); //下面是讲粘贴的图片内容传送到后端进行处理，如果直接前端处理可以不要后边的代码 var xhr = new XMLHttpRequest(); xhr.open(&apos;post&apos;, &apos;/pasteImage&apos;,true); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); reader.onload = function()&#123; console.log(reader.result); xhr.send(JSON.stringify(&#123; file: reader.result &#125;)); &#125;; //接收返回数据 xhr.onload = function()&#123; var response = JSON.parse(xhr.responseText); if(response.code == 200)&#123; // &#125;else&#123; // &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"JSON.stringify 函数参数分析","slug":"JSON-stringify-函数参数分析","date":"2016-07-16T01:50:57.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2016/07/16/JSON-stringify-函数参数分析/","link":"","permalink":"https://www.silenceboy.com/2016/07/16/JSON-stringify-函数参数分析/","excerpt":"","text":"JSON.stringify是将 JavaScript 值转换为 JavaScript 对象表示法 。语法为：JSON.stringify(value [, replacer] [, space])很多人都只会用到第一个参数，所以导致很多人不知道后两个参数是什么意思，下面对三个参数进行分析： value必需。 要转换的 JavaScript 值（通常为对象或数组）。 replacer可选。 用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。 使用返回值而不是原始值。 如果此函数返回 undefined，则排除成员。 根对象的键是一个空字符串：””。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。 成员的转换顺序与键在数组中的顺序一样。 当 value 参数也为数组时，将忽略 replacer 数组。 space可选。 向返回值 JSON 文本添加缩进、空格和换行符以使其更易于读取。如果省略 space，则将生成返回值文本，而没有任何额外空格。如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格。 如果 space 大于 10，则文本缩进 10 个空格。如果 space 是一个非空字符串（例如“t”），则返回值文本在每个级别中缩进字符串中的字符。如果 space 是长度大于 10 个字符的字符串，则使用前 10 个字符。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"nodejs读写excel内容","slug":"nodejs读写excel内容","date":"2016-07-16T01:47:27.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2016/07/16/nodejs读写excel内容/","link":"","permalink":"https://www.silenceboy.com/2016/07/16/nodejs读写excel内容/","excerpt":"","text":"支持读写Excel的node.js模块 node-xlsx: 基于Node.js解析excel文件数据及生成excel文件，仅支持xlsx格式文件； excel-parser: 基于Node.js解析excel文件数据，支持xls及xlsx格式文件； excel-export : 基于Node.js将数据生成导出excel文件，生成文件格式为xlsx； node-xlrd: 基于node.js从excel文件中提取数据，仅支持xls格式文件。 我将展示通过node-xlsx提取上传上来的excel文件里的数据，以及生成新的excel文件。代码如下： 12345678910111213141516171819202122232425var xlsx = require(&apos;node-xlsx&apos;);var fs = require(&apos;fs&apos;);//读取文件内容var obj = xlsx.parse(__dirname+&apos;/test.xlsx&apos;);var excelObj=obj[0].data;console.log(excelObj);var data = [];for(var i in excelObj)&#123; var arr=[]; var value=excelObj[i]; for(var j in value)&#123; arr.push(value[j]); &#125; data.push(arr);&#125;var buffer = xlsx.build([ &#123; name:&apos;sheet1&apos;, data:data &#125; ]);//将文件内容插入新的文件中fs.writeFileSync(&apos;test1.xlsx&apos;,buffer,&#123;&apos;flag&apos;:&apos;w&apos;&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"excel","slug":"excel","permalink":"https://www.silenceboy.com/tags/excel/"}]},{"title":"web聊天系统的消息通知问题","slug":"web聊天系统的消息通知问题","date":"2016-07-06T06:42:58.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2016/07/06/web聊天系统的消息通知问题/","link":"","permalink":"https://www.silenceboy.com/2016/07/06/web聊天系统的消息通知问题/","excerpt":"","text":"web消息提示无非三种方式：声音提示，桌面弹窗和title闪烁提醒。下面做一一介绍。 声音提示注意声音提示前提示已经加载了声音文件，有文章写的很多是临时create一个audio对象，然后audio.src,这样做是非常不好的，因为你每次调用声音的时候都会去后台请求一下这个声音文件。所以先加载出来是最好的方法。 &lt;audio id=&quot;chat-audio&quot; src=&quot;audio/system.wav&quot; display=&quot;none&quot;&gt;&lt;/audio&gt; function playAudio() { document.getElementById(&apos;chat-audio&apos;).play(); //pause()方法也可以暂停，具体可查html5的audio标签 } //调用方式 playAudio(); 桌面弹窗function palyDeskNotice(theTitle, options) { if (Notification.permission !== &quot;granted&quot;) { //先判断一下用户是否已经开启了桌面提示的权限，如果没有则提醒用户开启 window.Notification.requestPermission(function(permission) { if (permission === &quot;granted&quot;) showNotice(theTitle, options); }); } else { showNotice(theTitle, options); } } function showNotice(theTitle, options) { //这个就是桌面弹窗 var desknotice = new Notification(theTitle, options); desknotice.onclick = function() { //当用户点击弹窗的时候，要定位到聊天窗口 window.focus(); desknotice.close(); }; //页面退出时关闭提醒 window.onbeforeunload = function() { desknotice.close(); } //弹窗3秒后自动消失 setTimeout(desknotice.close.bind(desknotice), 3000); } //调用方式 palyDeskNotice(&apos;来自xxx&apos;, { body: &apos;内容&apos;, icon: &quot;images/xxx.jpg&quot; }); title闪烁提醒的原理var NewMsgNoticeflag = false,//闪烁标识 newMsgNotinceTimer = null; function newMsgCount() { if (NewMsgNoticeflag) { NewMsgNoticeflag = false; document.title = &apos;【☏新消息】您有新的即时消息&apos;; } else { NewMsgNoticeflag = true; document.title = &apos;【 】您有新的即时消息&apos;; } } //兼容性 var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; : &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; : &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; : null; var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;); var onVisibilityChange = function() { if (!document[hiddenProperty]) { clearInterval(newMsgNotinceTimer); newMsgNotinceTimer = null; document.title = &apos;beta-即时消息系统&apos;; //窗口没有消息的时候默认的title内容 } } document.addEventListener(visibilityChangeEvent, onVisibilityChange); //调用方式 if (!newMsgNotinceTimer) newMsgNotinceTimer = setInterval(&quot;newMsgCount()&quot;, 200);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"JavaScript让时间显示为多久以前","slug":"JavaScript让时间显示为多久以前","date":"2016-06-02T06:41:28.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2016/06/02/JavaScript让时间显示为多久以前/","link":"","permalink":"https://www.silenceboy.com/2016/06/02/JavaScript让时间显示为多久以前/","excerpt":"","text":"在做论坛的功能时，要求帖子的发帖时间显示几秒前，几分钟前，几小时前。。。这种功能，于是就把获取到的发帖时间做了如下处理： 12345678910111213141516171819function gettime(createtime)&#123; var now=Date.parse(new Date())/1000; var limit=now-createtime; var content=&quot;&quot;; if(limit&lt;60)&#123; content=&quot;刚刚&quot;; &#125;else if(limit&gt;=60 &amp;&amp; limit&lt;3600)&#123; content=Math.floor(limit/60)+&quot;分钟前&quot;; &#125;else if(limit&gt;=3600 &amp;&amp; limit&lt;86400)&#123; content=Math.floor(limit/3600)+&quot;小时前&quot;; &#125;else if(limit&gt;=86400 &amp;&amp; limit&lt;2592000)&#123; content=Math.floor(limit/86400)+&quot;天前&quot;; &#125;else if(limit&gt;=2592000 &amp;&amp; limit&lt;31104000)&#123; content=Math.floor(limit/2592000)+&quot;个月前&quot;; &#125;else&#123; content=&quot;很久前&quot;; &#125; return content;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"express如何解决request entity too large问题","slug":"express如何解决request-entity-too-large问题","date":"2016-05-30T03:21:33.000Z","updated":"2021-09-27T07:27:40.439Z","comments":true,"path":"2016/05/30/express如何解决request-entity-too-large问题/","link":"","permalink":"https://www.silenceboy.com/2016/05/30/express如何解决request-entity-too-large问题/","excerpt":"","text":"通过js向后台post一些文件信息时，会出现如下图所示的错误。这是express框架的问题，默认的很小，可以通过设置：app.use(express.json({limit: ‘5mb’}));解决该问题。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"Nodejs接收图片base64格式保存为文件","slug":"Nodejs接收图片base64格式保存为文件","date":"2016-05-27T03:19:30.000Z","updated":"2021-09-27T07:27:40.437Z","comments":true,"path":"2016/05/27/Nodejs接收图片base64格式保存为文件/","link":"","permalink":"https://www.silenceboy.com/2016/05/27/Nodejs接收图片base64格式保存为文件/","excerpt":"","text":"base64的形式为“data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0。。。。”；当接收到上边的内容后，需要将data:image/png;base64,这段内容过滤掉，过滤成：“iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0。。。”；然后进行保存。 1234567891011121314app.post(&apos;/upload&apos;, function(req, res)&#123; //接收前台POST过来的base64 var imgData = req.body.imgData; //过滤data:URL var base64Data = imgData.replace(/^data:image\\/\\w+;base64,/, &quot;&quot;); var dataBuffer = new Buffer(base64Data, &apos;base64&apos;); fs.writeFile(&quot;image.png&quot;, dataBuffer, function(err) &#123; if(err)&#123; res.send(err); &#125;else&#123; res.send(&quot;保存成功！&quot;); &#125; &#125;);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"base64","slug":"base64","permalink":"https://www.silenceboy.com/tags/base64/"}]},{"title":"javascript在网页中实现粘贴qq截图功能","slug":"javascript在网页中实现粘贴qq截图功能","date":"2016-05-27T01:41:34.000Z","updated":"2021-09-27T07:27:40.441Z","comments":true,"path":"2016/05/27/javascript在网页中实现粘贴qq截图功能/","link":"","permalink":"https://www.silenceboy.com/2016/05/27/javascript在网页中实现粘贴qq截图功能/","excerpt":"","text":"这篇文章主要介绍了在网页中实现读取剪贴板粘贴截图功能,即可以把剪贴板的截图Ctrl+V粘贴到网页的一个输入框中,例如QQ截图、旺旺截图或者其它截图软件。具体代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE HTML&gt;&lt;html lang=&quot;en-US&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;利用 clipboardData 在网页中实现截屏粘贴的功能&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#box&#123; width:200px; height:200px; border:1px solid #ddd; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;利用 clipboardData 在网页中实现截屏粘贴的功能&lt;/h1&gt; &lt;hr /&gt;&lt;div&gt;&lt;input type=&quot;text&quot; id=&quot;testInput&quot; placeholder=&quot;截屏后粘贴到输入框中&quot; size=&quot;30&quot; /&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;(function()&#123; var imgReader = function( item )&#123; var blob = item.getAsFile(), reader = new FileReader(); // 读取文件后将其显示在网页中 reader.onload = function( e )&#123; var img = new Image(); img.src = e.target.result; document.body.appendChild( img ); &#125;; // 读取文件 reader.readAsDataURL( blob ); &#125;; document.getElementById( &apos;testInput&apos; ).addEventListener( &apos;paste&apos;, function( e )&#123; // 添加到事件对象中的访问系统剪贴板的接口 var clipboardData = e.clipboardData, i = 0, items, item, types; if( clipboardData )&#123; items = clipboardData.items; if( !items )&#123; return; &#125; item = items[0]; // 保存在剪贴板中的数据类型 types = clipboardData.types || []; for( ; i &lt; types.length; i++ )&#123; if( types[i] === &apos;Files&apos; )&#123; item = items[i]; break; &#125; &#125; // 判断是否为图片数据 if( item &amp;&amp; item.kind === &apos;file&apos; &amp;&amp; item.type.match(/^image\\//i) )&#123; imgReader( item ); &#125; &#125; &#125;);&#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"}]},{"title":"js获取内容中的url链接，并设置a标签","slug":"js获取内容中的url链接，并设置a标签","date":"2016-05-24T01:39:27.000Z","updated":"2021-09-27T07:27:40.442Z","comments":true,"path":"2016/05/24/js获取内容中的url链接，并设置a标签/","link":"","permalink":"https://www.silenceboy.com/2016/05/24/js获取内容中的url链接，并设置a标签/","excerpt":"","text":"12345var regexp = /(http:\\/\\/|https:\\/\\/)((\\w|=|\\?|\\.|\\/|\\&amp;|-)+)/g;content = content.replace(regexp, function($url)&#123; return &quot;&lt;a href=&apos;&quot; + $url + &quot;&apos; target=&apos;_blank&apos;&gt;&quot; + $url + &quot;&lt;/a&gt;&quot;;&#125;);console.log(content);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.silenceboy.com/tags/正则表达式/"}]},{"title":"vi/vim多行注释和取消注释","slug":"vi-vim多行注释和取消注释","date":"2016-05-21T01:37:05.000Z","updated":"2021-09-27T07:27:40.445Z","comments":true,"path":"2016/05/21/vi-vim多行注释和取消注释/","link":"","permalink":"https://www.silenceboy.com/2016/05/21/vi-vim多行注释和取消注释/","excerpt":"","text":"多行注释： 进入命令行模式，按ctrl + v进入 visual block模式（可视快模式），然后按j, 或者k选中多行，把需要注释的行标记起来 按大写字母I，再插入注释符，例如// 按esc键就会全部注释了（我的是按两下） 取消多行注释： 进入命令行模式，按ctrl + v进入 visual block模式（可视快模式），按小写字母l横向选中列的个数，例如 // 需要选中2列 按字母j，或者k选中注释符号 按d键就可全部取消注释","categories":[{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/tags/vim/"},{"name":"vi","slug":"vi","permalink":"https://www.silenceboy.com/tags/vi/"}]},{"title":"nodejs如何获取form表单post方法提交的数据","slug":"nodejs如何获取form表单post方法提交的数据","date":"2016-05-18T05:41:40.000Z","updated":"2021-09-27T07:27:40.443Z","comments":true,"path":"2016/05/18/nodejs如何获取form表单post方法提交的数据/","link":"","permalink":"https://www.silenceboy.com/2016/05/18/nodejs如何获取form表单post方法提交的数据/","excerpt":"","text":"首先通过：npm install formidable安装所需的包。下面给出一个测试的例子： 12345678910111213141516171819202122232425262728var formidable = require(&apos;formidable&apos;), http = require(&apos;http&apos;), util = require(&apos;util&apos;);http.createServer(function(req, res) &#123; if (req.url == &apos;/upload&apos; &amp;&amp; req.method.toLowerCase() == &apos;post&apos;) &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/plain&apos;&#125;); res.write(&apos;received upload:\\n\\n&apos;); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; // show a file upload form res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/html&apos;&#125;); res.end( &apos;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;&apos;+ &apos;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;br&gt;&apos;+ &apos;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&lt;br&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&apos;+ &apos;&lt;/form&gt;&apos; );&#125;).listen(8080); 通过formidable可以成功获取表单 提交的内容。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"}]},{"title":"连接Buffer对象的正确方法","slug":"连接Buffer对象的正确方法","date":"2016-04-12T05:39:41.000Z","updated":"2021-09-27T07:27:40.449Z","comments":true,"path":"2016/04/12/连接Buffer对象的正确方法/","link":"","permalink":"https://www.silenceboy.com/2016/04/12/连接Buffer对象的正确方法/","excerpt":"","text":"1234567891011121314151617181920212223var buffers = [];var nread = 0;readStream.on(&apos;data&apos;, function (chunk) &#123; buffers.push(chunk); nread += chunk.length;&#125;);readStream.on(&apos;end&apos;, function () &#123; var buffer = null; switch(buffers.length) &#123; case 0: buffer = new Buffer(0); break; case 1: buffer = buffers[0]; break; default: buffer = new Buffer(nread); for (var i = 0, pos = 0, l = buffers.length; i &lt; l; i++) &#123; var chunk = buffers[i]; chunk.copy(buffer, pos); pos += chunk.length; &#125; break; &#125;&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"buffer","slug":"buffer","permalink":"https://www.silenceboy.com/tags/buffer/"}]},{"title":"html5 实现网页截屏 页面生成图片","slug":"html5-实现网页截屏-页面生成图片","date":"2016-03-21T05:37:41.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2016/03/21/html5-实现网页截屏-页面生成图片/","link":"","permalink":"https://www.silenceboy.com/2016/03/21/html5-实现网页截屏-页面生成图片/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;layout&quot; content=&quot;main&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://html2canvas.hertzen.com/build/html2canvas.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready( function()&#123; $(&quot;.example1&quot;).on(&quot;click&quot;, function(event) &#123; event.preventDefault(); html2canvas(document.body, &#123; allowTaint: true, taintTest: false, onrendered: function(canvas) &#123; canvas.id = &quot;mycanvas&quot;; //document.body.appendChild(canvas); //生成base64图片数据 var dataUrl = canvas.toDataURL(); var newImg = document.createElement(&quot;img&quot;); newImg.src = dataUrl; document.body.appendChild(newImg); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello! &lt;div class=&quot;&quot; style=&quot;background-color: #abc;&quot;&gt; html5页面截图 &lt;/div&gt; &lt;textArea id=&quot;textArea&quot; col=&quot;20&quot; rows=&quot;10&quot; &gt;&lt;/textArea&gt; &lt;input class=&quot;example1&quot; type=&quot;button&quot; value=&quot;截图&quot;&gt; 生成界面如下： &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/categories/html5/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/tags/html5/"}]},{"title":"php根据IP地址获取地理位置","slug":"php根据IP地址获取地理位置","date":"2016-01-24T14:35:15.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2016/01/24/php根据IP地址获取地理位置/","link":"","permalink":"https://www.silenceboy.com/2016/01/24/php根据IP地址获取地理位置/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpheader(&quot;Content-type: text/html; charset=utf-8&quot;); //获取IP地址的方法function getIP()&#123; if (isset($_SERVER)) &#123; if (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; &#125; elseif (isset($_SERVER[&apos;HTTP_CLIENT_IP&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_CLIENT_IP&apos;]; &#125; else &#123; $realip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; &#125; else &#123; if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;)) &#123; $realip = getenv( &quot;HTTP_X_FORWARDED_FOR&quot;); &#125; elseif (getenv(&quot;HTTP_CLIENT_IP&quot;)) &#123; $realip = getenv(&quot;HTTP_CLIENT_IP&quot;); &#125; else &#123; $realip = getenv(&quot;REMOTE_ADDR&quot;); &#125; &#125; return $realip;&#125;echo $ip = getIP();//通过php的file_get_contents()方法获取地理位置//新浪接口根据ip查询所在区域信息$res0 = file_get_contents(&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&quot;);$res0 = json_decode($res0,true);print_r($res0);echo &quot;&lt;br/&gt;&quot;;//淘宝接口根据ip查询所在区域信息$res1 = file_get_contents(&quot;http://ip.taobao.com/service/getIpInfo.php?ip=$ip&quot;);$res1 = json_decode($res1,true);print_r($res1);echo &quot;&lt;br/&gt;&quot;;//通过php的curl获取地理位置//新浪根据IP获取地理位置API$url = &apos;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&apos;; $ch = curl_init($url); curl_setopt($ch,CURLOPT_ENCODING ,&apos;utf8&apos;); curl_setopt($ch, CURLOPT_TIMEOUT, 10); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true) ; // 获取数据返回 $location = curl_exec($ch); $location = json_decode($location); print_r($location);curl_close($ch); $loc = &quot;&quot;; if($location===FALSE) return &quot;&quot;; if (empty($location-&gt;desc)) &#123; $loc = $location-&gt;province.$location-&gt;city.$location-&gt;district.$location-&gt;isp; &#125;else&#123; $loc = $location-&gt;desc; &#125; echo $loc; //腾讯根据IP获取地理位置API$url = &apos;http://ip.qq.com/cgi-bin/searchip?searchip1=$ip&apos;; $ch = curl_init($url); curl_setopt($ch,CURLOPT_ENCODING ,&apos;gb2312&apos;); curl_setopt($ch, CURLOPT_TIMEOUT, 10); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true) ; // 获取数据返回 $result = curl_exec($ch); $result = mb_convert_encoding($result, &quot;utf-8&quot;, &quot;gb2312&quot;); // 编码转换，否则乱码 curl_close($ch); preg_match(&quot;@&lt;span&gt;(.*)&lt;/span&gt;&lt;/p&gt;@iU&quot;,$result,$ipArray); $loc = $ipArray[1]; echo $loc;","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"}]},{"title":"express简单测试连接mysql","slug":"express简单测试连接mysql","date":"2016-01-06T14:11:16.000Z","updated":"2021-09-27T07:27:40.440Z","comments":true,"path":"2016/01/06/express简单测试连接mysql/","link":"","permalink":"https://www.silenceboy.com/2016/01/06/express简单测试连接mysql/","excerpt":"","text":"使用express应用生成器生成express模板后，先写package.json { &quot;name&quot;: &quot;mysql-test&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;start&quot;: &quot;node ./bin/www&quot; }, &quot;dependencies&quot;: { &quot;body-parser&quot;: &quot;~1.13.2&quot;, &quot;cookie-parser&quot;: &quot;~1.3.5&quot;, &quot;debug&quot;: &quot;~2.2.0&quot;, &quot;ejs&quot;: &quot;~2.3.3&quot;, &quot;express&quot;: &quot;~4.13.1&quot;, &quot;morgan&quot;: &quot;~1.6.1&quot;, &quot;serve-favicon&quot;: &quot;~2.3.0&quot;, &quot;mysql&quot;:&quot;*&quot; } } npm install安装依赖 新建立两个文件夹，models和config 写一个config配置文件，去连接mysql的: module.exports = { mysql_dev: { host: &apos;localhost&apos;, user: &apos;user&apos;, password: &apos;your password&apos;, database: &apos;your db name&apos;, connectionLimit: 10, supportBigNumbers: true } }; 再写上一个database.js文件： var mysql = require(&apos;mysql&apos;); var config = require(&apos;../config/config&apos;); var pool = mysql.createPool(config.mysql_dev); exports.pool = pool; 在models里建立一个User.js文件作为model： var db = require(&apos;./database&apos;); var User = function() {}; User.prototype.find = function(id, callback) { var sql = &quot;SELECT * FROM users WHERE id =?&quot;; // get a connection from the pool db.pool.getConnection(function(err, connection) { if (err) { callback(true); return; } // make the query connection.query(sql, [id], function(err, results) { if (err) { callback(true); return; } callback(false, results); }); }); }; module.exports = User; 最后在app.js里引入，再调用： var User = require(&apos;./models/User&apos;); //....... app.get(&apos;/users/:userid&apos;,function(req,res){ var userid = req.params.userid; var user = new User(); user.find(userid,function(err,result){ if(err){ res.send(&apos;not found&apos;); } res.send(result.length === 1 ? result[0]:result); }); }); 这样就简单地完成一个后端的node.js分级结构，前端提供rest请求。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"express.js","slug":"express-js","permalink":"https://www.silenceboy.com/tags/express-js/"}]},{"title":"Chrome 浏览器中的插件Vimium","slug":"Chrome-浏览器中的插件Vimium","date":"2015-12-24T02:44:59.000Z","updated":"2021-09-27T07:27:40.435Z","comments":true,"path":"2015/12/24/Chrome-浏览器中的插件Vimium/","link":"","permalink":"https://www.silenceboy.com/2015/12/24/Chrome-浏览器中的插件Vimium/","excerpt":"","text":"像使用vim一样使用浏览器，完全键盘操作，脱离鼠标。 Vimium 常用的按键功能解释：j：向下细微滚动窗口 k：向上细微滚动窗口J：(Shift+j的意思，以下大写全部表示加Shift) 下一个标签页 K：上一个标签页d：向下滚动半个屏幕 u：向上移动半个屏幕g+g（连续按两下g）：回到顶部G：到达页面底部H：后退 L： 前进f：将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框。如果按的是F，那么将在新窗口中打开页面（见上图）g+i：将光标 定位到输入框，如果有多个可以按Tab键切换x：关闭当前页面 X：恢复刚刚关闭的页面o：相当于Chrome中的地址栏，可以匹配历史记录、收藏夹并在当前窗口打开，或者直接打开一个网址或者搜索一个关键字（Chrome在全屏的时候地址栏死都出不来，有了它就解决这个一直困扰我的问题了！～），如果按的是O，则可以在新窗口中打开，非常非常方便！g+s：查看网页的源代码r：重新载入当前网页（顺便提一句，这点上新浪微博和它是一样的，光标没有定位在发送框时，即便没有安装这个插件你也可以用j/k来控制页面上下滚动，用r在刷新，用f或者p来定位到发送框。而Gmail的快捷键如j,k上下移动光标也是类似，有兴趣大家可以再自己去了解一下一些常用web应用的快捷键）Vimium / Vimperator 的快捷键远远不止我上面写的这些，想要把它玩得炉火纯青的话，按 shift+/ （chrome）或者是进入设置页面（firefox+chrome），可以找到更详细的的帮助。甚至，你还可以在设置中按照你自己的习惯替换掉一些键。","categories":[{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/categories/chrome/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/tags/chrome/"},{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/tags/vim/"}]},{"title":"phpmailer发送邮件 SMTP Error: Could not authenticate 错误","slug":"phpmailer发送邮件-SMTP-Error-Could-not-authenticate-错误","date":"2015-12-24T02:40:37.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2015/12/24/phpmailer发送邮件-SMTP-Error-Could-not-authenticate-错误/","link":"","permalink":"https://www.silenceboy.com/2015/12/24/phpmailer发送邮件-SMTP-Error-Could-not-authenticate-错误/","excerpt":"","text":"今天在使用phpmailer发送smtp邮件时提示 SMTP Error: Could not authenticate 错误，其中密码帐号都是正确的，邮箱也设置开启了SMTP功能。 上谷歌百度了一遍，有的说是服务器禁用了端口，有的说把class.phpmailer.php中的 代码如下 function IsSMTP() { $this-&gt;Mailer = &apos;smtp&apos;; } 改为 function IsSMTP() { $this-&gt;Mailer = &apos;SMTP&apos;; } （我的问题通过以上修改解决）如果解决不了还有一些解决方法可供参考：这个错误说明虚拟主机不支持PHPMailer默认调用的fsockopen函数，找到class.smtp.php文件，搜索fsockopen，就找到了这样一段代码： 代码如下 // connect to the smtp server $this-&gt;smtp_conn = @fsockopen($host,// the host of the server $port,// the port to use $errno, // error number if any $errstr, // error message if any $tval); // give up after ? secs 方法1：将fsockopen函数替换成pfsockopen函数 首先，在php.ini中去掉下面的两个分号 ;extension=php_sockets.dll ;extension=php_openssl.dll 然后重启一下 因为pfsockopen的参数与fsockopen基本一致，所以只需要将@fsockopen替换成@pfsockopen就可以了。 方法2：使用stream_socket_client函数 一般fsockopen()被禁，pfsockopen也有可能被禁，所以这里介绍另一个函数stream_socket_client()。 stream_socket_client的参数与fsockopen有所不同，所以代码要修改为： 代码如下 $this-&gt;smtp_conn = stream_socket_client(&quot;tcp://&quot;.$host.&quot;:&quot;.$port, $errno, $errstr, $tval); 这样就可以了。","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"}]},{"title":"php中如何使用phpredis","slug":"php中如何使用phpredis","date":"2015-12-24T02:34:10.000Z","updated":"2021-09-27T07:27:40.444Z","comments":true,"path":"2015/12/24/php中如何使用phpredis/","link":"","permalink":"https://www.silenceboy.com/2015/12/24/php中如何使用phpredis/","excerpt":"","text":"安装redis服务：下载地址：http://redis.io/download，下载最新文档版本。本教程使用的最新文档版本为 2.8.17，下载并安装： $ wget http://download.redis.io/releases/redis-2.8.17.tar.gz $ tar xzf redis-2.8.17.tar.gz $ cd redis-2.8.17 $ make make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：下面启动redis服务. $ cd src $ ./redis-server 注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 $ cd src $ ./redis-server redis.conf redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如： $ cd src $ ./redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; 安装PHP redis 驱动装 PHP redis 驱动：下载地址为:https://github.com/nicolasff/phpredis。首先git clone 项目到本地，切换到phpredis目录下在shell中输入 phpize 然后 ./configure 进行配置（ps:可能找不到phpize，phpize是属于php-devel的内容，因此在centos中只要运行如下命令：yum install php-devel 然后就会安装上phpize了。）接下来就是最后的make 和make install了，make 之后记得跑一下 make test，在make install中遇到点权限问题，所以要加上sudo这样就完成了phpredis的编译工作，接下来我们需要来配置了。 然后，在PHP.INI 配置文件中添加一条extension = redis.so 就OK 对了，别忘了重启Apache","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"},{"name":"redis","slug":"redis","permalink":"https://www.silenceboy.com/tags/redis/"}]},{"title":"PHP获取IP地址以及IP地址所在位置","slug":"PHP获取IP地址以及IP地址所在位置","date":"2015-12-22T02:29:45.000Z","updated":"2021-09-27T07:27:40.438Z","comments":true,"path":"2015/12/22/PHP获取IP地址以及IP地址所在位置/","link":"","permalink":"https://www.silenceboy.com/2015/12/22/PHP获取IP地址以及IP地址所在位置/","excerpt":"","text":"获取IP地址：12345678910111213141516171819202122function getIP()&#123; if (isset($_SERVER)) &#123; if (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; &#125; elseif (isset($_SERVER[&apos;HTTP_CLIENT_IP&apos;])) &#123; $realip = $_SERVER[&apos;HTTP_CLIENT_IP&apos;]; &#125; else &#123; $realip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; &#125; else &#123; if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;)) &#123; $realip = getenv( &quot;HTTP_X_FORWARDED_FOR&quot;); &#125; elseif (getenv(&quot;HTTP_CLIENT_IP&quot;)) &#123; $realip = getenv(&quot;HTTP_CLIENT_IP&quot;); &#125; else &#123; $realip = getenv(&quot;REMOTE_ADDR&quot;); &#125; &#125; return $realip;&#125;echo $ip = getIP(); 新浪接口根据ip查询所在区域信息 1234$res0 = file_get_contents(&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&quot;);$res0 = json_decode($res0,true);print_r($res0);echo &quot;&lt;br/&gt;&quot;; 淘宝接口根据ip查询所在区域信息 1234$res1 = file_get_contents(&quot;http://ip.taobao.com/service/getIpInfo.php?ip=$ip&quot;);$res1 = json_decode($res1,true);print_r($res1);echo &quot;&lt;br/&gt;&quot;;","categories":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"}]}],"categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/categories/nodejs/"},{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/categories/linux/"},{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/categories/mysql/"},{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/categories/npm/"},{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/categories/shell/"},{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/categories/git/"},{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/categories/ssh/"},{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/categories/docker/"},{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/categories/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/categories/算法/"},{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/categories/shadowsock/"},{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/categories/html5/"},{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/categories/vim/"},{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/categories/php/"},{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/categories/chrome/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://www.silenceboy.com/tags/nodejs/"},{"name":"mac","slug":"mac","permalink":"https://www.silenceboy.com/tags/mac/"},{"name":"M1","slug":"M1","permalink":"https://www.silenceboy.com/tags/M1/"},{"name":"linux","slug":"linux","permalink":"https://www.silenceboy.com/tags/linux/"},{"name":"i3wm","slug":"i3wm","permalink":"https://www.silenceboy.com/tags/i3wm/"},{"name":"i3","slug":"i3","permalink":"https://www.silenceboy.com/tags/i3/"},{"name":"mysql","slug":"mysql","permalink":"https://www.silenceboy.com/tags/mysql/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.silenceboy.com/tags/ubuntu/"},{"name":"java","slug":"java","permalink":"https://www.silenceboy.com/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.silenceboy.com/tags/jdk/"},{"name":"npm","slug":"npm","permalink":"https://www.silenceboy.com/tags/npm/"},{"name":"scp","slug":"scp","permalink":"https://www.silenceboy.com/tags/scp/"},{"name":"zsh","slug":"zsh","permalink":"https://www.silenceboy.com/tags/zsh/"},{"name":"git","slug":"git","permalink":"https://www.silenceboy.com/tags/git/"},{"name":"pm2","slug":"pm2","permalink":"https://www.silenceboy.com/tags/pm2/"},{"name":"ssh","slug":"ssh","permalink":"https://www.silenceboy.com/tags/ssh/"},{"name":"docker","slug":"docker","permalink":"https://www.silenceboy.com/tags/docker/"},{"name":"jira","slug":"jira","permalink":"https://www.silenceboy.com/tags/jira/"},{"name":"portainer","slug":"portainer","permalink":"https://www.silenceboy.com/tags/portainer/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.silenceboy.com/tags/gitlab/"},{"name":"javascript","slug":"javascript","permalink":"https://www.silenceboy.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://www.silenceboy.com/tags/算法/"},{"name":"shell","slug":"shell","permalink":"https://www.silenceboy.com/tags/shell/"},{"name":"hexo","slug":"hexo","permalink":"https://www.silenceboy.com/tags/hexo/"},{"name":"express.js","slug":"express-js","permalink":"https://www.silenceboy.com/tags/express-js/"},{"name":"middleware","slug":"middleware","permalink":"https://www.silenceboy.com/tags/middleware/"},{"name":"tailf","slug":"tailf","permalink":"https://www.silenceboy.com/tags/tailf/"},{"name":"gitlab-runner","slug":"gitlab-runner","permalink":"https://www.silenceboy.com/tags/gitlab-runner/"},{"name":"sql server","slug":"sql-server","permalink":"https://www.silenceboy.com/tags/sql-server/"},{"name":"sms","slug":"sms","permalink":"https://www.silenceboy.com/tags/sms/"},{"name":"shadowsock","slug":"shadowsock","permalink":"https://www.silenceboy.com/tags/shadowsock/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://www.silenceboy.com/tags/dockerfile/"},{"name":"base64","slug":"base64","permalink":"https://www.silenceboy.com/tags/base64/"},{"name":"html5","slug":"html5","permalink":"https://www.silenceboy.com/tags/html5/"},{"name":"录音","slug":"录音","permalink":"https://www.silenceboy.com/tags/录音/"},{"name":"语言识别","slug":"语言识别","permalink":"https://www.silenceboy.com/tags/语言识别/"},{"name":"excel","slug":"excel","permalink":"https://www.silenceboy.com/tags/excel/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.silenceboy.com/tags/正则表达式/"},{"name":"vim","slug":"vim","permalink":"https://www.silenceboy.com/tags/vim/"},{"name":"vi","slug":"vi","permalink":"https://www.silenceboy.com/tags/vi/"},{"name":"buffer","slug":"buffer","permalink":"https://www.silenceboy.com/tags/buffer/"},{"name":"php","slug":"php","permalink":"https://www.silenceboy.com/tags/php/"},{"name":"chrome","slug":"chrome","permalink":"https://www.silenceboy.com/tags/chrome/"},{"name":"redis","slug":"redis","permalink":"https://www.silenceboy.com/tags/redis/"}]}