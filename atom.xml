<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  <subtitle>morty&#39;s blog</subtitle>
  <link href="https://www.silenceboy.com/atom.xml" rel="self"/>
  
  <link href="https://www.silenceboy.com/"/>
  <updated>2025-11-07T02:44:19.797Z</updated>
  <id>https://www.silenceboy.com/</id>
  
  <author>
    <name>morty</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>企业私有知识库RAG系统构建挑战</title>
    <link href="https://www.silenceboy.com/2025/11/07/%E4%BC%81%E4%B8%9A%E7%A7%81%E6%9C%89%E7%9F%A5%E8%AF%86%E5%BA%93RAG%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E6%8C%91%E6%88%98/"/>
    <id>https://www.silenceboy.com/2025/11/07/%E4%BC%81%E4%B8%9A%E7%A7%81%E6%9C%89%E7%9F%A5%E8%AF%86%E5%BA%93RAG%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E6%8C%91%E6%88%98/</id>
    <published>2025-11-07T02:43:04.000Z</published>
    <updated>2025-11-07T02:44:19.797Z</updated>
    
    <content type="html"><![CDATA[<p>构建企业私有知识库的检索增强生成（RAG）系统面临着多重挑战，这些困难主要集中在<strong>源数据的质量和结构</strong>、<strong>复杂的数据预处理流程</strong>以及<strong>生产级系统的架构和性能</strong>等方面。</p><h3 id="一、-源数据（私有文档）的质量与结构挑战"><a href="#一、-源数据（私有文档）的质量与结构挑战" class="headerlink" title="一、 源数据（私有文档）的质量与结构挑战"></a>一、 源数据（私有文档）的质量与结构挑战</h3><p>企业私有知识库通常包含面向人类阅读的现有文档，其格式和写作风格往往不符合 RAG 系统的优化要求，导致检索器性能不佳。</p><ol><li><p><strong>缺乏结构化格式和元数据</strong>：</p><ul><li>原始文档可能<strong>缺少清晰的章节标题、副标题或元数据</strong>，这使得 RAG 模型难以识别和提取相关信息。</li><li>例如，没有明确标题的长文档会使确定特定信息的上下文变得困难。高质量的 RAG 需要生成并存储元数据（如文件名、URLs、作者、章节标题、页码等），以实现更快、更高效的数据检索。</li></ul></li><li><p><strong>语言非正式且不一致</strong>：</p><ul><li>文档可能包含<strong>非正式语言或不一致的术语</strong>。</li><li>最常见的问题是<strong>未定义或法学硕士（LLMs）未知的缩写</strong>，这可能会混淆 RAG 模型。</li><li>LLMs 接受了海量互联网数据的训练，但<strong>缺乏企业内部文档的上下文</strong>，因此必须设置上下文、定义缩写并避免使用或定义公司特定的术语。</li></ul></li><li><p><strong>冗余、冗长和歧义</strong>：</p><ul><li>原始文档可能过于<strong>冗长</strong>，包含不必要或重复的信息，使 RAG 模型不堪重负，导致响应不够简洁和相关。</li><li>文档中可能包含<strong>模棱两可的术语或短语</strong>，可能有多种解释，从而导致 RAG 模型误解和不准确的响应。</li></ul></li><li><p><strong>注入图形和超链接元素</strong>：</p><ul><li>包含图形和超链接（URLs）的原始文档虽然适合人类使用，但这些元素<strong>可能会消耗检索令牌限制</strong>，导致后续段落中的关键信息丢失或摘录不完整。</li></ul></li><li><p><strong>缺乏特定领域的知识或上下文</strong>：</p><ul><li>文档可能缺乏生成准确响应所需的<strong>特定领域知识或上下文</strong>，这限制了 RAG 模型生成相关且准确响应的能力。</li></ul></li></ol><h3 id="二、-数据预处理和管道工程挑战"><a href="#二、-数据预处理和管道工程挑战" class="headerlink" title="二、 数据预处理和管道工程挑战"></a>二、 数据预处理和管道工程挑战</h3><p>将企业非结构化数据转化为可用于 RAG 的高质量向量索引，需要一个复杂且精心策划的数据管道。</p><ol><li><p><strong>文件格式的多样性与复杂性</strong>：</p><ul><li>企业级数据来源广泛，格式多样，包括但不限于 <strong>PDF、Word、Excel、PPT</strong> 等。每种格式都有其特定的结构和内容表示方式，给解析工作带来了挑战。</li><li><strong>内容复杂性</strong>：文档内容可能包含文本、图像、表格、公式等多种元素，这些元素的解析和提取需要不同的技术和方法。</li></ul></li><li><p><strong>非结构化数据的解析难度</strong>：</p><ul><li>对于 <strong>PDF 和扫描图像</strong> 等非结构化数据，信息以视觉化方式呈现，解析难度大，通常需要借助 OCR（光学字符识别）和文档布局检测（DLD）等技术进行预处理和格式信息提取。</li><li><strong>表格信息难以解释</strong>：RAG 模型可能难以解释表格，因为这需要对二维结构的理解。建议用多级项目符号列表或扁平语法格式化表格信息，以方便模型处理。</li></ul></li><li><p><strong>分块策略（Chunking）的优化</strong>：</p><ul><li>将大型文档分解为较小、可管理的部分（分块）是 RAG 工作流中的关键预处理步骤。</li><li><strong>糟糕的分块</strong> 会导致检索结果不相关、效率低下并降低业务价值。</li><li><strong>没有“一刀切”的分块方法</strong>。最佳的分块大小和策略（如固定大小分块、段落分块或语义分块）取决于具体的用例和数据性质，需要进行迭代和实验。</li></ul></li><li><p><strong>数据去重与过滤</strong>：</p><ul><li>由于数据源可能来自多个共享驱动器，可能会出现重复或近似重复的文档，如果这些冗余块保留在最终索引中，会降低应用程序的性能。</li><li>必须进行<strong>过滤</strong>，以消除与 RAG 目的不相关、太旧、不可靠或包含敏感信息（如个人身份信息 PII）的文档。</li></ul></li></ol><h3 id="三、-生产级系统架构与性能挑战"><a href="#三、-生产级系统架构与性能挑战" class="headerlink" title="三、 生产级系统架构与性能挑战"></a>三、 生产级系统架构与性能挑战</h3><p>企业 RAG 系统必须具备鲁棒性、可扩展性和高度的准确性，以应对复杂的生产环境和用户查询。</p><ol><li><p><strong>处理复杂的多跳查询</strong>：</p><ul><li>简单的 RAG 架构（线性、一次性流程）<strong>无法解决需要推理、反思和多步骤决策的复杂查询</strong>。</li><li>真正的企业应用往往涉及<strong>多源知识</strong>的整合，需要系统能够先从内部文档中识别事实，再通过外部搜索（如 Web 搜索）查找最新信息，最后将二者综合分析，进行多跳推理。这需要构建复杂的 Agentic RAG 流水线来管理状态和控制流。</li></ul></li><li><p><strong>检索精度和效率</strong>：</p><ul><li>生产级 RAG 需要采用<strong>多阶段检索漏斗</strong>（先广召回，再高精度重排）来确保检索结果的质量。</li><li>需要在<strong>召回率（Recall）</strong>（确保找到所有相关信息）和<strong>精度（Precision）</strong>（确保检索到的文档中相关信息占比高）之间取得平衡。</li></ul></li><li><p><strong>基础设施和可扩展性</strong>：</p><ul><li>RAG 的核心引擎是<strong>向量数据库</strong>，它必须针对快速查询进行优化，能够处理数百万个向量，支持分布式索引和分片，以确保低延迟和高吞吐量。</li><li>在向量数据库的选择上，需要平衡<strong>性能、可扩展性、集成兼容性、成本和基础设施</strong>（云原生或自托管）等多个关键因素。</li></ul></li><li><p><strong>安全性和合规性</strong>：</p><ul><li>由于处理的是企业<strong>私有</strong>知识库，数据保护是首要任务。系统必须支持：<ul><li><strong>静态和传输中的加密</strong>。</li><li><strong>基于角色的访问控制</strong>。</li><li>符合如 <strong>GDPR 或 HIPAA</strong> 等监管标准。</li></ul></li></ul></li><li><p><strong>持续评估与迭代</strong>：</p><ul><li>构建一个持续提供准确、相关响应的 RAG 系统非常困难，需要在开发和生产中持续进行评估，以区分细微的改进和系统崩溃。</li><li>传统的 NLP 指标（如 BLEU 和 ROUGE）无法检测到幻觉和上下文利用率，因此需要使用 <strong>RAG 三元组</strong>（上下文相关性、忠实性和答案相关性）等 RAG 专属指标，并结合人工评估，以确保结果与用户满意度相关。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;构建企业私有知识库的检索增强生成（RAG）系统面临着多重挑战，这些困难主要集中在&lt;strong&gt;源数据的质量和结构&lt;/strong&gt;、&lt;strong&gt;复杂的数据预处理流程&lt;/strong&gt;以及&lt;strong&gt;生产级系统的架构和性能&lt;/strong&gt;等方面。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="RAG" scheme="https://www.silenceboy.com/categories/RAG/"/>
    
    
    <category term="RAG" scheme="https://www.silenceboy.com/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>fidl和arxml互转教程</title>
    <link href="https://www.silenceboy.com/2025/09/05/fidl%E5%92%8Carxml%E4%BA%92%E8%BD%AC%E6%95%99%E7%A8%8B/"/>
    <id>https://www.silenceboy.com/2025/09/05/fidl%E5%92%8Carxml%E4%BA%92%E8%BD%AC%E6%95%99%E7%A8%8B/</id>
    <published>2025-09-05T09:56:31.000Z</published>
    <updated>2025-09-05T10:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>fracon</code> 命令行工具可以使用 <code>maven</code> 从源代码构建。本页介绍如何运行本地构建。 请注意，你的公司需要成为 <code>AUTOSAR</code> 组织的成员。如果不是会员，你将无法访问 <code>artop.org</code>，因此无法使用 FARACON 工具。</p><p>环境要求：java8 &#x2F; mvn3.x</p><p>注意：<strong>以下所有操作均在ubuntu20.04上进行。</strong></p><h2 id="如何从源码构建命令行工具"><a href="#如何从源码构建命令行工具" class="headerlink" title="如何从源码构建命令行工具"></a>如何从源码构建命令行工具</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>源码地址：<a href="https://github.com/COVESA/franca_ara_tools">https://github.com/COVESA/franca_ara_tools</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/GENIVI/franca_ara_tools.git</span><br></pre></td></tr></table></figure><h3 id="artop文件下载"><a href="#artop文件下载" class="headerlink" title="artop文件下载"></a>artop文件下载</h3><p>为了构建<code>franca_ara_tools</code>项目，需要下载<code>artop</code>提供的<code>artop-Update-4.12.1</code>文件。只有加入<code>autosar</code>会员的公司才能注册和登录<code>artop</code>站点：<a href="https://www.artop.org/">https://www.artop.org</a>。</p><ol><li>登录<code>artop</code>站点后，选择<code>Downloads</code>，然后选择<code>All Downloads</code>。</li></ol><p><img src="/../images/artop1.png"></p><ol start="2"><li>选择<code>SDK</code></li></ol><p><img src="/../images/artop2.png"></p><ol start="3"><li>下拉找到<code>artop-Update-4.12.1.zip</code></li></ol><p><strong>注意：目前只能使用4.12.1版本，其他版本无效。</strong></p><p><img src="/../images/artop3.png"></p><ol start="4"><li><code>artop-Update-4.12.1.zip</code>解压到制定目录：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -d /home/test/franca/artop-Update-4.12.1 artop-Update-4.12.1.zip</span><br></pre></td></tr></table></figure><h3 id="franca-ara-tools源码修改"><a href="#franca-ara-tools源码修改" class="headerlink" title="franca_ara_tools源码修改"></a>franca_ara_tools源码修改</h3><p>进入下载的franca_ara_tools项目目录，然后执行以下操作：</p><ol><li>修改<code>releng/org.genivi.faracon.parent/pom.xml</code>文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">+++ b/releng/org.genivi.faracon.parent/pom.xml</span><br><span class="line">@@ -401,6 +401,16 @@</span><br><span class="line">                                                        &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt;</span><br><span class="line">                                                        &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt;</span><br><span class="line">                                                        &lt;version&gt;$&#123;jdt-core-version&#125;&lt;/version&gt;</span><br><span class="line">+                                                       &lt;exclusions&gt;</span><br><span class="line">+                                                               &lt;exclusion&gt;</span><br><span class="line">+                                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                                       &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;</span><br><span class="line">+                                                               &lt;/exclusion&gt;</span><br><span class="line">+                                                               &lt;exclusion&gt;</span><br><span class="line">+                                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                                       &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;</span><br><span class="line">+                                                               &lt;/exclusion&gt;</span><br><span class="line">+                                                       &lt;/exclusions&gt;</span><br><span class="line">                                                &lt;/dependency&gt;</span><br><span class="line">                                                &lt;dependency&gt;</span><br><span class="line">                                                        &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt;</span><br><span class="line">@@ -412,10 +422,36 @@</span><br><span class="line">                                                        &lt;artifactId&gt;org.eclipse.jdt.compiler.tool&lt;/artifactId&gt;</span><br><span class="line">                                                        &lt;version&gt;$&#123;jdt-compiler-tool-version&#125;&lt;/version&gt;</span><br><span class="line">                                                &lt;/dependency&gt;</span><br><span class="line">+                                               &lt;dependency&gt;</span><br><span class="line">+                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                       &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;</span><br><span class="line">+                                                       &lt;version&gt;3.12.0&lt;/version&gt;</span><br><span class="line">+                                                       &lt;exclusions&gt;</span><br><span class="line">+                                                               &lt;exclusion&gt;</span><br><span class="line">+                                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                                       &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;</span><br><span class="line">+                                                               &lt;/exclusion&gt;</span><br><span class="line">+                                                       &lt;/exclusions&gt;</span><br><span class="line">+                                               &lt;/dependency&gt;</span><br><span class="line">                                                &lt;dependency&gt;</span><br><span class="line">                                                        &lt;groupId&gt;org.eclipse.emf&lt;/groupId&gt;</span><br><span class="line">                                                        &lt;artifactId&gt;org.eclipse.emf.codegen&lt;/artifactId&gt;</span><br><span class="line">                                                        &lt;version&gt;$&#123;emf-codegen-version&#125;&lt;/version&gt;</span><br><span class="line">+                                                       &lt;exclusions&gt;</span><br><span class="line">+                                                               &lt;exclusion&gt;</span><br><span class="line">+                                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                                       &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;</span><br><span class="line">+                                                               &lt;/exclusion&gt;</span><br><span class="line">+                                                               &lt;exclusion&gt;</span><br><span class="line">+                                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                                       &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;</span><br><span class="line">+                                                               &lt;/exclusion&gt;</span><br><span class="line">+                                                       &lt;/exclusions&gt;</span><br><span class="line">+                                               &lt;/dependency&gt;</span><br><span class="line">+                                               &lt;dependency&gt;</span><br><span class="line">+                                                       &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;</span><br><span class="line">+                                                       &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;</span><br><span class="line">+                                                       &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">                                                &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/fidl1.png"></p><ol start="2"><li>修改<code>releng/org.genivi.faracon.target/fara-oxygen-artop.target</code>文件，将location修改为本地artop文件目录：<code>&lt;repository location=&quot;file:/home/test/franca/artop-Update-4.12.1&quot;/&gt;</code></li></ol><p><img src="/../images/fidl2.png"></p><h3 id="franca-ara-tools源码构建"><a href="#franca-ara-tools源码构建" class="headerlink" title="franca_ara_tools源码构建"></a>franca_ara_tools源码构建</h3><p>进入<code>franca_ara_tools</code>项目的<code>releng/org.genivi.faracon.parent</code>目录，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean install -Pwith-artop -Dtycho.disableP2Mirrors=true</span><br></pre></td></tr></table></figure><p>等待构建完成，时间较长：</p><p><img src="/../images/fidl3.png"></p><p>构建成功之后在<code>franca_ara_tools</code>项目下生成products目录，构建成果物在该目录下。</p><h2 id="文件转换"><a href="#文件转换" class="headerlink" title="文件转换"></a>文件转换</h2><p>构建完成后在<code>products/org.genivi.faracon.cli.product/target/products/org.genivi.faracon.cli.product</code>目录下会生成各个平台的可执行文件，进入目录：</p><p><img src="/../images/fidl4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd products/org.genivi.faracon.cli.product/target/products/org.genivi.faracon.cli.product</span><br></pre></td></tr></table></figure><p>由于我在<code>ubuntu20.04</code>下操作，将对应系统文件<code>copy</code>到指定目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -a franca_ara_tools/products/org.genivi.faracon.cli.product/target/products/org.genivi.faracon.cli.product/linux/gtk/x86_64 $HOME/faracon</span><br></pre></td></tr></table></figure><p>为了在任意地方使用<code>faranca</code>命令，设置环境变量：<code>vim ~/.zshrc</code>,添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$HOME/faracon</span><br></pre></td></tr></table></figure><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p><code>faracon-linux-x86_64 --help</code> 将输出以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Command: Console Help</span><br><span class="line">Command: Franca ARA Converter</span><br><span class="line">usage: faracon [-a &lt;arg&gt;] [-c] [-ca] [-d &lt;arg&gt;] [-e] [-f &lt;arg&gt;] [-i &lt;arg&gt;] [-L</span><br><span class="line">       &lt;arg&gt;] [-l &lt;arg&gt;]</span><br><span class="line"> -a,--ara-to-franca &lt;arg&gt;       Arxml file that will be converted to .fidl or</span><br><span class="line">                                directory what will be recursively scanned for</span><br><span class="line">                                .arxml files and each one of them will be</span><br><span class="line">                                converted to corresponding fidl ones.</span><br><span class="line"> -c,--continue-on-errors        Do not stop the tool execution when an error</span><br><span class="line">                                occurs.</span><br><span class="line"> -ca,--check-arxml-files-only   Checks the provided ARXML files.</span><br><span class="line"> -conf,--f2aconfig &lt;arg&gt;        Supply configuration file for command line</span><br><span class="line">                                related to Franca-to-arxml generation.</span><br><span class="line"> -d,--dest &lt;arg&gt;                Output directory for the generated files.</span><br><span class="line"> -e,--warnings-as-errors        Treat warnings as errors.</span><br><span class="line"> -f,--franca-to-ara &lt;arg&gt;       Franca file that will be converted to arxml or</span><br><span class="line">                                directory what will be recursively scanned for</span><br><span class="line">                                fidl files and each one of them will be</span><br><span class="line">                                converted to corresponding arxml ones.</span><br><span class="line"> -i,--include &lt;arg&gt;             Additions to classpath.</span><br><span class="line"> -L,--license &lt;arg&gt;             The file path to the license text that will be</span><br><span class="line">                                added to each generated file.</span><br><span class="line"> -l,--log-level &lt;arg&gt;           The log level (quiet or verbose).</span><br><span class="line"></span><br><span class="line">Command: Console Help</span><br><span class="line">usage: faracon -h</span><br><span class="line"> -h,--help   Print out options of the tool.</span><br><span class="line"></span><br><span class="line">Command: Version Information</span><br><span class="line">usage: faracon -v</span><br><span class="line"> -v,--version   Show version number of the tool.</span><br></pre></td></tr></table></figure><h3 id="转换前注意事项"><a href="#转换前注意事项" class="headerlink" title="转换前注意事项"></a>转换前注意事项</h3><p>终于可以使用命令行工具了，激动的去试一试，但是发现在执行转换命令操作的时候遇到以下报错：</p><p><img src="/../images/fidl5.png"></p><p>经过一番排查之后，找到了问题原因，修改<code>$HOME/faracon/faracon-linux-x86_64.ini</code>文件内容，删除<code>--illegal-access=deny</code>参数。</p><p>删除前：</p><p><img src="/../images/fidl6.png"></p><p>删除后：</p><p><img src="/../images/fidl7.png"></p><p>之后就可以按照以下步骤进行转换了。👦</p><h3 id="fidl转arxml"><a href="#fidl转arxml" class="headerlink" title="fidl转arxml"></a>fidl转arxml</h3><p>转换 <code>/path/to/fidls</code> 中的所有 <code>fidl</code> 文件，将输出存储在<code> /path/to/output </code>中，使用详细的日志记录级别，并在发生错误时继续翻译下一个 <code>fidl</code>：</p><p>转换<code>fidl</code>使用参数<code>-f</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ faracon-linux-x86_64 -f /path/to/fidls/ -d /path/to/output/ -l verbose -c</span><br></pre></td></tr></table></figure><p>也可指定文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ faracon-linux-x86_64 -f /path/to/fidls/helloworld.fidl -d /path/to/output/ -l verbose -c</span><br></pre></td></tr></table></figure><p><img src="/../images/fidl8.png"></p><h3 id="arxml转fidl"><a href="#arxml转fidl" class="headerlink" title="arxml转fidl"></a>arxml转fidl</h3><p>转换<code> /path/to/arxmls</code> 中的所有 <code>arxml</code> 文件，将输出存储在<code> /path/to/output</code> 中，使用详细的日志记录级别，并在发生错误时继续翻译下一个 <code>arxml</code>：</p><p>转换<code>arxml</code>使用参数<code>-a</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ faracon-linux-x86_64 -a /path/to/arxmls/ -d /path/to/output/ -l verbose -c</span><br></pre></td></tr></table></figure><p>也可指定文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ faracon-linux-x86_64 -a /path/to/arxmls/helloworld.arxml -d /path/to/output/ -l verbose -c</span><br></pre></td></tr></table></figure><p><img src="/../images/fidl9.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;fracon&lt;/code&gt; 命令行工具可以使用 &lt;code&gt;maven&lt;/code&gt; 从源代码构建。本页介绍如何运行本地构建。 请注意，你的公司需要成为 &lt;code&gt;AUTOSAR&lt;/code&gt; 组织的成员。如果不是会员，你将无法访问 &lt;code&gt;artop.o</summary>
      
    
    
    
    <category term="autosar" scheme="https://www.silenceboy.com/categories/autosar/"/>
    
    
    <category term="fidl" scheme="https://www.silenceboy.com/tags/fidl/"/>
    
    <category term="arxml" scheme="https://www.silenceboy.com/tags/arxml/"/>
    
  </entry>
  
  <entry>
    <title>AI编码工具对比分析</title>
    <link href="https://www.silenceboy.com/2025/09/05/AI%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/"/>
    <id>https://www.silenceboy.com/2025/09/05/AI%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</id>
    <published>2025-09-05T09:16:49.000Z</published>
    <updated>2025-09-05T09:38:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：模型决定下限，Agent决定上限"><a href="#前言：模型决定下限，Agent决定上限" class="headerlink" title="前言：模型决定下限，Agent决定上限"></a>前言：模型决定下限，Agent决定上限</h1><p>在深入对比分析之前，我想分享一个重要观点：<strong>模型决定下限，Agent决定上限</strong>。</p><h2 id="核心观察"><a href="#核心观察" class="headerlink" title="核心观察"></a>核心观察</h2><p>如果您使用过不同的AI IDE，可能会发现一个有趣的现象：即使都选择相同的Claude Sonnet 4模型，不同工具生成的代码质量差别往往很大。这种差异的根本原因在于，<strong>底层模型只是AI编码工具的基础能力边界，而真正决定实际效果的是各工具的Agent架构和工程实现</strong>。具体原因如下：</p><ol><li><p><strong>提示工程的差异</strong></p><ul><li>不同工具对相同模型使用不同的提示策略、上下文组织方式和任务分解逻辑</li><li>优秀的Agent会根据代码类型、项目结构、开发阶段动态调整提示策略</li></ul></li><li><p><strong>上下文管理的水平</strong></p><ul><li>如何选择、组织和传递代码上下文信息直接影响生成质量</li><li>项目级理解、跨文件依赖分析、代码库索引等能力差异巨大</li></ul></li><li><p><strong>工作流集成的深度</strong></p><ul><li>与开发环境、版本控制、测试框架的集成程度</li><li>多步骤任务的规划、执行和验证能力</li></ul></li><li><p><strong>反馈循环的设计</strong></p><ul><li>错误检测、自我修正、迭代优化的机制</li><li>从用户行为中学习和适应的能力</li></ul></li></ol><h2 id="实践启示"><a href="#实践启示" class="headerlink" title="实践启示"></a>实践启示</h2><p>基于这一认知，我们在选择和使用AI编码工具时应该：</p><p><strong>关注Agent能力而非仅仅模型版本</strong></p><ul><li>评估工具的项目理解能力、任务分解能力、上下文管理水平</li><li>测试在实际工作场景中的表现，而非单纯的基准测试分数</li></ul><p><strong>善用工具组合，发挥协同效应</strong></p><ul><li>不同工具在不同场景下各有优势，组合使用往往效果更佳</li><li>例如：用Claude Code做架构分析，用Cursor做功能开发，用Copilot做日常补全</li></ul><p><strong>持续优化使用策略</strong></p><ul><li>学习每个工具的最佳实践和高级功能</li><li>根据项目特点和团队需求调整工具配置和使用方式</li></ul><p><strong>拥抱Agent时代的编程范式</strong></p><ul><li>从”代码补全”思维转向”AI协作”思维</li><li>将AI工具视为编程伙伴，而非简单的自动完成工具</li></ul><h1 id="执行摘要"><a href="#执行摘要" class="headerlink" title="执行摘要"></a>执行摘要</h1><p>本报告对当前主流的三款AI编码工具进行了深入分析对比：GitHub Copilot、Cursor和Claude Code。通过功能特性、性能表现、适用场景等多个维度的评估，为开发者和团队针对不同工作内容选择合适的AI编码工具提供决策依据。</p><p><strong>关键发现：</strong></p><ul><li><strong>GitHub Copilot</strong>：最适合日常代码补全和多编辑器环境，稳定可靠</li><li><strong>Cursor</strong>：最适合需要深度AI集成的现代化开发，项目级理解能力强</li><li><strong>Claude Code</strong>：最适合复杂项目重构和大型代码库分析，上下文理解能力最强</li></ul><p><strong>核心建议：</strong></p><ul><li><strong>快速开发和日常编码</strong>：选择GitHub Copilot</li><li><strong>大型项目和团队协作</strong>：选择Cursor</li><li><strong>复杂重构和架构分析</strong>：选择Claude Code</li></ul><h1 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h1><h2 id="GitHub-Copilot"><a href="#GitHub-Copilot" class="headerlink" title="GitHub Copilot"></a>GitHub Copilot</h2><p><strong>开发商：</strong> GitHub &amp; OpenAI<br><strong>发布时间：</strong> 2021年<br><strong>核心定位：</strong> AI代码补全助手  </p><p>GitHub Copilot是首批商业化的AI编码工具之一，专注于提供高质量的代码补全和生成功能。基于OpenAI Codex模型训练，能够理解自然语言注释并生成相应代码。</p><h2 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h2><p><strong>开发商：</strong> Anysphere<br><strong>发布时间：</strong> 2023年<br><strong>核心定位：</strong> AI增强型集成开发环境  </p><p>Cursor是基于VS Code构建的AI原生IDE，将AI功能深度集成到开发环境的每个角落，提供从代码补全到项目管理的全方位AI支持。</p><h2 id="Claude-Code"><a href="#Claude-Code" class="headerlink" title="Claude Code"></a>Claude Code</h2><p><strong>开发商：</strong> Anthropic<br><strong>发布时间：</strong> 2024年<br><strong>核心定位：</strong> 终端AI编程助手  </p><p>Claude Code是Anthropic推出的命令行AI编程工具，采用代理式架构，具备强大的自主决策能力和超大上下文理解能力。</p><h1 id="功能特性对比"><a href="#功能特性对比" class="headerlink" title="功能特性对比"></a>功能特性对比</h1><h2 id="代码补全能力"><a href="#代码补全能力" class="headerlink" title="代码补全能力"></a>代码补全能力</h2><table><thead><tr><th>特性</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td>补全类型</td><td>内联建议、函数生成</td><td>多行补全、智能Tab</td><td>整体代码生成</td></tr><tr><td>上下文理解</td><td>当前文件+光标附近</td><td>项目级理解</td><td>200K tokens超大上下文</td></tr><tr><td>预测准确性</td><td>高（稳定）</td><td>很高（智能）</td><td>极高（深度理解）</td></tr><tr><td>响应速度</td><td>快</td><td>快</td><td>中等</td></tr></tbody></table><h2 id="AI模型支持"><a href="#AI模型支持" class="headerlink" title="AI模型支持"></a>AI模型支持</h2><table><thead><tr><th>工具</th><th>支持模型</th></tr></thead><tbody><tr><td>GitHub Copilot</td><td>GPT系列，Claude系列，Gemini系列等</td></tr><tr><td>Cursor</td><td>GPT系列，Claude系列，Gemini系列等</td></tr><tr><td>Claude Code</td><td>Claude 系列，通过模型网关，也可接入其他模型</td></tr></tbody></table><h2 id="编辑器集成"><a href="#编辑器集成" class="headerlink" title="编辑器集成"></a>编辑器集成</h2><table><thead><tr><th>工具</th><th>支持编辑器</th><th>集成深度</th></tr></thead><tbody><tr><td>GitHub Copilot</td><td>VS Code, JetBrains, Vim, Neovim</td><td>插件形式</td></tr><tr><td>Cursor</td><td>内置（基于VS Code）</td><td>原生集成</td></tr><tr><td>Claude Code</td><td>终端 + VS Code&#x2F;JetBrains插件</td><td>命令行为主</td></tr></tbody></table><h1 id="详细功能分析"><a href="#详细功能分析" class="headerlink" title="详细功能分析"></a>详细功能分析</h1><h2 id="GitHub-Copilot-1"><a href="#GitHub-Copilot-1" class="headerlink" title="GitHub Copilot"></a>GitHub Copilot</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li><p><strong>广泛的编辑器支持</strong></p><ul><li>支持VS Code、JetBrains全系列、Vim、Neovim等主流编辑器</li><li>提供一致的用户体验，降低学习成本</li></ul></li><li><p><strong>稳定的代码补全质量</strong></p><ul><li>基于大量开源代码训练，代码质量可靠</li><li>支持多种编程语言，包括主流和小众语言</li></ul></li><li><p><strong>深度生态系统与代理能力</strong></p><ul><li>与GitHub平台无缝集成（PR、Issue、Actions）</li><li>新增“代理模式”（Agentic Coding）：可根据项目上下文建议或执行跨文件变更与命令方案（以 VS Code 集成为主）</li><li>适合需要项目级改动规划与执行建议的场景</li></ul></li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li><p><strong>上下文理解局限</strong></p><ul><li>主要基于当前文件和光标附近代码</li><li>对跨文件依赖理解能力有限</li><li>难以处理复杂的项目架构</li></ul></li><li><p><strong>代码质量风险</strong></p><ul><li>可能生成包含逻辑错误的代码</li><li>不总是遵循最佳实践</li><li>需要开发者具备代码审查能力</li></ul></li><li><p><strong>隐私安全顾虑</strong></p><ul><li>代码片段需上传至云端处理</li><li>可能涉及知识产权泄露风险</li><li>企业级用户需要额外的安全配置</li></ul></li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>日常代码补全需求</strong>：适合需要快速代码补全的开发者</li><li><strong>多编辑器环境</strong>：适合使用多种编辑器的开发团队</li><li><strong>GitHub深度用户</strong>：已深度使用GitHub生态的团队</li><li><strong>预算敏感项目</strong>：寻求高性价比AI编码工具的个人开发者</li></ul><h2 id="Cursor-1"><a href="#Cursor-1" class="headerlink" title="Cursor"></a>Cursor</h2><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ol><li><p><strong>深度AI集成的IDE体验</strong></p><ul><li>AI功能原生集成到IDE的每个角落</li><li>提供聊天面板、快捷键触发等多种交互方式</li><li>支持AI驱动的代码重构和调试</li></ul></li><li><p><strong>多模型支持与灵活性</strong></p><ul><li>支持GPT系列、Claude系列、Gemini系列等多个模型</li><li>用户可根据任务需求切换不同模型</li><li>持续集成最新的AI模型</li></ul></li><li><p><strong>项目级代码理解</strong></p><ul><li>能够理解整个代码库结构</li><li>支持跨文件依赖分析</li><li>适合大型项目的开发和维护</li></ul></li><li><p><strong>现代化用户界面</strong></p><ul><li>基于VS Code构建，保持熟悉的操作体验</li><li>提供可视化的差异查看和批量操作</li><li>支持VS Code扩展生态</li></ul></li></ol><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ol><li><p><strong>学习曲线较陡峭</strong></p><ul><li>功能丰富，初学者需要时间适应</li><li>AI功能的最佳使用方式需要学习</li><li>可能存在功能过载的问题</li></ul></li><li><p><strong>系统资源占用</strong></p><ul><li>作为完整IDE，占用较多系统资源</li><li>对硬件配置有一定要求</li><li>可能影响低配置设备的性能</li></ul></li></ol><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>大型项目开发</strong>：需要深度理解复杂代码库的项目</li><li><strong>AI深度集成需求</strong>：希望AI深度参与编程过程的开发者</li><li><strong>现代化开发团队</strong>：追求高效开发体验的团队</li><li><strong>VS Code用户</strong>：熟悉VS Code操作的开发者</li></ul><h2 id="Claude-Code-1"><a href="#Claude-Code-1" class="headerlink" title="Claude Code"></a>Claude Code</h2><h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h3><ol><li><p><strong>超大上下文窗口</strong></p><ul><li>支持200K tokens的上下文窗口</li><li>能够一次性处理整个大型代码库</li><li>提供更深层次的代码理解能力</li></ul></li><li><p><strong>强大的自主决策能力</strong></p><ul><li>采用代理式架构，能够自主规划任务</li><li>支持复杂的多步骤任务分解</li><li>具备跨文件依赖分析能力</li></ul></li><li><p><strong>隐私与执行方式</strong></p><ul><li>以本地终端为主要操作界面，但模型推理通常在云端（调用 Anthropic API）</li><li>支持通过企业代理&#x2F;私有网关降低代码外发风险（需单独配置）</li><li>适合对安全性和审计有要求且可接受受控外发的场景</li></ul></li><li><p><strong>终端原生体验</strong></p><ul><li>无缝融入现有开发工具链</li><li>适合习惯命令行操作的开发者</li><li>减少界面干扰，专注于代码本身</li></ul></li></ol><h3 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h3><ol><li><p><strong>学习曲线陡峭</strong></p><ul><li>需要熟悉终端操作</li><li>命令行界面对初学者不够友好</li><li>缺乏图形化的操作指导</li></ul></li><li><p><strong>缺乏可视化界面</strong></p><ul><li>纯命令行工具，无图形界面</li><li>不适合习惯GUI操作的开发者</li><li>代码审查和协作相对困难</li></ul></li></ol><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>复杂项目管理</strong>：需要深度代码理解和自动化的项目</li><li><strong>终端操作偏好</strong>：习惯命令行操作的高级开发者</li><li><strong>大型代码库处理</strong>：需要处理大型代码库重构的场景</li><li><strong>隐私敏感项目</strong>：对代码隐私有高要求的企业项目</li></ul><h1 id="性能与准确性对比"><a href="#性能与准确性对比" class="headerlink" title="性能与准确性对比"></a>性能与准确性对比</h1><h2 id="代码生成质量"><a href="#代码生成质量" class="headerlink" title="代码生成质量"></a>代码生成质量</h2><p>根据社区反馈与公开测评汇总（非统一标准基准，仅作参考，团队应以内部用例复现为准）：</p><table><thead><tr><th>指标</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td>语法正确性</td><td>相对稳定</td><td>较高</td><td>较高</td></tr><tr><td>逻辑正确性</td><td>中等</td><td>中上</td><td>较高</td></tr><tr><td>最佳实践遵循</td><td>中等</td><td>中上</td><td>较高</td></tr><tr><td>上下文相关性</td><td>中上</td><td>高</td><td>很高</td></tr></tbody></table><h2 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h2><table><thead><tr><th>工具</th><th>平均响应时间</th><th>网络依赖</th></tr></thead><tbody><tr><td>GitHub Copilot</td><td>100-300ms</td><td>高</td></tr><tr><td>Cursor</td><td>200-500ms</td><td>高</td></tr><tr><td>Claude Code</td><td>500-2000ms</td><td>中（仅API调用）</td></tr></tbody></table><h2 id="支持语言覆盖"><a href="#支持语言覆盖" class="headerlink" title="支持语言覆盖"></a>支持语言覆盖</h2><table><thead><tr><th>语言类别</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td>主流语言</td><td>优秀</td><td>优秀</td><td>优秀</td></tr><tr><td>小众语言</td><td>良好</td><td>良好</td><td>一般</td></tr><tr><td>新兴语言</td><td>一般</td><td>良好</td><td>良好</td></tr><tr><td>配置文件</td><td>良好</td><td>良好</td><td>优秀</td></tr></tbody></table><h1 id="工作场景选择指南"><a href="#工作场景选择指南" class="headerlink" title="工作场景选择指南"></a>工作场景选择指南</h1><h2 id="基于开发任务类型的选择"><a href="#基于开发任务类型的选择" class="headerlink" title="基于开发任务类型的选择"></a>基于开发任务类型的选择</h2><h3 id="日常编码和快速开发"><a href="#日常编码和快速开发" class="headerlink" title="日常编码和快速开发"></a>日常编码和快速开发</h3><p><strong>推荐：GitHub Copilot</strong></p><ul><li><strong>适用场景</strong>：<ul><li>编写常见的业务逻辑代码</li><li>实现标准的API接口</li><li>快速原型开发</li><li>学习新的编程语言或框架</li></ul></li><li><strong>优势</strong>：响应快速，建议稳定，学习成本低</li><li><strong>最佳实践</strong>：配合多个编辑器使用，适合快速迭代开发</li></ul><h3 id="大型项目开发和重构"><a href="#大型项目开发和重构" class="headerlink" title="大型项目开发和重构"></a>大型项目开发和重构</h3><p><strong>推荐：Cursor</strong></p><ul><li><strong>适用场景</strong>：<ul><li>多文件协同开发</li><li>代码重构和架构调整</li><li>团队协作开发</li><li>需要理解项目整体结构的开发任务</li></ul></li><li><strong>优势</strong>：项目级理解，多模型支持，可视化界面</li><li><strong>最佳实践</strong>：充分利用聊天功能和多模型切换</li></ul><h3 id="复杂分析和系统级开发"><a href="#复杂分析和系统级开发" class="headerlink" title="复杂分析和系统级开发"></a>复杂分析和系统级开发</h3><p><strong>推荐：Claude Code</strong></p><ul><li><strong>适用场景</strong>：<ul><li>大型代码库分析和重构</li><li>复杂算法实现</li><li>系统架构设计</li><li>跨多个服务的代码修改</li></ul></li><li><strong>优势</strong>：超大上下文，深度理解，自主决策</li><li><strong>最佳实践</strong>：适合处理复杂的、需要深度思考的编程任务</li></ul><h2 id="基于编程语言和技术栈的选择"><a href="#基于编程语言和技术栈的选择" class="headerlink" title="基于编程语言和技术栈的选择"></a>基于编程语言和技术栈的选择</h2><h3 id="主流编程语言和技术栈"><a href="#主流编程语言和技术栈" class="headerlink" title="主流编程语言和技术栈"></a>主流编程语言和技术栈</h3><h4 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h4><table><thead><tr><th>技术栈</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>HTML&#x2F;CSS&#x2F;JavaScript</strong></td><td>GitHub Copilot</td><td>最广泛支持，丰富的代码模式</td><td>Cursor</td></tr><tr><td><strong>React.js</strong></td><td>Cursor</td><td>优秀的组件理解和状态管理</td><td>GitHub Copilot</td></tr><tr><td><strong>Vue.js</strong></td><td>Cursor</td><td>现代前端框架的深度支持</td><td>GitHub Copilot</td></tr><tr><td><strong>Angular</strong></td><td>GitHub Copilot</td><td>企业级框架的成熟支持</td><td>Cursor</td></tr><tr><td><strong>TypeScript</strong></td><td>Cursor</td><td>类型系统的深度理解</td><td>GitHub Copilot</td></tr></tbody></table><h4 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h4><table><thead><tr><th>技术栈</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>Python</strong></td><td>GitHub Copilot</td><td>最成熟的Python生态支持</td><td>Cursor</td></tr><tr><td><strong>Django&#x2F;Flask</strong></td><td>Cursor</td><td>Web框架的项目级理解</td><td>GitHub Copilot</td></tr><tr><td><strong>Node.js</strong></td><td>GitHub Copilot</td><td>JavaScript生态的丰富支持</td><td>Cursor</td></tr><tr><td><strong>Java Spring</strong></td><td>GitHub Copilot</td><td>企业级框架的深度支持</td><td>Cursor</td></tr><tr><td><strong>Go</strong></td><td>Claude Code</td><td>并发模式和微服务架构理解</td><td>GitHub Copilot</td></tr><tr><td><strong>C#&#x2F;.NET</strong></td><td>GitHub Copilot</td><td>微软技术栈的原生支持</td><td>Cursor</td></tr><tr><td><strong>C&#x2F;C++</strong></td><td>Claude Code</td><td>深度理解内存管理和系统编程</td><td>GitHub Copilot</td></tr></tbody></table><h4 id="移动开发"><a href="#移动开发" class="headerlink" title="移动开发"></a>移动开发</h4><table><thead><tr><th>技术栈</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>React Native</strong></td><td>GitHub Copilot</td><td>跨平台开发的成熟支持</td><td>Cursor</td></tr><tr><td><strong>Flutter&#x2F;Dart</strong></td><td>GitHub Copilot</td><td>Google生态的深度集成</td><td>Cursor</td></tr><tr><td><strong>Swift&#x2F;iOS</strong></td><td>GitHub Copilot</td><td>苹果生态的原生支持</td><td>Claude Code</td></tr><tr><td><strong>Kotlin&#x2F;Android</strong></td><td>GitHub Copilot</td><td>Android开发的成熟支持</td><td>Cursor</td></tr><tr><td><strong>Xamarin</strong></td><td>GitHub Copilot</td><td>微软跨平台解决方案</td><td>Cursor</td></tr></tbody></table><h4 id="数据科学与AI"><a href="#数据科学与AI" class="headerlink" title="数据科学与AI"></a>数据科学与AI</h4><table><thead><tr><th>技术栈</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>Python数据科学</strong></td><td>GitHub Copilot</td><td>丰富的科学计算库支持</td><td>Cursor</td></tr><tr><td><strong>R语言</strong></td><td>Claude Code</td><td>统计分析的深度理解</td><td>GitHub Copilot</td></tr><tr><td><strong>Jupyter Notebook</strong></td><td>Cursor</td><td>交互式开发环境的优秀支持</td><td>GitHub Copilot</td></tr><tr><td><strong>TensorFlow&#x2F;PyTorch</strong></td><td>Claude Code</td><td>深度学习框架的复杂理解</td><td>GitHub Copilot</td></tr><tr><td><strong>SQL&#x2F;数据库</strong></td><td>GitHub Copilot</td><td>查询优化和数据操作</td><td>Claude Code</td></tr></tbody></table><h4 id="系统编程与嵌入式"><a href="#系统编程与嵌入式" class="headerlink" title="系统编程与嵌入式"></a>系统编程与嵌入式</h4><table><thead><tr><th>技术栈</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>C语言</strong></td><td>Claude Code</td><td>深度理解底层内存管理和系统调用</td><td>GitHub Copilot</td></tr><tr><td><strong>C++</strong></td><td>Claude Code</td><td>复杂的面向对象和模板编程理解</td><td>GitHub Copilot</td></tr><tr><td><strong>嵌入式C&#x2F;C++</strong></td><td>Claude Code</td><td>理解硬件约束和实时系统要求</td><td>GitHub Copilot</td></tr><tr><td><strong>汇编语言</strong></td><td>Claude Code</td><td>底层硬件操作的深度理解</td><td>GitHub Copilot</td></tr><tr><td><strong>Rust</strong></td><td>Claude Code</td><td>内存安全和系统编程的现代理解</td><td>GitHub Copilot</td></tr></tbody></table><h4 id="系统与运维"><a href="#系统与运维" class="headerlink" title="系统与运维"></a>系统与运维</h4><table><thead><tr><th>技术栈</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>Docker&#x2F;容器化</strong></td><td>GitHub Copilot</td><td>容器化最佳实践</td><td>Cursor</td></tr><tr><td><strong>Kubernetes</strong></td><td>Claude Code</td><td>复杂编排系统的深度理解</td><td>Cursor</td></tr><tr><td><strong>Linux Shell</strong></td><td>GitHub Copilot</td><td>丰富的脚本模式库</td><td>Claude Code</td></tr><tr><td><strong>CI&#x2F;CD管道</strong></td><td>Cursor</td><td>项目级的持续集成理解</td><td>GitHub Copilot</td></tr><tr><td><strong>云平台SDK</strong></td><td>GitHub Copilot</td><td>AWS&#x2F;Azure&#x2F;GCP的API支持</td><td>Cursor</td></tr></tbody></table><h3 id="特殊场景开发"><a href="#特殊场景开发" class="headerlink" title="特殊场景开发"></a>特殊场景开发</h3><table><thead><tr><th>场景</th><th>首选工具</th><th>原因</th><th>备选方案</th></tr></thead><tbody><tr><td><strong>多语言混合项目</strong></td><td>Claude Code</td><td>超大上下文理解跨语言依赖</td><td>Cursor</td></tr><tr><td><strong>算法实现</strong></td><td>Claude Code</td><td>复杂算法逻辑的深度理解</td><td>GitHub Copilot</td></tr><tr><td><strong>系统集成</strong></td><td>Cursor</td><td>项目级理解和架构设计</td><td>Claude Code</td></tr><tr><td><strong>性能优化</strong></td><td>Claude Code</td><td>系统级性能分析能力</td><td>Cursor</td></tr><tr><td><strong>代码重构</strong></td><td>Claude Code</td><td>大规模代码改动的全局理解</td><td>Cursor</td></tr></tbody></table><h2 id="基于开发阶段的选择"><a href="#基于开发阶段的选择" class="headerlink" title="基于开发阶段的选择"></a>基于开发阶段的选择</h2><h3 id="项目初期（0-30-进度）"><a href="#项目初期（0-30-进度）" class="headerlink" title="项目初期（0-30%进度）"></a>项目初期（0-30%进度）</h3><p><strong>推荐：GitHub Copilot + Cursor</strong></p><ul><li><strong>GitHub Copilot</strong>：快速搭建基础代码结构</li><li><strong>Cursor</strong>：项目架构设计和初始化</li><li><strong>策略</strong>：先用Copilot快速开发，再用Cursor整理和优化</li></ul><h3 id="项目中期（30-70-进度）"><a href="#项目中期（30-70-进度）" class="headerlink" title="项目中期（30-70%进度）"></a>项目中期（30-70%进度）</h3><p><strong>推荐：Cursor</strong></p><ul><li><strong>原因</strong>：需要频繁的跨文件操作和功能集成</li><li><strong>优势</strong>：项目级理解能力强，适合功能开发</li><li><strong>策略</strong>：充分利用聊天功能解决复杂问题</li></ul><h3 id="项目后期（70-100-进度）"><a href="#项目后期（70-100-进度）" class="headerlink" title="项目后期（70-100%进度）"></a>项目后期（70-100%进度）</h3><p><strong>推荐：Claude Code + GitHub Copilot</strong></p><ul><li><strong>Claude Code</strong>：代码优化和重构</li><li><strong>GitHub Copilot</strong>：bug修复和细节完善</li><li><strong>策略</strong>：用Claude Code做整体优化，用Copilot处理细节</li></ul><h2 id="基于代码库特征的选择"><a href="#基于代码库特征的选择" class="headerlink" title="基于代码库特征的选择"></a>基于代码库特征的选择</h2><h3 id="新项目开发"><a href="#新项目开发" class="headerlink" title="新项目开发"></a>新项目开发</h3><ul><li><strong>小型项目（&lt;10k行）</strong>：GitHub Copilot</li><li><strong>中型项目（10k-100k行）</strong>：Cursor</li><li><strong>大型项目（&gt;100k行）</strong>：Claude Code + Cursor</li></ul><h3 id="遗留代码维护"><a href="#遗留代码维护" class="headerlink" title="遗留代码维护"></a>遗留代码维护</h3><ul><li><strong>文档完善的项目</strong>：GitHub Copilot</li><li><strong>文档缺失的项目</strong>：Claude Code（强大的代码理解能力）</li><li><strong>需要重构的项目</strong>：Cursor + Claude Code</li></ul><h3 id="多语言项目"><a href="#多语言项目" class="headerlink" title="多语言项目"></a>多语言项目</h3><ul><li><strong>主流语言组合</strong>：GitHub Copilot</li><li><strong>包含小众语言</strong>：Cursor（多模型支持）</li><li><strong>复杂语言交互</strong>：Claude Code（深度理解能力）</li></ul><h1 id="实际使用场景对比"><a href="#实际使用场景对比" class="headerlink" title="实际使用场景对比"></a>实际使用场景对比</h1><h2 id="通用开发任务对比"><a href="#通用开发任务对比" class="headerlink" title="通用开发任务对比"></a>通用开发任务对比</h2><h3 id="前端开发任务"><a href="#前端开发任务" class="headerlink" title="前端开发任务"></a>前端开发任务</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>React组件开发</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>Vue组件开发</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>CSS样式编写</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td><strong>JavaScript逻辑</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>TypeScript开发</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr></tbody></table><h3 id="后端开发任务"><a href="#后端开发任务" class="headerlink" title="后端开发任务"></a>后端开发任务</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>RESTful API</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>数据库操作</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>微服务架构</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>身份认证</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>缓存实现</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr></tbody></table><h3 id="移动开发任务"><a href="#移动开发任务" class="headerlink" title="移动开发任务"></a>移动开发任务</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>React Native</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td><strong>Flutter开发</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>原生iOS开发</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>原生Android</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td><strong>跨平台集成</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr></tbody></table><h3 id="数据科学任务"><a href="#数据科学任务" class="headerlink" title="数据科学任务"></a>数据科学任务</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>数据清洗</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>机器学习模型</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>数据可视化</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td><strong>统计分析</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>深度学习</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table><h3 id="系统编程任务"><a href="#系统编程任务" class="headerlink" title="系统编程任务"></a>系统编程任务</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>系统调用</strong></td><td>⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>内存管理</strong></td><td>⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>并发编程</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>网络编程</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>性能优化</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table><h3 id="运维和工具开发"><a href="#运维和工具开发" class="headerlink" title="运维和工具开发"></a>运维和工具开发</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>Docker配置</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td><strong>自动化脚本</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>CI&#x2F;CD管道</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>监控工具</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>日志分析</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table><h3 id="维护和调试"><a href="#维护和调试" class="headerlink" title="维护和调试"></a>维护和调试</h3><table><thead><tr><th>任务类型</th><th>GitHub Copilot</th><th>Cursor</th><th>Claude Code</th></tr></thead><tbody><tr><td><strong>Bug修复</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>代码审查</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>遗留代码理解</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>架构重构</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>性能分析</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table><h2 id="开发环境适配"><a href="#开发环境适配" class="headerlink" title="开发环境适配"></a>开发环境适配</h2><h3 id="编辑器偏好"><a href="#编辑器偏好" class="headerlink" title="编辑器偏好"></a>编辑器偏好</h3><ul><li><strong>VS Code用户</strong>：<ul><li>首选：Cursor（原生体验）</li><li>备选：GitHub Copilot（插件形式）</li></ul></li><li><strong>JetBrains用户</strong>：<ul><li>首选：GitHub Copilot（官方支持好）</li><li>备选：Claude Code（插件支持）</li></ul></li><li><strong>Vim&#x2F;Neovim用户</strong>：<ul><li>首选：GitHub Copilot（插件支持）</li><li>备选：Claude Code（终端友好）</li></ul></li><li><strong>多编辑器用户</strong>：<ul><li>首选：GitHub Copilot（广泛支持）</li><li>备选：Claude Code（编辑器无关）</li></ul></li></ul><h3 id="操作系统适配"><a href="#操作系统适配" class="headerlink" title="操作系统适配"></a>操作系统适配</h3><ul><li><strong>macOS</strong>：三个工具都有良好支持</li><li><strong>Windows</strong>：GitHub Copilot和Cursor支持最好</li><li><strong>Linux</strong>：Claude Code和GitHub Copilot支持较好</li></ul><h2 id="工作流程集成"><a href="#工作流程集成" class="headerlink" title="工作流程集成"></a>工作流程集成</h2><h3 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h3><ul><li><strong>GitHub Flow</strong>：GitHub Copilot（原生集成）</li><li><strong>GitLab Flow</strong>：Cursor（通用性好）</li><li><strong>复杂分支策略</strong>：Claude Code（深度理解）</li></ul><h3 id="CI-CD集成"><a href="#CI-CD集成" class="headerlink" title="CI&#x2F;CD集成"></a>CI&#x2F;CD集成</h3><ul><li><strong>GitHub Actions</strong>：GitHub Copilot</li><li><strong>Jenkins&#x2F;GitLab CI</strong>：Cursor</li><li><strong>复杂部署流程</strong>：Claude Code</li></ul><h1 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h1><h2 id="学习路径建议"><a href="#学习路径建议" class="headerlink" title="学习路径建议"></a>学习路径建议</h2><h3 id="新手开发者"><a href="#新手开发者" class="headerlink" title="新手开发者"></a>新手开发者</h3><ol><li><strong>第一阶段</strong>：GitHub Copilot（学习AI辅助编程基础）</li><li><strong>第二阶段</strong>：Cursor（体验项目级AI支持）</li><li><strong>第三阶段</strong>：Claude Code（掌握高级AI编程技巧）</li></ol><h3 id="有经验开发者"><a href="#有经验开发者" class="headerlink" title="有经验开发者"></a>有经验开发者</h3><ol><li><strong>评估阶段</strong>：同时试用三个工具，找到最适合的</li><li><strong>专精阶段</strong>：深度掌握选定工具的高级功能</li><li><strong>组合阶段</strong>：根据不同场景灵活切换工具</li></ol><h2 id="团队采用建议"><a href="#团队采用建议" class="headerlink" title="团队采用建议"></a>团队采用建议</h2><h3 id="渐进式采用策略"><a href="#渐进式采用策略" class="headerlink" title="渐进式采用策略"></a>渐进式采用策略</h3><ol><li><strong>试点阶段</strong>：选择1-2个开发者先行试用</li><li><strong>评估阶段</strong>：收集使用反馈，评估效果</li><li><strong>推广阶段</strong>：逐步扩大使用范围</li><li><strong>标准化阶段</strong>：制定团队使用规范</li></ol><h3 id="培训和支持"><a href="#培训和支持" class="headerlink" title="培训和支持"></a>培训和支持</h3><ul><li><strong>基础培训</strong>：AI编程基础概念和最佳实践</li><li><strong>工具培训</strong>：具体工具的使用方法和技巧</li><li><strong>持续支持</strong>：建立内部知识分享机制</li></ul><h2 id="高级开发场景建议"><a href="#高级开发场景建议" class="headerlink" title="高级开发场景建议"></a>高级开发场景建议</h2><h3 id="安全性和合规性考虑"><a href="#安全性和合规性考虑" class="headerlink" title="安全性和合规性考虑"></a>安全性和合规性考虑</h3><ul><li><strong>代码隐私</strong>：对于涉及商业机密的关键代码，优先选择本地运行的AI工具</li><li><strong>合规要求</strong>：遵循行业安全标准和法规，AI生成的代码需要严格审查</li><li><strong>知识产权</strong>：避免将专有算法和核心技术通过云端AI工具处理</li><li><strong>数据安全</strong>：处理敏感数据的代码开发时，选择符合数据保护要求的工具</li></ul><h3 id="性能和优化要求"><a href="#性能和优化要求" class="headerlink" title="性能和优化要求"></a>性能和优化要求</h3><ul><li><strong>高性能计算</strong>：科学计算、图像处理等性能敏感代码，建议使用Claude Code深度分析</li><li><strong>内存优化</strong>：资源受限环境的开发，需要人工审查AI生成的代码</li><li><strong>并发处理</strong>：多线程、异步编程等复杂并发场景，利用AI工具的深度理解能力</li><li><strong>算法优化</strong>：复杂算法实现，选择具备数学和算法理解能力的AI工具</li></ul><h3 id="企业级开发协作"><a href="#企业级开发协作" class="headerlink" title="企业级开发协作"></a>企业级开发协作</h3><ul><li><strong>微服务架构</strong>：使用Cursor理解服务间接口和依赖关系</li><li><strong>系统集成</strong>：利用Claude Code的大上下文能力理解整个系统架构</li><li><strong>版本管理</strong>：多团队、多模块的代码版本同步，需要项目级理解能力</li><li><strong>API设计</strong>：复杂API设计和文档生成，选择理解能力强的AI工具</li></ul><h3 id="质量保证策略"><a href="#质量保证策略" class="headerlink" title="质量保证策略"></a>质量保证策略</h3><ul><li><strong>单元测试</strong>：AI工具生成的测试用例需要覆盖边界条件和异常情况</li><li><strong>集成测试</strong>：跨模块功能测试，建议使用Cursor理解测试框架</li><li><strong>性能测试</strong>：AI辅助的性能测试脚本编写和结果分析</li><li><strong>代码审查</strong>：利用AI工具进行代码质量检查和最佳实践建议</li></ul><h3 id="技术债务管理"><a href="#技术债务管理" class="headerlink" title="技术债务管理"></a>技术债务管理</h3><ul><li><strong>遗留系统重构</strong>：使用Claude Code理解复杂的遗留代码逻辑</li><li><strong>架构演进</strong>：利用Cursor的项目级理解能力进行架构升级</li><li><strong>依赖管理</strong>：AI辅助分析和更新项目依赖关系</li><li><strong>文档维护</strong>：自动生成和更新技术文档</li></ul><h1 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h1><h2 id="总体结论"><a href="#总体结论" class="headerlink" title="总体结论"></a>总体结论</h2><p>基于深入的功能分析和实际使用场景对比，三款AI编码工具各有明确的优势领域：</p><ul><li><strong>GitHub Copilot</strong>：最适合日常编码和快速开发，稳定可靠，学习成本低</li><li><strong>Cursor</strong>：最适合大型项目开发和团队协作，项目级理解能力强，功能集成度高</li><li><strong>Claude Code</strong>：最适合复杂分析和系统级开发，上下文理解能力最强，适合高级开发者</li></ul><h2 id="核心选择原则"><a href="#核心选择原则" class="headerlink" title="核心选择原则"></a>核心选择原则</h2><h3 id="按工作复杂度选择"><a href="#按工作复杂度选择" class="headerlink" title="按工作复杂度选择"></a>按工作复杂度选择</h3><ul><li><strong>简单任务</strong>：GitHub Copilot（快速高效）</li><li><strong>中等复杂度</strong>：Cursor（平衡性好）</li><li><strong>高复杂度</strong>：Claude Code（深度理解）</li></ul><h3 id="按项目规模选择"><a href="#按项目规模选择" class="headerlink" title="按项目规模选择"></a>按项目规模选择</h3><ul><li><strong>小型项目</strong>：GitHub Copilot</li><li><strong>中大型项目</strong>：Cursor</li><li><strong>超大型项目</strong>：Claude Code + Cursor组合</li></ul><h3 id="按团队特征选择"><a href="#按团队特征选择" class="headerlink" title="按团队特征选择"></a>按团队特征选择</h3><ul><li><strong>新手团队</strong>：GitHub Copilot（学习成本低）</li><li><strong>成熟团队</strong>：Cursor（效率提升明显）</li><li><strong>专家团队</strong>：Claude Code（充分发挥高级能力）</li></ul><h2 id="实施建议"><a href="#实施建议" class="headerlink" title="实施建议"></a>实施建议</h2><h3 id="个人开发者"><a href="#个人开发者" class="headerlink" title="个人开发者"></a>个人开发者</h3><ol><li><strong>起步阶段</strong>：从GitHub Copilot开始，建立AI编程习惯</li><li><strong>进阶阶段</strong>：根据项目需要尝试Cursor或Claude Code</li><li><strong>成熟阶段</strong>：形成个人的工具组合使用策略</li></ol><h3 id="团队采用"><a href="#团队采用" class="headerlink" title="团队采用"></a>团队采用</h3><ol><li><strong>统一标准</strong>：选择一个主要工具作为团队标准</li><li><strong>分层使用</strong>：不同角色可以使用不同的辅助工具</li><li><strong>持续评估</strong>：定期评估工具效果，适时调整策略</li></ol><h3 id="企业级部署"><a href="#企业级部署" class="headerlink" title="企业级部署"></a>企业级部署</h3><ol><li><strong>安全评估</strong>：优先考虑数据安全和隐私保护</li><li><strong>成本控制</strong>：制定合理的使用策略和预算规划</li><li><strong>培训体系</strong>：建立完善的培训和支持体系</li></ol><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>随着AI技术的快速发展，建议：</p><ol><li><strong>保持开放心态</strong>：持续关注新工具和新功能</li><li><strong>灵活调整策略</strong>：根据技术发展适时调整工具选择</li><li><strong>投资学习</strong>：持续提升AI辅助编程的技能水平</li></ol><p><strong>最终建议</strong>：没有一个工具能够完美适应所有场景，最佳策略是根据具体的工作内容、项目特点和个人偏好，灵活选择和组合使用这些AI编码工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：模型决定下限，Agent决定上限&quot;&gt;&lt;a href=&quot;#前言：模型决定下限，Agent决定上限&quot; class=&quot;headerlink&quot; title=&quot;前言：模型决定下限，Agent决定上限&quot;&gt;&lt;/a&gt;前言：模型决定下限，Agent决定上限&lt;/h1&gt;&lt;p&gt;在深</summary>
      
    
    
    
    <category term="AI" scheme="https://www.silenceboy.com/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.silenceboy.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>SSE与Streamable HTTP：MCP 背后的传输技术</title>
    <link href="https://www.silenceboy.com/2025/08/27/SSE%E4%B8%8EStreamable-HTTP%EF%BC%9AMCP-%E8%83%8C%E5%90%8E%E7%9A%84%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.silenceboy.com/2025/08/27/SSE%E4%B8%8EStreamable-HTTP%EF%BC%9AMCP-%E8%83%8C%E5%90%8E%E7%9A%84%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/</id>
    <published>2025-08-27T03:06:46.000Z</published>
    <updated>2025-08-27T06:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MCP-使用的传输协议背后的历史"><a href="#MCP-使用的传输协议背后的历史" class="headerlink" title="MCP 使用的传输协议背后的历史"></a>MCP 使用的传输协议背后的历史</h1><p>MCP（模型上下文协议）是当今最流行、应用最广泛的人工智能协议之一，它从 2025-03-26 版本开始，用 <code>Streamable HTTP</code> 取代了 <code>HTTP+SSE</code> 传输机制。这标志着该协议架构的重大变革。</p><p>现在，在解释这两种传输机制的含义之前，让我们先更好地理解这一变化。</p><h2 id="为什么AI协议需要传输机制"><a href="#为什么AI协议需要传输机制" class="headerlink" title="为什么AI协议需要传输机制"></a>为什么AI协议需要传输机制</h2><p>像 MCP 这样的 AI 协议需要传输机制来促进协议架构中不同组件之间的信息交换。</p><p>具体来说，MCP 使用 <code>JSON-RPC 2.0</code> 作为客户端和服务器之间的连接格式。对于 <code>JSON-RPC</code> 消息的传输，它依赖于标准传输机制，如 <code>HTTP+SSE</code> 或 <code>Streamable HTTP</code>（在 stdio 中 - 用于通过本地服务器上的标准输入和标准输出进行通信）。</p><p>这些专用的传输层是必需的，因为传统 HTTP 的请求-响应模型对于实时 AI 通信来说效率低下。这是因为纯 HTTP 频繁建立连接会导致高开销和延迟。相比之下，MCP 需要连续、低延迟的数据流——<code>HTTP+SSE</code> 和 <code>Streamable HTTP</code> 正是为此而设计的。</p><h2 id="为什么从-SSE-转变到-Streamable-HTTP"><a href="#为什么从-SSE-转变到-Streamable-HTTP" class="headerlink" title="为什么从 SSE 转变到 Streamable HTTP"></a>为什么从 <code>SSE</code> 转变到 <code>Streamable HTTP</code></h2><p>MCP 最初使用 <code>HTTP+SSE</code> 来实现远程场景下的服务器到客户端的流式传输。然而，以下三个主要限制使得这一改变变得合理：</p><ul><li><strong>不支持可恢复流</strong>：无法从断开处恢复数据流。</li><li><strong>需要维护长连接</strong>：服务器需要维护长时间的、高可用的连接，消耗资源，尤其是在大 规模部署时。</li><li><strong>仅允许通过 SSE 传递服务器消息</strong>：客户端必须使用单独的 HTTP POST 请求发送消息， 无法在同一通道内双向通信。</li></ul><p><code>Streamable HTTP</code> 解决了这些问题。它支持无状态通信，甚至支持按需升级到 <code>SSE</code>。这提高了与现代基础设施的兼容性，并确保了更稳定、更高效的通信。同时，这一转变体现了 MCP 在追求以下目标：</p><ul><li><strong>提升可伸缩性</strong>：通过支持无状态服务器和减少长连接依赖，MCP 能够更好地应对大规模并发请求，为 AI 服务的爆发式增长提供坚实基础。</li><li><strong>增强鲁棒性</strong>：可恢复流的引入，使得 MCP 在面对不稳定的网络环境时，依然能够保证数据传输的可靠性，减少因网络问题导致的数据丢失或服务中断。</li><li><strong>优化资源利用</strong>：减少长连接的维护成本，使得服务器资源能够更高效地分配和利用，降低运营成本。</li><li><strong>拥抱未来趋势</strong>：Streamable HTTP 与现代 Web 技术栈和云原生架构更加契合，为 MCP 未来的发展和与其他技术的融合提供了更广阔的空间。</li></ul><h1 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h1><p><code>SSE</code>（Server-Sent Events）是一种允许 Web 客户端从服务器接收自动更新的机制。这些更新被称为“事件”，并通过单个长寿命 HTTP 连接发送。</p><p>与<code>WebSockets</code> 不同，<code>SSE</code> 是单向的，这意味着数据仅从服务器流向客户端。SSE 的工作原理是服务器通过此开放连接发送事件流，通常格式为<code>text/event-stream</code>MIME类型。</p><h2 id="在-MCP-中使用-HTTP-SSE"><a href="#在-MCP-中使用-HTTP-SSE" class="headerlink" title="在 MCP 中使用 HTTP+SSE"></a>在 <code>MCP</code> 中使用 <code>HTTP+SSE</code></h2><p><img src="/../images/sse.png" alt="sse"></p><p>服务器必须提供两个端点：</p><ol><li>客户端用于建立连接并从服务器接收消息的 <code>SSE GET</code> 端点。</li><li>客户端向服务器发送 <code>JSON-RPC</code> 消息的常规 <code>HTTP POST</code> 端点。</li></ol><p>当客户端连接时，服务器必须发送一个端点事件，其中包含客户端将用于发送消息的 URI。所有客户端 <code>JSON-RPC</code> 消息都将作为 <code>HTTP POST</code> 请求发送到此 URI。</p><p>服务器通过打开的 <code>SSE</code> 连接发送流式事件来响应，模拟持久会话。具体来说，服务器消息以 <code>SSE</code> 消息事件的形式传递，其内容在事件数据中以 JSON 格式编码。</p><p>对于单个响应，服务器发送消息并关闭流。对于正在进行的通信，连接保持打开状态。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p><ul><li>流式传输大量结果：允许立即发送部分结果，允许立即发送部分结果，避免 <code>MCP</code> 工具处理大量数据或等待外部 API 响应时的延迟。</li><li>事件驱动触发器：支持未经请求的服务器事件，通过警报或状态更新通知客户端有关更改。</li><li>简单：使用标准 HTTP，无需特殊协议或复杂设置。</li></ul><p>缺点：</p><ul><li>仅限单向：数据只能在 SSE 通道中从服务器流向客户端。客户端必须使用单独的 <code>HTTP POST</code> 请求来发送消息。</li><li>长连接资源使用：维护开放连接会消耗大量服务器资源，尤其是在大规模连接时。</li></ul><h1 id="Streamable-HTTP"><a href="#Streamable-HTTP" class="headerlink" title="Streamable HTTP"></a>Streamable HTTP</h1><p>在 <code>MCP</code> 的语境中，<code>Streamable HTTP</code> 是一种使用纯 HTTP 在客户端和服务器之间传输流式数据的方法。它为实时通信打开了大门，无需长连接。</p><p>虽然它仍然可以使用 <code>SSE</code> 来实现灵活性和向后兼容性，但不再需要该传输方式。这使得 MCP 能够支持无状态服务器，而无需维护高可用性持久连接的开销。</p><blockquote><p>为什么是Streamable HTTP + 可选 SSE 而不是 WebSockets？</p><ol><li>避免不必要的开销：对于简单的 RPC 调用或数据流，WebSocket 的全双工特性可能引入不必要的协议开销和复杂性。Streamable HTTP 在保持流式传输能力的同时，更加轻量。</li><li>更好的 HTTP 兼容性：WebSocket 的协议升级机制有时会与现有的 HTTP 基础设施（如代理、负载均衡器）产生兼容性问题，并且浏览器无法直接在 WebSocket 连接上附加 HTTP 头（如 Authorization）。Streamable HTTP 则完全兼容 HTTP，避免了这些问题。</li><li>POST 请求的灵活性：WebSocket 的升级握手主要基于 GET 请求，这使得基于 POST 的复杂交互流程实现起来较为繁琐。Streamable HTTP 则对 POST 和 GET 请求都提供了良好的支持。</li></ol></blockquote><h2 id="在-MCP-中使用-Streamable-HTTP"><a href="#在-MCP-中使用-Streamable-HTTP" class="headerlink" title="在 MCP 中使用 Streamable HTTP"></a>在 <code>MCP</code> 中使用 <code>Streamable HTTP</code></h2><p>在 <code>Streamable HTTP</code> 传输中，服务器作为一个独立进程，能够处理多个客户端连接。它使用标准的 HTTP <code>POST</code> 和 <code>GET</code> 请求进行通信。</p><p>服务器可以选择使用 <code>SSE</code> 将多条消息流式传输到客户端。这既适用于用于简单请求&#x2F;响应工具的基本 MCP 服务器，也适用于提供更高级功能（例如流式传输和实时服务器到客户端通知）的服务器。</p><p>服务器必须公开一个支持 <code>POST</code> 和 <code>GET</code> 方法的 HTTP 端点（称为 “MCP 端点“）。</p><p>下图说明了使用 <code>Streamable HTTP</code> 的 MCP 客户端和服务器之间的通信流程：</p><p><img src="/../images/streamable-http.png" alt="streamable-http"></p><p>为了支持恢复断开的连接并重新传递可能丢失的消息，MCP 服务器会为每个流分配 ID。这些 ID 在每个流中充当游标。</p><h2 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p><ul><li>支持无状态服务器：无需始终在线的长连接。</li><li>纯 HTTP：可以使用任何标准 HTTP 服务器实现，而无需 <code>SSE</code>。</li><li>基础设施友好：与常见的 HTTP 中间件、代理和托管平台兼容。</li><li>向后兼容：在以前的 <code>HTTP+SSE</code> 传输基础上逐步构建。</li><li>可选流式传输：服务器可在需要时升级为 <code>SSE</code>，以实现流式传输响应。</li><li>解决 SSE 局限性：支持可恢复流，无需维护长连接，且允许客户端和服务器在同一 HTTP 端点进行通信（通过 POST 和 GET）。</li><li>效率更高：对于大负载或自定义二进制协议，数据传输更高效，没有 SSE 的事件格式 开销。</li><li>更强的控制力：应用可以更精细地控制缓冲策略，可能减少内存开销。</li></ul><p>缺点：</p><ul><li>暂无</li></ul><h1 id="SSE-与Streamable-HTTP对比"><a href="#SSE-与Streamable-HTTP对比" class="headerlink" title="SSE 与Streamable HTTP对比"></a>SSE 与Streamable HTTP对比</h1><table><thead><tr><th>类型</th><th>HTTP+SSE</th><th>Streamable HTTP</th></tr></thead><tbody><tr><td>通信类型</td><td>单向（服务器→客户端）</td><td>双向（客户端通过 GET&#x2F;POST ↔ 服务器）</td></tr><tr><td>HTTP 协议的使用</td><td>GET 用于流媒体，POST 用于客户端信息</td><td>从一个端点使用标准 HTTP POST 和 GET</td></tr><tr><td>状态性</td><td>有状态</td><td>有状态，但支持无状态服务器</td></tr><tr><td>需要长期 HTTP 连接</td><td>是</td><td>否</td></tr><tr><td>要求高可用性</td><td>是，用于连接持久性</td><td>否，适用于无状态或临时服务器</td></tr><tr><td>可扩展性</td><td>有限</td><td>高</td></tr><tr><td>流媒体支持</td><td>是（通过文本&#x2F;事件流）</td><td>是（通过 SSE 作为可选增强功能）</td></tr><tr><td>身份验证支持</td><td>是</td><td>是</td></tr><tr><td>支持可恢复性和重新交付</td><td>没有</td><td>没有</td></tr><tr><td>客户数量</td><td>多个</td><td>多个</td></tr><tr><td>在 MCP 中的使用</td><td>自协议版本 2025-03-26 起已弃用</td><td>在 2025-03-26 版协议中引入</td></tr><tr><td>向后兼容性</td><td>-</td><td>完全向后兼容基于 SSE 的客户端</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MCP-使用的传输协议背后的历史&quot;&gt;&lt;a href=&quot;#MCP-使用的传输协议背后的历史&quot; class=&quot;headerlink&quot; title=&quot;MCP 使用的传输协议背后的历史&quot;&gt;&lt;/a&gt;MCP 使用的传输协议背后的历史&lt;/h1&gt;&lt;p&gt;MCP（模型上下文协议）是当</summary>
      
    
    
    
    <category term="mcp" scheme="https://www.silenceboy.com/categories/mcp/"/>
    
    
    <category term="AI" scheme="https://www.silenceboy.com/tags/AI/"/>
    
    <category term="mcp" scheme="https://www.silenceboy.com/tags/mcp/"/>
    
  </entry>
  
  <entry>
    <title>命令帮手：tldr 安装与中文配置指南</title>
    <link href="https://www.silenceboy.com/2025/05/09/%E5%91%BD%E4%BB%A4%E5%B8%AE%E6%89%8B%EF%BC%9Atldr-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%B8%AD%E6%96%87%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>https://www.silenceboy.com/2025/05/09/%E5%91%BD%E4%BB%A4%E5%B8%AE%E6%89%8B%EF%BC%9Atldr-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%B8%AD%E6%96%87%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</id>
    <published>2025-05-09T05:39:38.000Z</published>
    <updated>2025-05-09T05:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发与运维过程中，你是否会觉得传统的 man 手册过于繁琐？<a href="https://tldr.sh/">tldr</a> 项目正是为了解决这个问题而生，它为上百个常用命令提供了简明直观的示例，极大地提升了查阅效率。本文将手把手介绍 tldr 在 Windows、Mac、Ubuntu 下的安装流程，基本使用方法，以及如何让 tldr 输出为简体中文。</p><h2 id="一、tldr-安装方法"><a href="#一、tldr-安装方法" class="headerlink" title="一、tldr 安装方法"></a>一、tldr 安装方法</h2><h3 id="1-Windows-系统"><a href="#1-Windows-系统" class="headerlink" title="1. Windows 系统"></a>1. Windows 系统</h3><h4 id="方法一：用-Scoop-安装（推荐）"><a href="#方法一：用-Scoop-安装（推荐）" class="headerlink" title="方法一：用 Scoop 安装（推荐）"></a>方法一：用 Scoop 安装（推荐）</h4><ol><li><p>安装 <a href="https://scoop.sh/">Scoop</a>（如果还没装）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="built_in">irm</span> get.scoop.sh | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure></li><li><p>安装 tldr：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install tldr</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法二：用-npm-安装"><a href="#方法二：用-npm-安装" class="headerlink" title="方法二：用 npm 安装"></a>方法二：用 npm 安装</h4><p>需先装好 <a href="https://nodejs.org/">Node.js</a> 与 npm，然后在命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> tldr</span><br></pre></td></tr></table></figure><h4 id="方法三：用-pip-安装"><a href="#方法三：用-pip-安装" class="headerlink" title="方法三：用 pip 安装"></a>方法三：用 pip 安装</h4><p>需先装好python与pip，然后在命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><h3 id="2-macOS-系统"><a href="#2-macOS-系统" class="headerlink" title="2. macOS 系统"></a>2. macOS 系统</h3><p>推荐使用 <a href="https://brew.sh/">Homebrew</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tldr</span><br></pre></td></tr></table></figure><p>或者用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tldr</span><br></pre></td></tr></table></figure><p>或者用 pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><h3 id="3-Ubuntu-Debian-系统"><a href="#3-Ubuntu-Debian-系统" class="headerlink" title="3. Ubuntu &#x2F; Debian 系统"></a>3. Ubuntu &#x2F; Debian 系统</h3><p>推荐方式（snap 安装）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install tldr</span><br></pre></td></tr></table></figure><p>或者用 apt（部分老版本仓库没有）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install tldr</span><br></pre></td></tr></table></figure><p>还可以用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tldr</span><br></pre></td></tr></table></figure><p>或者用 pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><h2 id="二、tldr-的基本使用"><a href="#二、tldr-的基本使用" class="headerlink" title="二、tldr 的基本使用"></a>二、tldr 的基本使用</h2><p>安装好 tldr 后，在命令行中直接输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr 命令名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr tar</span><br></pre></td></tr></table></figure><p>它会显示 tar 常用的简要用法和示例。</p><p>常用选项：</p><ul><li><code>tldr -u</code><br>强制更新离线文档缓存。</li><li><code>tldr --list</code><br>查看有哪些命令有 tldr 页面。</li><li><code>tldr --help</code><br>查看 tldr 的详细帮助信息。</li></ul><h2 id="三、配置-tldr-显示中文页面"><a href="#三、配置-tldr-显示中文页面" class="headerlink" title="三、配置 tldr 显示中文页面"></a>三、配置 tldr 显示中文页面</h2><p>tldr 官方已支持多语言，目前大部分主流命令已有简体中文文档。只需调整默认语言环境变量即可。</p><h3 id="1-临时使用中文"><a href="#1-临时使用中文" class="headerlink" title="1. 临时使用中文"></a>1. 临时使用中文</h3><p>只对当前命令生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=zh tldr <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>或（部分 tldr 客户端支持）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE=zh tldr <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="2-永久设置为中文"><a href="#2-永久设置为中文" class="headerlink" title="2. 永久设置为中文"></a>2. 永久设置为中文</h3><h4 id="macOS-Ubuntu-WSL"><a href="#macOS-Ubuntu-WSL" class="headerlink" title="macOS &#x2F; Ubuntu &#x2F; WSL"></a>macOS &#x2F; Ubuntu &#x2F; WSL</h4><p>将下方内容添加到 <code>~/.bashrc</code> 或 <code>~/.zshrc</code>（具体看你用哪个 shell）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=zh</span><br></pre></td></tr></table></figure><p>保存后，执行一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc    <span class="comment"># 或 source ~/.zshrc</span></span><br></pre></td></tr></table></figure><p>这样每次开新终端，tldr 默认输出中文页面。</p><h4 id="Windows（CMD-或-PowerShell）"><a href="#Windows（CMD-或-PowerShell）" class="headerlink" title="Windows（CMD 或 PowerShell）"></a>Windows（CMD 或 PowerShell）</h4><p><strong>CMD 中临时生效：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> LANG=zh</span><br><span class="line">tldr ls</span><br></pre></td></tr></table></figure><p><strong>长期生效</strong>：<br>在系统环境变量或用户环境变量中添加 <code>LANG</code>，值填 <code>zh</code>。</p><h3 id="3-更新缓存（非常重要）"><a href="#3-更新缓存（非常重要）" class="headerlink" title="3. 更新缓存（非常重要）"></a>3. 更新缓存（非常重要）</h3><p>修改语言后，强烈建议刷新缓存让中文页面生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr -u</span><br></pre></td></tr></table></figure><h3 id="4-验证效果"><a href="#4-验证效果" class="headerlink" title="4. 验证效果"></a>4. 验证效果</h3><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr <span class="built_in">cp</span></span><br></pre></td></tr></table></figure><p>如果出现中文简明用法，表明配置成功。</p><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><ul><li><strong>部分命令还是英文？</strong><br>可能该命令尚未有中文翻译。同样建议及时更新缓存。</li><li><strong>未知命令提示或无法联网？</strong><br>检查网络或采用 <code>tldr --update</code> 手动补全离线缓存。</li><li><strong>Windows 环境变量生效问题？</strong><br>尝试重启终端或电脑，确认语言变量设置无误。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>tldr 是极简而实用的命令行速查工具，无论软件开发者还是 Linux&#x2F;Unix&#x2F;Windows 运维者都能从中获益。通过简单的安装和配置，你就能轻松查阅常见命令的简明用法，还能设为汉语输出，降低理解难度，为高效开发助力。</p><blockquote><p><strong>扩展阅读：</strong></p><ul><li>官方网站：<a href="https://tldr.sh/">https://tldr.sh/</a></li><li>GitHub 项目：<a href="https://github.com/tldr-pages/tldr">https://github.com/tldr-pages/tldr</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发与运维过程中，你是否会觉得传统的 man 手册过于繁琐？&lt;a href=&quot;https://tldr.sh/&quot;&gt;tldr&lt;/a&gt; 项目正是为了解决这个问题而生，它为上百个常用命令提供了简明直观的示例，极大地提升了查阅效率。本文将手把手介绍 tldr 在 Window</summary>
      
    
    
    
    <category term="shell" scheme="https://www.silenceboy.com/categories/shell/"/>
    
    
    <category term="shell" scheme="https://www.silenceboy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Python魔法方法介绍</title>
    <link href="https://www.silenceboy.com/2025/04/25/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.silenceboy.com/2025/04/25/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-04-25T06:34:11.000Z</published>
    <updated>2025-04-25T06:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是魔法方法"><a href="#1-什么是魔法方法" class="headerlink" title="1. 什么是魔法方法"></a>1. 什么是魔法方法</h2><p>魔法方法是指<strong>前后都有双下划线</strong>的特殊方法，例如 <strong>init</strong>、<strong>new</strong>、<strong>str</strong> 等。这些方法是 Python 内部预定义的，将它们以特定名字命名，是为了配合 Python 的特性（如对象创建、属性访问、运算符重载等）实现自定义行为。</p><h2 id="2-常见魔法方法类别与功能"><a href="#2-常见魔法方法类别与功能" class="headerlink" title="2. 常见魔法方法类别与功能"></a>2. 常见魔法方法类别与功能</h2><h3 id="a-对象的构造与销毁"><a href="#a-对象的构造与销毁" class="headerlink" title="a) 对象的构造与销毁"></a>a) 对象的构造与销毁</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>常用场景</th></tr></thead><tbody><tr><td><code>__new__</code></td><td>实例创建，返回一个新对象</td><td>单例、元类、自定义创建流程</td></tr><tr><td><code>__init__</code></td><td>实例初始化，设置属性等</td><td>常规对象初始化</td></tr><tr><td><code>__del__</code></td><td>实例删除前调用（析构函数）</td><td>资源释放、日志等</td></tr></tbody></table><h3 id="b-字符串与可打印表现"><a href="#b-字符串与可打印表现" class="headerlink" title="b) 字符串与可打印表现"></a>b) 字符串与可打印表现</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>常用场景</th></tr></thead><tbody><tr><td><code>__str__</code></td><td>str(obj)、print(obj) 时的表现</td><td>用户友好信息</td></tr><tr><td><code>__repr__</code></td><td>repr(obj)、调试器、解释器中直接输入对象时的表现</td><td>开发调试、复现对象</td></tr></tbody></table><h3 id="c-运算符重载"><a href="#c-运算符重载" class="headerlink" title="c) 运算符重载"></a>c) 运算符重载</h3><p>使实例自定义如何参与各种运算：</p><table><thead><tr><th>魔法方法</th><th>覆盖的运算符</th><th>例子</th></tr></thead><tbody><tr><td><code>__add__</code></td><td>+</td><td>a + b</td></tr><tr><td><code>__sub__</code></td><td>-</td><td>a - b</td></tr><tr><td><code>__mul__</code></td><td>*</td><td>a * b</td></tr><tr><td><code>__truediv__</code></td><td>&#x2F;</td><td>a &#x2F; b</td></tr><tr><td><code>__floordiv__</code></td><td>&#x2F;&#x2F;</td><td>a &#x2F;&#x2F; b</td></tr><tr><td><code>__mod__</code></td><td>%</td><td>a % b</td></tr><tr><td><code>__pow__</code></td><td>**</td><td>a ** b</td></tr><tr><td><code>__eq__</code></td><td>&#x3D;&#x3D;</td><td>a &#x3D;&#x3D; b</td></tr><tr><td><code>__ne__</code></td><td>!&#x3D;</td><td>a !&#x3D; b</td></tr><tr><td><code>__lt__</code></td><td>&lt;</td><td>a &lt; b</td></tr><tr><td><code>__gt__</code></td><td>&gt;</td><td>a &gt; b</td></tr><tr><td><code>__le__</code></td><td>&lt;&#x3D;</td><td>a &lt;&#x3D; b</td></tr></tbody></table><p>还有很多，比如逻辑运算（<code>__and__</code>, <code>__or__</code> 等）、反向运算（如 <code>__radd__</code>)等。</p><h3 id="d-集合与映射接口"><a href="#d-集合与映射接口" class="headerlink" title="d) 集合与映射接口"></a>d) 集合与映射接口</h3><p>用于容器类的自定义：</p><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>使用方式</th></tr></thead><tbody><tr><td><code>__len__</code></td><td>求长度</td><td>len(obj)</td></tr><tr><td><code>__getitem__</code></td><td>获取指定元素</td><td>obj[key]</td></tr><tr><td><code>__setitem__</code></td><td>设置值</td><td>obj[key]&#x3D;value</td></tr><tr><td><code>__delitem__</code></td><td>删除项</td><td>del obj[key]</td></tr><tr><td><code>__contains__</code></td><td>in&#x2F;not in 查询</td><td>item in obj</td></tr><tr><td><code>__iter__</code></td><td>返回迭代器</td><td>for x in obj</td></tr><tr><td><code>__next__</code></td><td>迭代器的下一个值</td><td>next(iterator)</td></tr></tbody></table><h3 id="e-上下文管理"><a href="#e-上下文管理" class="headerlink" title="e) 上下文管理"></a>e) 上下文管理</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>使用方式</th></tr></thead><tbody><tr><td><code>__enter__</code></td><td>进入上下文、with块前调用</td><td>with obj as xxx</td></tr><tr><td><code>__exit__</code></td><td>离开上下文、with块后调用</td><td></td></tr></tbody></table><h3 id="f-可调用对象相关"><a href="#f-可调用对象相关" class="headerlink" title="f) 可调用对象相关"></a>f) 可调用对象相关</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>示例</th></tr></thead><tbody><tr><td><code>__call__</code></td><td>让实例像函数一样可调用</td><td>obj()</td></tr></tbody></table><h3 id="g-其他常用魔法方法"><a href="#g-其他常用魔法方法" class="headerlink" title="g) 其他常用魔法方法"></a>g) 其他常用魔法方法</h3><ul><li><code>__getattr__</code> &#x2F; <code>__setattr__</code> &#x2F; <code>__delattr__</code>：属性访问&#x2F;设置&#x2F;删除拦截。</li><li><code>__slots__</code>：限制对象可以有哪些属性，提高内存效率。</li></ul><h2 id="3-魔法方法功能对比表"><a href="#3-魔法方法功能对比表" class="headerlink" title="3. 魔法方法功能对比表"></a>3. 魔法方法功能对比表</h2><table><thead><tr><th>方法</th><th>调用时机&#x2F;作用</th><th>返回值须</th><th>是否常用</th></tr></thead><tbody><tr><td><code>__new__</code></td><td>创建对象（类-&gt;实例）</td><td>实例 or 其子类</td><td>部分场景</td></tr><tr><td><code>__init__</code></td><td>初始化对象</td><td>None</td><td>常用</td></tr><tr><td><code>__del__</code></td><td>删除对象时</td><td>None</td><td>偶尔</td></tr><tr><td><code>__str__</code></td><td>str&#x2F;print</td><td>str</td><td>常用</td></tr><tr><td><code>__repr__</code></td><td>repr()，交互式解释器</td><td>str</td><td>常用</td></tr><tr><td><code>__add__</code></td><td>a+b</td><td>任意</td><td>按需</td></tr><tr><td><code>__getitem__</code></td><td>obj[key]</td><td>任意</td><td>按需</td></tr><tr><td><code>__call__</code></td><td>obj()</td><td>任意</td><td>有趣&#x2F;高阶</td></tr><tr><td><code>__enter__</code></td><td>with 块开始</td><td>任意</td><td>按需</td></tr><tr><td><code>__exit__</code></td><td>with 块结束</td><td>None&#x2F;Bool</td><td>按需</td></tr></tbody></table><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>魔法方法本质上让我们可以“像内置类型一样”自定义自己的类行为。</li><li>它们不需要显式调用，由 Python 语法环境&#x2F;运算符&#x2F;函数自动调用。</li><li>合理地使用魔法方法，可以让自己的类表现得更“Pythonic”，增加灵活性、可读性与可用性。</li><li>不是所有魔法方法都需要重写，按需选择。</li></ul><p><strong>举例说明：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y = x, y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector2D(<span class="variable language_">self</span>.x + other.x, <span class="variable language_">self</span>.y + other.y)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">v1 = Vector2D(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">v2 = Vector2D(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(v1 + v2)   <span class="comment"># 自动调用 __add__（输出：(4, 6)）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(v1))   <span class="comment"># 自动调用 __str__（输出：(1, 2)）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是魔法方法&quot;&gt;&lt;a href=&quot;#1-什么是魔法方法&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是魔法方法&quot;&gt;&lt;/a&gt;1. 什么是魔法方法&lt;/h2&gt;&lt;p&gt;魔法方法是指&lt;strong&gt;前后都有双下划线&lt;/strong&gt;的特殊方法，例如 </summary>
      
    
    
    
    <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>取消conda终端默认激活base虚拟环境</title>
    <link href="https://www.silenceboy.com/2025/04/09/%E5%8F%96%E6%B6%88conda%E7%BB%88%E7%AB%AF%E9%BB%98%E8%AE%A4%E6%BF%80%E6%B4%BBbase%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.silenceboy.com/2025/04/09/%E5%8F%96%E6%B6%88conda%E7%BB%88%E7%AB%AF%E9%BB%98%E8%AE%A4%E6%BF%80%E6%B4%BBbase%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2025-04-09T10:20:02.000Z</published>
    <updated>2025-04-09T10:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，安装完conda后，每次打开终端都会自动激活<code>base</code>环境。如果你不习惯这一行为，可以通过修改conda的相关配置，使终端启动时不再默认激活<code>base</code>环境。</p><h2 id="▶️-临时关闭-auto-activate-当前终端有效"><a href="#▶️-临时关闭-auto-activate-当前终端有效" class="headerlink" title="▶️ 临时关闭 auto activate (当前终端有效)"></a>▶️ 临时关闭 auto activate (当前终端有效)</h2><p>如果你只是想一次性临时地关闭，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>但是这种方式仅对当前打开的终端临时生效，打开新的终端窗口时，<code>base</code>还是会自动激活。</p><h2 id="✅-长期永久关闭默认激活-推荐"><a href="#✅-长期永久关闭默认激活-推荐" class="headerlink" title="✅ 长期永久关闭默认激活 (推荐)"></a>✅ 长期永久关闭默认激活 (推荐)</h2><p>要永久关闭每次终端自动激活<code>base</code>环境，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以上命令会修改conda配置文件<code>~/.condarc</code>，添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_activate_base:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以后你每次打开新的终端窗口时，<code>base</code>将不会再自动激活。</p><h2 id="📝-如果你后悔了，如何恢复自动激活base？"><a href="#📝-如果你后悔了，如何恢复自动激活base？" class="headerlink" title="📝 如果你后悔了，如何恢复自动激活base？"></a>📝 如果你后悔了，如何恢复自动激活base？</h2><p>再次启用自动激活：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="🔍-验证你的配置"><a href="#🔍-验证你的配置" class="headerlink" title="🔍 验证你的配置"></a>🔍 验证你的配置</h2><p>执行以下命令验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show | grep auto_activate_base</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_activate_base:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代表成功地关闭了默认激活行为。</p><p>⚠️ <strong>注意</strong>：</p><ul><li>在关闭默认激活之后，如果想激活base或其他虚拟环境，就需要手动运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate base       <span class="comment">#激活base</span></span><br><span class="line">conda activate env_name   <span class="comment">#激活其他环境</span></span><br></pre></td></tr></table></figure><p>按照以上方法，你便可以自由控制conda是否默认激活<code>base</code>环境了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;默认情况下，安装完conda后，每次打开终端都会自动激活&lt;code&gt;base&lt;/code&gt;环境。如果你不习惯这一行为，可以通过修改conda的相关配置，使终端启动时不再默认激活&lt;code&gt;base&lt;/code&gt;环境。&lt;/p&gt;
&lt;h2 id=&quot;▶️-临时关闭-auto-act</summary>
      
    
    
    
    <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python项目批量检查依赖并添加进requirements文件</title>
    <link href="https://www.silenceboy.com/2025/04/09/python%E9%A1%B9%E7%9B%AE%E6%89%B9%E9%87%8F%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%BF%9Brequirements%E6%96%87%E4%BB%B6/"/>
    <id>https://www.silenceboy.com/2025/04/09/python%E9%A1%B9%E7%9B%AE%E6%89%B9%E9%87%8F%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%BF%9Brequirements%E6%96%87%E4%BB%B6/</id>
    <published>2025-04-09T01:38:13.000Z</published>
    <updated>2025-04-09T09:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Python项目中，管理依赖是很重要的工作。下面我介绍几种方法，可以帮助你批量检查项目依赖并更新requirements文件。</p><h2 id="1-使用pipreqs自动生成requirements-txt"><a href="#1-使用pipreqs自动生成requirements-txt" class="headerlink" title="1. 使用pipreqs自动生成requirements.txt"></a>1. 使用pipreqs自动生成requirements.txt</h2><p>pipreqs是一个很好的工具，它能分析你的代码并只生成项目实际使用的依赖列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pipreqs</span></span><br><span class="line">pip install pipreqs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在项目根目录运行</span></span><br><span class="line">pipreqs . --force  <span class="comment"># --force选项会覆盖已存在的requirements.txt</span></span><br></pre></td></tr></table></figure><p>这个工具的优点是它只包含代码中实际导入的包，而不是环境中安装的所有包。</p><h2 id="2-使用pip-tools管理依赖"><a href="#2-使用pip-tools管理依赖" class="headerlink" title="2. 使用pip-tools管理依赖"></a>2. 使用pip-tools管理依赖</h2><p>pip-tools提供了两个命令：<code>pip-compile</code>和<code>pip-sync</code>，可以更精确地管理依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pip-tools</span></span><br><span class="line">pip install pip-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个requirements.in文件，列出主要依赖</span></span><br><span class="line"><span class="comment"># 然后生成详细的requirements.txt</span></span><br><span class="line">pip-compile requirements.in</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持环境与requirements.txt同步</span></span><br><span class="line">pip-sync</span><br></pre></td></tr></table></figure><p>这种方法的优点是可以区分直接依赖和间接依赖，并且锁定所有包的版本。</p><h2 id="3-检查项目中缺少的依赖"><a href="#3-检查项目中缺少的依赖" class="headerlink" title="3. 检查项目中缺少的依赖"></a>3. 检查项目中缺少的依赖</h2><p>可以使用pylint或其他静态分析工具来查找可能缺少的导入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pylint</span></span><br><span class="line">pip install pylint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描项目</span></span><br><span class="line">pylint --<span class="built_in">disable</span>=all --<span class="built_in">enable</span>=no-name-in-module,import-error path/to/your/project</span><br></pre></td></tr></table></figure><h2 id="4-自动化脚本示例"><a href="#4-自动化脚本示例" class="headerlink" title="4. 自动化脚本示例"></a>4. 自动化脚本示例</h2><p>你可以创建一个脚本来自动执行这些步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">自动检查和更新项目依赖，并添加到requirements.txt文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 确保pip-tools已安装</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> piptools</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;安装 pip-tools...&quot;</span>)</span><br><span class="line">        subprocess.check_call([sys.executable, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;pip&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;pip-tools&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用pipreqs分析项目依赖</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> pipreqs</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;安装 pipreqs...&quot;</span>)</span><br><span class="line">        subprocess.check_call([sys.executable, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;pip&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;pipreqs&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成临时requirements文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分析项目依赖...&quot;</span>)</span><br><span class="line">    subprocess.check_call([<span class="string">&quot;pipreqs&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;--savepath&quot;</span>, <span class="string">&quot;requirements.temp.txt&quot;</span>, <span class="string">&quot;--force&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取现有的requirements.txt (如果存在)</span></span><br><span class="line">    existing_reqs = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;requirements.txt&quot;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;requirements.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                line = line.strip()</span><br><span class="line">                <span class="keyword">if</span> line <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                    existing_reqs.add(line.split(<span class="string">&quot;==&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取新生成的requirements</span></span><br><span class="line">    new_reqs = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;requirements.temp.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="keyword">if</span> line <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                new_reqs.append(line)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并并分类</span></span><br><span class="line">    main_deps = []</span><br><span class="line">    <span class="keyword">for</span> req <span class="keyword">in</span> new_reqs:</span><br><span class="line">        pkg_name = req.split(<span class="string">&quot;==&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> pkg_name <span class="keyword">not</span> <span class="keyword">in</span> existing_reqs:</span><br><span class="line">            main_deps.append(<span class="string">f&quot;<span class="subst">&#123;req&#125;</span>  # 新添加的依赖&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            main_deps.append(req)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 写入最终的requirements.txt</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;requirements.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;# 主要依赖 - 项目直接使用\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> dep <span class="keyword">in</span> <span class="built_in">sorted</span>(main_deps):</span><br><span class="line">            f.write(<span class="string">f&quot;<span class="subst">&#123;dep&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;\n# 根据实际需要添加开发和测试依赖\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清理临时文件</span></span><br><span class="line">    os.remove(<span class="string">&quot;requirements.temp.txt&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;完成! requirements.txt 已更新。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将这个脚本保存为<code>update_requirements.py</code>，然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python update_requirements.py</span><br></pre></td></tr></table></figure><h2 id="5-整合进Makefile"><a href="#5-整合进Makefile" class="headerlink" title="5. 整合进Makefile"></a>5. 整合进Makefile</h2><p>如果你的项目使用Makefile，可以添加一个目标来更新依赖：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: update-deps</span></span><br><span class="line"></span><br><span class="line"><span class="section">update-deps:</span></span><br><span class="line">@echo <span class="string">&quot;更新项目依赖...&quot;</span></span><br><span class="line">pip install pipreqs</span><br><span class="line">pipreqs . --force</span><br><span class="line">@echo <span class="string">&quot;依赖已更新到requirements.txt&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-对于复杂项目的建议"><a href="#6-对于复杂项目的建议" class="headerlink" title="6. 对于复杂项目的建议"></a>6. 对于复杂项目的建议</h2><p>对于有多个环境的复杂项目：</p><ol><li>使用<code>pyproject.toml</code>配合<code>setuptools</code>或<code>poetry</code>管理依赖</li><li>区分开发依赖和运行时依赖</li><li>使用虚拟环境确保依赖隔离</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用poetry</span></span><br><span class="line">poetry init  <span class="comment"># 创建pyproject.toml</span></span><br><span class="line">poetry add package1 package2  <span class="comment"># 添加依赖</span></span><br><span class="line">poetry <span class="built_in">export</span> -f requirements.txt --output requirements.txt  <span class="comment"># 导出requirements.txt</span></span><br></pre></td></tr></table></figure><h2 id="7-检查未使用的依赖"><a href="#7-检查未使用的依赖" class="headerlink" title="7. 检查未使用的依赖"></a>7. 检查未使用的依赖</h2><p>可以使用<code>pip-extra-reqs</code>工具检查未使用的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip-extra-reqs</span><br><span class="line">pip-extra-reqs src/</span><br></pre></td></tr></table></figure><p>通过以上步骤，你可以有效地管理项目依赖，确保requirements.txt文件包含所有必要的依赖，同时避免添加不必要的包。无论项目规模大小，这些方法都能帮助你保持依赖的清晰和最新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Python项目中，管理依赖是很重要的工作。下面我介绍几种方法，可以帮助你批量检查项目依赖并更新requirements文件。&lt;/p&gt;
&lt;h2 id=&quot;1-使用pipreqs自动生成requirements-txt&quot;&gt;&lt;a href=&quot;#1-使用pipreqs自动生成re</summary>
      
    
    
    
    <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>本地管理多个python版本</title>
    <link href="https://www.silenceboy.com/2025/03/26/%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AApython%E7%89%88%E6%9C%AC/"/>
    <id>https://www.silenceboy.com/2025/03/26/%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AApython%E7%89%88%E6%9C%AC/</id>
    <published>2025-03-26T12:13:54.000Z</published>
    <updated>2025-04-09T09:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本地管理多个 Python 版本是开发中的常见需求，以下是几种主流且高效的方法，适用于不同操作系统：</p><hr><h3 id="一、使用-pyenv（推荐给-macOS-Linux-用户）"><a href="#一、使用-pyenv（推荐给-macOS-Linux-用户）" class="headerlink" title="一、使用 pyenv（推荐给 macOS&#x2F;Linux 用户）"></a>一、使用 <strong>pyenv</strong>（推荐给 macOS&#x2F;Linux 用户）</h3><p><strong>原理</strong>：通过修改环境变量动态切换 Python 版本，不依赖系统自带的 Python。</p><h4 id="1-安装-pyenv"><a href="#1-安装-pyenv" class="headerlink" title="1. 安装 pyenv"></a>1. 安装 pyenv</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用安装脚本</span></span><br><span class="line">curl https://pyenv.run | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将以下内容添加到 ~/.bashrc 或 ~/.zshrc</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv virtualenv-init -)</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可安装版本</span></span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本（如 Python 3.9.6）</span></span><br><span class="line">pyenv install 3.9.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装版本</span></span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局默认版本</span></span><br><span class="line">pyenv global 3.9.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前目录的本地版本（优先级更高）</span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.8.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载版本</span></span><br><span class="line">pyenv uninstall 3.7.0</span><br></pre></td></tr></table></figure><hr><h3 id="二、使用-conda（跨平台，适合科学计算场景）"><a href="#二、使用-conda（跨平台，适合科学计算场景）" class="headerlink" title="二、使用 conda（跨平台，适合科学计算场景）"></a>二、使用 <strong>conda</strong>（跨平台，适合科学计算场景）</h3><p><strong>原理</strong>：通过虚拟环境管理 Python 版本和依赖。</p><h4 id="1-安装-Miniconda-Anaconda"><a href="#1-安装-Miniconda-Anaconda" class="headerlink" title="1. 安装 Miniconda&#x2F;Anaconda"></a>1. 安装 Miniconda&#x2F;Anaconda</h4><p>从官网下载安装包：<a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a></p><h4 id="2-创建不同-Python-版本的环境"><a href="#2-创建不同-Python-版本的环境" class="headerlink" title="2. 创建不同 Python 版本的环境"></a>2. 创建不同 Python 版本的环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 py38 的环境，指定 Python 3.8</span></span><br><span class="line">conda create -n py38 python=3.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">conda activate py38</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有环境</span></span><br><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除环境</span></span><br><span class="line">conda <span class="built_in">env</span> remove -n py38</span><br></pre></td></tr></table></figure><hr><h3 id="三、使用-Docker（适合隔离开发环境）"><a href="#三、使用-Docker（适合隔离开发环境）" class="headerlink" title="三、使用 Docker（适合隔离开发环境）"></a>三、使用 <strong>Docker</strong>（适合隔离开发环境）</h3><p>通过容器化技术隔离不同项目环境。</p><h4 id="示例-Dockerfile"><a href="#示例-Dockerfile" class="headerlink" title="示例 Dockerfile"></a>示例 Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="使用不同镜像版本"><a href="#使用不同镜像版本" class="headerlink" title="使用不同镜像版本"></a>使用不同镜像版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Python 3.9 容器</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> python:3.9-alpine python --version</span><br></pre></td></tr></table></figure><hr><h3 id="四、Windows-用户的替代方案"><a href="#四、Windows-用户的替代方案" class="headerlink" title="四、Windows 用户的替代方案"></a>四、Windows 用户的替代方案</h3><ol><li><p><strong>pyenv-win</strong>（类似 Unix 的 pyenv）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="literal">-Uri</span> <span class="string">&quot;https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1&quot;</span> <span class="literal">-OutFile</span> <span class="string">&quot;./install-pyenv-win.ps1&quot;</span></span><br><span class="line">&amp; <span class="string">&quot;./install-pyenv-win.ps1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动安装多个版本</strong>：</p><ul><li>从官网下载不同版本的安装包（如 <code>python-3.8.exe</code> 和 <code>python-3.10.exe</code>）</li><li>安装时勾选 <strong>“Add to PATH”</strong>，但通过修改可执行文件名区分版本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 Python 3.8 的可执行文件重命名</span></span><br><span class="line"><span class="built_in">mv</span> /path/to/python3.8/python.exe /path/to/python3.8/python38.exe</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="五、通用技巧：虚拟环境-版本指定"><a href="#五、通用技巧：虚拟环境-版本指定" class="headerlink" title="五、通用技巧：虚拟环境 + 版本指定"></a>五、通用技巧：虚拟环境 + 版本指定</h3><p>即使使用系统 Python，也可通过 <code>venv</code> 或 <code>virtualenv</code> 隔离环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用特定 Python 版本创建虚拟环境</span></span><br><span class="line">/path/to/python3.9 -m venv myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate  <span class="comment"># Linux/macOS</span></span><br><span class="line">myenv\Scripts\activate.bat <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><hr><h3 id="版本管理工具对比"><a href="#版本管理工具对比" class="headerlink" title="版本管理工具对比"></a>版本管理工具对比</h3><table><thead><tr><th>工具</th><th>适用系统</th><th>特点</th></tr></thead><tbody><tr><td><strong>pyenv</strong></td><td>macOS&#x2F;Linux</td><td>轻量级，纯命令行操作</td></tr><tr><td><strong>conda</strong></td><td>跨平台</td><td>集成包管理，适合科学计算</td></tr><tr><td><strong>Docker</strong></td><td>跨平台</td><td>完全环境隔离，但需学习容器技术</td></tr><tr><td><strong>手动管理</strong></td><td>所有系统</td><td>灵活性高，但维护成本较高</td></tr></tbody></table><p>选择工具时，建议优先使用 <strong>pyenv</strong>（Unix）或 <strong>conda</strong>（跨平台）以简化操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本地管理多个 Python 版本是开发中的常见需求，以下是几种主流且高效的方法，适用于不同操作系统：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、使用-pyenv（推荐给-macOS-Linux-用户）&quot;&gt;&lt;a href=&quot;#一、使用-pyenv（推荐给-macOS-Linux</summary>
      
    
    
    
    <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pip自动写入requirements的终极方案</title>
    <link href="https://www.silenceboy.com/2025/03/21/pip%E8%87%AA%E5%8A%A8%E5%86%99%E5%85%A5requirements%E7%9A%84%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88/"/>
    <id>https://www.silenceboy.com/2025/03/21/pip%E8%87%AA%E5%8A%A8%E5%86%99%E5%85%A5requirements%E7%9A%84%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88/</id>
    <published>2025-03-21T04:50:53.000Z</published>
    <updated>2025-03-21T04:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Python开发中，手动维护requirements.txt文件容易遗漏依赖项。本文将介绍三种自动化解决方案，让依赖管理更高效。</p><hr><h3 id="方案一：智能Shell别名（原生pip增强）"><a href="#方案一：智能Shell别名（原生pip增强）" class="headerlink" title="方案一：智能Shell别名（原生pip增强）"></a>方案一：智能Shell别名（原生pip增强）</h3><p><strong>实现原理：</strong> 通过Shell函数封装pip命令，在执行安装后自动更新requirements文件</p><p><strong>配置方法（在.bashrc&#x2F;.zshrc中添加）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pip</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;install&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">command</span> pip <span class="string">&quot;<span class="variable">$@</span>&quot;</span> &amp;&amp; pip freeze --exclude-editable | grep -v <span class="string">&#x27;^#&#x27;</span> &gt; requirements.txt</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">command</span> pip <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装包并自动记录</span></span><br><span class="line">pip install requests==2.26.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装多个包（支持所有pip参数）</span></span><br><span class="line">pip install django~=3.2.0 celery[redis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发模式安装（不会记录到requirements）</span></span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p><strong>方案特点：</strong></p><ul><li>✅ 零依赖，纯Shell实现</li><li>🛡️ 排除<code>-e</code>安装的本地包</li><li>🔍 自动过滤注释行</li><li>⚠️ 注意：会覆盖原有requirements文件</li></ul><hr><h3 id="方案二：pip-autosave工具（专业级自动记录）"><a href="#方案二：pip-autosave工具（专业级自动记录）" class="headerlink" title="方案二：pip-autosave工具（专业级自动记录）"></a>方案二：pip-autosave工具（专业级自动记录）</h3><p><strong>安装使用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pip-autosave</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础用法（自动生成requirements.txt）</span></span><br><span class="line">pip install requests --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定保存文件</span></span><br><span class="line">pip install pandas --save requirements-dev.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量安装并记录</span></span><br><span class="line">pip install -r base-requirements.txt --save</span><br></pre></td></tr></table></figure><p><strong>核心功能：</strong></p><ul><li>📦 增量更新模式（保留已有依赖）</li><li>🎯 智能版本锁定（记录精确版本号）</li><li>🔄 支持多环境文件（dev&#x2F;prod）</li><li>📊 生成依赖关系树可视化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show pandas --save --tree</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="方案三：现代项目管理工具集成"><a href="#方案三：现代项目管理工具集成" class="headerlink" title="方案三：现代项目管理工具集成"></a>方案三：现代项目管理工具集成</h3><p><strong>1. Pipenv工作流：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装并自动更新Pipfile</span></span><br><span class="line">pipenv install requests</span><br><span class="line">pipenv install --dev pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标准requirements文件</span></span><br><span class="line">pipenv requirements &gt; requirements.txt</span><br></pre></td></tr></table></figure><p><strong>2. Poetry配置：</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pyproject.toml 配置示例</span></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"><span class="attr">requests</span> = &#123; version = <span class="string">&quot;*&quot;</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.2.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出requirements.txt</span></span><br><span class="line">poetry export -f requirements.txt --output requirements.txt</span><br></pre></td></tr></table></figure><p><strong>3. Hatch环境管理：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建带自动依赖跟踪的环境</span></span><br><span class="line">hatch <span class="built_in">env</span> create myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在环境中安装依赖</span></span><br><span class="line">hatch run myenv pip install numpy</span><br></pre></td></tr></table></figure><hr><h3 id="版本控制最佳实践"><a href="#版本控制最佳实践" class="headerlink" title="版本控制最佳实践"></a>版本控制最佳实践</h3><ol><li><p><strong>差异化版本记录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产依赖</span></span><br><span class="line">pip freeze --exclude-editable | grep -v <span class="string">&#x27;pkg-resources==0.0.0&#x27;</span> &gt; requirements.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开发依赖</span></span><br><span class="line">pip freeze --exclude-editable | grep -E <span class="string">&#x27;(pytest|coverage)&#x27;</span> &gt; requirements-dev.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>依赖树可视化检查：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipdeptree --exclude pip,pip-autosave,setuptools,wheel</span><br></pre></td></tr></table></figure></li><li><p><strong>安全更新策略：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看过时依赖</span></span><br><span class="line">pip list --outdated --format=columns</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 批量更新命令</span></span><br><span class="line">pip install $(pip list --outdated | awk <span class="string">&#x27;NR&gt;2 &#123;print $1&#125;&#x27;</span>) --upgrade</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="不同方案的适用场景对比"><a href="#不同方案的适用场景对比" class="headerlink" title="不同方案的适用场景对比"></a>不同方案的适用场景对比</h3><table><thead><tr><th>方案</th><th>适用场景</th><th>优势</th><th>局限性</th></tr></thead><tbody><tr><td>Shell别名</td><td>快速原型开发</td><td>无需安装新工具</td><td>功能有限，可能覆盖文件</td></tr><tr><td>pip-autosave</td><td>企业级项目</td><td>精细控制，支持多环境</td><td>需要额外安装</td></tr><tr><td>Pipenv&#x2F;Poetry</td><td>长期维护的大型项目</td><td>完整依赖解析，支持锁定文件</td><td>学习成本较高</td></tr><tr><td>Hatch</td><td>多环境复杂配置</td><td>集成测试和构建流程</td><td>生态系统较新</td></tr></tbody></table><hr><h3 id="常见问题解决方案"><a href="#常见问题解决方案" class="headerlink" title="常见问题解决方案"></a>常见问题解决方案</h3><p><strong>Q：如何处理不同操作系统依赖？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用平台标记</span></span><br><span class="line">pip install pywin32 --save; sys_platform == <span class="string">&#x27;win32&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>Q：如何避免开发工具污染生产依赖？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用分层requirements文件</span></span><br><span class="line">.</span><br><span class="line">├── requirements</span><br><span class="line">│   ├── base.txt</span><br><span class="line">│   ├── dev.txt</span><br><span class="line">│   └── prod.txt</span><br></pre></td></tr></table></figure><p><strong>Q：依赖冲突自动解决示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用版本范围语法</span></span><br><span class="line">Django&gt;=<span class="number">3.2</span>,&lt;<span class="number">4.0</span></span><br><span class="line">requests&gt;=<span class="number">2.25</span><span class="number">.1</span>,!=<span class="number">2.28</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Python开发中，手动维护requirements.txt文件容易遗漏依赖项。本文将介绍三种自动化解决方案，让依赖管理更高效。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;方案一：智能Shell别名（原生pip增强）&quot;&gt;&lt;a href=&quot;#方案一：智能Shell别名（原生pip增</summary>
      
    
    
    
    <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python虚拟环境创建、激活、管理与最佳实践</title>
    <link href="https://www.silenceboy.com/2025/03/21/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA%E3%80%81%E6%BF%80%E6%B4%BB%E3%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.silenceboy.com/2025/03/21/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA%E3%80%81%E6%BF%80%E6%B4%BB%E3%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-03-21T04:47:36.000Z</published>
    <updated>2025-03-21T04:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言：为什么需要虚拟环境？"><a href="#引言：为什么需要虚拟环境？" class="headerlink" title="引言：为什么需要虚拟环境？"></a>引言：为什么需要虚拟环境？</h2><p>在Python开发中，不同项目往往依赖不同版本的第三方库。全局安装的包可能导致版本冲突，例如项目A需要Django 3.2，而项目B需要Django 4.0。虚拟环境通过为每个项目创建隔离的Python运行环境，完美解决这一难题。</p><hr><h2 id="一、创建虚拟环境"><a href="#一、创建虚拟环境" class="headerlink" title="一、创建虚拟环境"></a>一、创建虚拟环境</h2><h3 id="1-使用内置venv模块"><a href="#1-使用内置venv模块" class="headerlink" title="1. 使用内置venv模块"></a>1. 使用内置venv模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用于Python 3.3+版本</span></span><br><span class="line">python -m venv myenv  <span class="comment"># 创建名为myenv的虚拟环境</span></span><br></pre></td></tr></table></figure><h3 id="2-指定Python解释器版本"><a href="#2-指定Python解释器版本" class="headerlink" title="2. 指定Python解释器版本"></a>2. 指定Python解释器版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.8 -m venv py38_env  <span class="comment"># 使用特定Python版本创建</span></span><br></pre></td></tr></table></figure><h3 id="3-目录结构解析"><a href="#3-目录结构解析" class="headerlink" title="3. 目录结构解析"></a>3. 目录结构解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myenv/</span><br><span class="line">├── bin/            # Unix激活脚本</span><br><span class="line">├── Scripts/        # Windows激活脚本</span><br><span class="line">├── Lib/            # 安装的第三方库</span><br><span class="line">└── pyvenv.cfg      # 环境配置文件</span><br></pre></td></tr></table></figure><hr><h2 id="二、激活虚拟环境"><a href="#二、激活虚拟环境" class="headerlink" title="二、激活虚拟环境"></a>二、激活虚拟环境</h2><h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myenv\Scripts\activate</span><br><span class="line"><span class="comment"># 命令提示符显示 (myenv) C:\&gt;</span></span><br></pre></td></tr></table></figure><h3 id="macOS-Linux系统"><a href="#macOS-Linux系统" class="headerlink" title="macOS&#x2F;Linux系统"></a>macOS&#x2F;Linux系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"><span class="comment"># 终端提示符显示 (myenv) $</span></span><br></pre></td></tr></table></figure><p><strong>验证激活状态：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> python  <span class="comment"># Unix</span></span><br><span class="line"><span class="built_in">where</span> python  <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、管理项目依赖"><a href="#三、管理项目依赖" class="headerlink" title="三、管理项目依赖"></a>三、管理项目依赖</h2><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django==3.2.12</span><br></pre></td></tr></table></figure><h3 id="导出依赖清单"><a href="#导出依赖清单" class="headerlink" title="导出依赖清单"></a>导出依赖清单</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h3 id="批量安装依赖"><a href="#批量安装依赖" class="headerlink" title="批量安装依赖"></a>批量安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><hr><h2 id="四、退出虚拟环境"><a href="#四、退出虚拟环境" class="headerlink" title="四、退出虚拟环境"></a>四、退出虚拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br><span class="line"><span class="comment"># 命令提示符恢复默认状态</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、进阶技巧与工具"><a href="#五、进阶技巧与工具" class="headerlink" title="五、进阶技巧与工具"></a>五、进阶技巧与工具</h2><h3 id="1-虚拟环境管理工具对比"><a href="#1-虚拟环境管理工具对比" class="headerlink" title="1. 虚拟环境管理工具对比"></a>1. 虚拟环境管理工具对比</h3><table><thead><tr><th>工具</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>venv</td><td>Python内置，轻量级</td><td>简单项目</td></tr><tr><td>virtualenv</td><td>支持Python 2&#x2F;3</td><td>兼容旧项目</td></tr><tr><td>pipenv</td><td>整合pip+虚拟环境</td><td>复杂依赖管理</td></tr><tr><td>poetry</td><td>依赖解析+打包一体化</td><td>专业项目开发</td></tr></tbody></table><h3 id="2-快速复制环境"><a href="#2-快速复制环境" class="headerlink" title="2. 快速复制环境"></a>2. 快速复制环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在原环境执行</span></span><br><span class="line">pip list --format=freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新环境执行</span></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="3-环境配置加速"><a href="#3-环境配置加速" class="headerlink" title="3. 环境配置加速"></a>3. 环境配置加速</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install pip --upgrade  <span class="comment"># 升级pip</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple  <span class="comment"># 国内镜像源</span></span><br></pre></td></tr></table></figure><hr><h2 id="六、最佳实践"><a href="#六、最佳实践" class="headerlink" title="六、最佳实践"></a>六、最佳实践</h2><ol><li><strong>项目隔离原则</strong>：每个独立项目创建专属虚拟环境</li><li><strong>版本控制</strong>：将requirements.txt加入Git仓库，忽略虚拟环境目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># .gitignore</span><br><span class="line">myenv/</span><br><span class="line">venv/</span><br><span class="line">*.env/</span><br></pre></td></tr></table></figure></li><li><strong>定期维护</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip list --outdated  <span class="comment"># 检查过期包</span></span><br><span class="line">pip-autoremove  <span class="comment"># 清理无用依赖</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>掌握虚拟环境是Python开发者的必备技能。通过<code>venv</code>创建隔离环境，配合<code>requirements.txt</code>管理依赖，能有效避免”在我机器上能运行”的经典问题。建议立即在您的下一个Python项目中实践这些技巧，体验更干净的开发环境！</p><blockquote><p><strong>提示</strong>：删除虚拟环境只需删除对应目录即可，但请确保已执行<code>deactivate</code>退出环境。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言：为什么需要虚拟环境？&quot;&gt;&lt;a href=&quot;#引言：为什么需要虚拟环境？&quot; class=&quot;headerlink&quot; title=&quot;引言：为什么需要虚拟环境？&quot;&gt;&lt;/a&gt;引言：为什么需要虚拟环境？&lt;/h2&gt;&lt;p&gt;在Python开发中，不同项目往往依赖不同版本的第三</summary>
      
    
    
    
    <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ASIL等级是什么</title>
    <link href="https://www.silenceboy.com/2024/10/22/ASIL%E7%AD%89%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://www.silenceboy.com/2024/10/22/ASIL%E7%AD%89%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2024-10-22T06:45:40.000Z</published>
    <updated>2024-10-22T06:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL A表示最低的安全要求。</p><h3 id="ASIL等级的定义"><a href="#ASIL等级的定义" class="headerlink" title="ASIL等级的定义"></a>ASIL等级的定义</h3><p>ASIL等级基于三个主要因素来确定：</p><ol><li><strong>严重性（Severity, S）</strong>：故障导致的潜在伤害的严重程度。</li><li><strong>暴露率（Exposure, E）</strong>：驾驶员或乘客暴露于潜在故障的频率。</li><li><strong>可控性（Controllability, C）</strong>：驾驶员或乘客在故障发生时控制车辆的能力。</li></ol><h3 id="ASIL等级的划分"><a href="#ASIL等级的划分" class="headerlink" title="ASIL等级的划分"></a>ASIL等级的划分</h3><p>根据上述三个因素的组合，ASIL等级可以分为以下四个级别：</p><ol><li><strong>ASIL A</strong>：最低的安全要求。适用于故障对安全影响较小、暴露率低且可控性高的情况。</li><li><strong>ASIL B</strong>：中等安全要求。适用于故障对安全影响中等、暴露率中等且可控性一般的情况。</li><li><strong>ASIL C</strong>：较高的安全要求。适用于故障对安全影响较大、暴露率较高且可控性较低的情况。</li><li><strong>ASIL D</strong>：最高的安全要求。适用于故障对安全影响非常大、暴露率非常高且几乎不可控的情况。</li></ol><h3 id="ASIL等级的确定"><a href="#ASIL等级的确定" class="headerlink" title="ASIL等级的确定"></a>ASIL等级的确定</h3><p>ASIL等级的确定通常通过一个风险评估矩阵来完成，该矩阵综合考虑严重性、暴露率和可控性三个因素。以下是一个简化的示例矩阵：</p><table><thead><tr><th>严重性&#x2F;暴露率&#x2F;可控性</th><th>E1（低）</th><th>E2（中低）</th><th>E3（中高）</th><th>E4（高）</th></tr></thead><tbody><tr><td>S1（低）</td><td>QM</td><td>QM</td><td>ASIL A</td><td>ASIL A</td></tr><tr><td>S2（中）</td><td>QM</td><td>ASIL A</td><td>ASIL B</td><td>ASIL B</td></tr><tr><td>S3（高）</td><td>ASIL A</td><td>ASIL B</td><td>ASIL C</td><td>ASIL D</td></tr><tr><td>S4（极高）</td><td>ASIL B</td><td>ASIL C</td><td>ASIL D</td><td>ASIL D</td></tr></tbody></table><p><strong>注</strong>：QM（Quality Management）表示不需要特别的安全措施，只需按照质量管理标准进行处理。</p><h3 id="ASIL等级的应用"><a href="#ASIL等级的应用" class="headerlink" title="ASIL等级的应用"></a>ASIL等级的应用</h3><p>在汽车电子系统的设计和开发过程中，确定ASIL等级是确保系统安全性的关键步骤。不同的ASIL等级对应不同的开发流程和验证要求：</p><ul><li><strong>ASIL A</strong>：基本的安全措施和验证。</li><li><strong>ASIL B</strong>：需要更严格的设计和测试流程。</li><li><strong>ASIL C</strong>：需要高级的安全分析和验证技术。</li><li><strong>ASIL D</strong>：需要最高级别的安全措施、冗余设计和全面的验证。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ASIL等级是评估和管理汽车电子系统安全性的关键工具。通过确定系统的ASIL等级，开发人员可以采取适当的设计和验证措施，以确保系统在各种可能的故障情况下都能保持安全性。ISO 26262标准提供了详细的指南和方法，帮助开发人员在整个开发生命周期中实现和维护所需的安全完整性等级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL </summary>
      
    
    
    
    <category term="ASIL" scheme="https://www.silenceboy.com/categories/ASIL/"/>
    
    
    <category term="ASIL" scheme="https://www.silenceboy.com/tags/ASIL/"/>
    
  </entry>
  
  <entry>
    <title>SOC中除了R核和A核还有哪些处理器核心</title>
    <link href="https://www.silenceboy.com/2024/10/21/SOC%E4%B8%AD%E9%99%A4%E4%BA%86R%E6%A0%B8%E5%92%8CA%E6%A0%B8%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8%E5%BF%83/"/>
    <id>https://www.silenceboy.com/2024/10/21/SOC%E4%B8%AD%E9%99%A4%E4%BA%86R%E6%A0%B8%E5%92%8CA%E6%A0%B8%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8%E5%BF%83/</id>
    <published>2024-10-21T06:25:57.000Z</published>
    <updated>2024-10-21T06:26:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型：</p><h3 id="M核（Microcontroller-Core）"><a href="#M核（Microcontroller-Core）" class="headerlink" title="M核（Microcontroller Core）"></a>M核（Microcontroller Core）</h3><p>M核通常指的是微控制器核心，主要用于低功耗、低成本的嵌入式系统。以下是M核的一些特点和应用：</p><ol><li><strong>低功耗</strong>：设计目标是尽量减少功耗，适合电池供电的设备。</li><li><strong>简单架构</strong>：通常具有较简单的指令集和架构，易于编程和调试。</li><li><strong>集成外设</strong>：通常集成了丰富的外设接口，如ADC、DAC、UART、I2C、SPI等。</li><li><strong>实时性</strong>：虽然不如R核那样严格，但也能处理一些实时任务。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>家用电器</li><li>传感器节点</li><li>简单控制系统</li><li>物联网设备</li></ul><h3 id="NPU（Neural-Processing-Unit）"><a href="#NPU（Neural-Processing-Unit）" class="headerlink" title="NPU（Neural Processing Unit）"></a>NPU（Neural Processing Unit）</h3><p>NPU是神经网络处理单元，专门用于加速深度学习和人工智能任务。以下是NPU的一些特点和应用：</p><ol><li><strong>高效计算</strong>：专门优化用于矩阵运算和卷积操作，适合深度学习模型的推理和训练。</li><li><strong>并行处理</strong>：具有高度并行的计算能力，能够同时处理大量数据。</li><li><strong>低功耗</strong>：相对于通用处理器，NPU在执行AI任务时具有更高的能效比。</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>图像和视频处理</li><li>语音识别</li><li>自然语言处理</li><li>自动驾驶</li></ul><h3 id="DSP（Digital-Signal-Processor）"><a href="#DSP（Digital-Signal-Processor）" class="headerlink" title="DSP（Digital Signal Processor）"></a>DSP（Digital Signal Processor）</h3><p>DSP是数字信号处理器，专门用于处理数字信号，如音频、视频和通信信号。以下是DSP的一些特点和应用：</p><ol><li><strong>高效信号处理</strong>：专门优化用于快速傅里叶变换（FFT）、滤波和其他信号处理算法。</li><li><strong>实时处理</strong>：能够实时处理输入信号，适合实时音频和视频处理。</li><li><strong>低延迟</strong>：设计目标是尽量减少处理延迟，确保信号处理的实时性。</li></ol><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>音频处理（如回声消除、降噪）</li><li>视频处理（如编码、解码）</li><li>通信系统（如调制、解调）</li><li>雷达和声纳</li></ul><h3 id="GPU（Graphics-Processing-Unit）"><a href="#GPU（Graphics-Processing-Unit）" class="headerlink" title="GPU（Graphics Processing Unit）"></a>GPU（Graphics Processing Unit）</h3><p>GPU是图形处理单元，主要用于图形渲染和计算加速。以下是GPU的一些特点和应用：</p><ol><li><strong>高并行性</strong>：具有大量并行处理单元，能够同时处理大量数据。</li><li><strong>图形渲染</strong>：专门用于处理图形渲染任务，如3D图形、游戏图形等。</li><li><strong>通用计算</strong>：近年来，GPU也被广泛用于通用计算（GPGPU），如科学计算、机器学习等。</li></ol><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>游戏和娱乐</li><li>图形设计和渲染</li><li>科学计算</li><li>深度学习</li></ul><h3 id="VPU（Vision-Processing-Unit）"><a href="#VPU（Vision-Processing-Unit）" class="headerlink" title="VPU（Vision Processing Unit）"></a>VPU（Vision Processing Unit）</h3><p>VPU是视觉处理单元，专门用于处理计算机视觉任务。以下是VPU的一些特点和应用：</p><ol><li><strong>优化视觉任务</strong>：专门优化用于图像和视频处理任务，如对象检测、图像识别等。</li><li><strong>高效能效比</strong>：在处理视觉任务时具有高效的能效比。</li><li><strong>实时处理</strong>：能够实时处理图像和视频数据，适合实时应用。</li></ol><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>计算机视觉</li><li>增强现实（AR）和虚拟现实（VR）</li><li>自动驾驶</li><li>安全监控</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在现代SoC设计中，除了R核和A核，还有多种类型的处理器核心，如M核、NPU、DSP、GPU和VPU等。每种核心都有其特定的用途和优势，通过组合使用这些核心，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型：&lt;/p&gt;
&lt;h3 id=&quot;M核（Microcontroller-Core）&quot;&gt;&lt;a href=&quot;#M核（Microcontr</summary>
      
    
    
    
    <category term="SoC" scheme="https://www.silenceboy.com/categories/SoC/"/>
    
    
    <category term="SoC" scheme="https://www.silenceboy.com/tags/SoC/"/>
    
  </entry>
  
  <entry>
    <title>SOC的R核、A核有什么区别</title>
    <link href="https://www.silenceboy.com/2024/10/21/SOC%E7%9A%84R%E6%A0%B8%E3%80%81A%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.silenceboy.com/2024/10/21/SOC%E7%9A%84R%E6%A0%B8%E3%80%81A%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2024-10-21T06:22:57.000Z</published>
    <updated>2024-10-21T06:23:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。</p><h3 id="R核（Real-time-Core）"><a href="#R核（Real-time-Core）" class="headerlink" title="R核（Real-time Core）"></a>R核（Real-time Core）</h3><p>R核通常指的是实时处理器核心，主要用于处理实时任务。以下是R核的一些特点和应用：</p><ol><li><strong>实时性</strong>：R核设计用于处理需要严格时间约束的任务，确保任务在规定时间内完成。</li><li><strong>确定性</strong>：R核通常具有确定的响应时间，适合用于实时操作系统（RTOS）。</li><li><strong>低延迟</strong>：R核的设计目标是尽量减少处理延迟，以确保快速响应外部事件。</li><li><strong>低功耗</strong>：R核通常功耗较低，适合用于电池供电的嵌入式设备。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>工业自动化控制</li><li>汽车电子（如引擎控制单元）</li><li>医疗设备</li><li>物联网设备</li></ul><h3 id="A核（Application-Core）"><a href="#A核（Application-Core）" class="headerlink" title="A核（Application Core）"></a>A核（Application Core）</h3><p>A核通常指的是应用处理器核心，主要用于运行复杂的应用程序和操作系统。以下是A核的一些特点和应用：</p><ol><li><strong>高性能</strong>：A核设计用于处理复杂计算任务，具有较高的处理能力。</li><li><strong>多任务处理</strong>：A核通常支持多任务处理，能够运行完整的操作系统（如Linux、Android）。</li><li><strong>丰富的外设支持</strong>：A核通常集成了丰富的外设接口，如USB、HDMI、以太网等。</li><li><strong>较高功耗</strong>：由于需要处理复杂任务，A核的功耗通常较高。</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>智能手机和平板电脑</li><li>个人计算机</li><li>多媒体设备（如智能电视和机顶盒）</li><li>高级嵌入式系统（如无人机和机器人）</li></ul><h3 id="例子：ARM-Cortex-系列"><a href="#例子：ARM-Cortex-系列" class="headerlink" title="例子：ARM Cortex 系列"></a>例子：ARM Cortex 系列</h3><p>在ARM的Cortex系列处理器中，R核和A核的区别非常明显：</p><ul><li><strong>Cortex-R 系列</strong>：这是ARM的实时处理器系列，设计用于高可靠性和实时性应用，如Cortex-R5和Cortex-R8。</li><li><strong>Cortex-A 系列</strong>：这是ARM的应用处理器系列，设计用于高性能和复杂应用，如Cortex-A53、Cortex-A72等。</li></ul><h3 id="SoC中的组合"><a href="#SoC中的组合" class="headerlink" title="SoC中的组合"></a>SoC中的组合</h3><p>在许多SoC设计中，R核和A核常常被组合使用，以便同时满足实时处理和高性能计算的需求。例如：</p><ul><li><strong>智能手机SoC</strong>：通常包含多个Cortex-A系列核心用于运行操作系统和应用程序，同时可能包含一个或多个Cortex-R系列核心用于处理实时任务，如基带处理。</li><li><strong>汽车电子SoC</strong>：可能包含Cortex-R系列核心用于引擎控制和安全系统，同时包含Cortex-A系列核心用于信息娱乐系统。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>R核（Real-time Core）</strong>：用于实时任务，强调低延迟和确定性，适合工业控制、汽车电子等领域。</li><li><strong>A核（Application Core）</strong>：用于运行复杂应用程序和操作系统，强调高性能和多任务处理，适合智能手机、平板电脑等设备。</li></ul><p>通过结合使用R核和A核，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。&lt;/p&gt;
&lt;h3 id=&quot;R核（Real-time-Core）&quot;&gt;&lt;a href=&quot;#R核（Real-time-Core）&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="SoC" scheme="https://www.silenceboy.com/categories/SoC/"/>
    
    
    <category term="SoC" scheme="https://www.silenceboy.com/tags/SoC/"/>
    
  </entry>
  
  <entry>
    <title>docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？</title>
    <link href="https://www.silenceboy.com/2024/06/28/docker%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E9%9D%9Eroot%EF%BC%8C%E4%B8%94%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AF%86%E7%A0%81%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Csudo%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>https://www.silenceboy.com/2024/06/28/docker%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E9%9D%9Eroot%EF%BC%8C%E4%B8%94%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AF%86%E7%A0%81%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Csudo%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</id>
    <published>2024-06-28T07:22:18.000Z</published>
    <updated>2024-06-28T07:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在 Docker 容器中默认用户是 <code>dev</code>，但不知道密码，无法执行 <code>sudo</code> 操作，你可以通过以下几种方法来解决这个问题：</p><h3 id="方法一：以-root-用户重新启动容器"><a href="#方法一：以-root-用户重新启动容器" class="headerlink" title="方法一：以 root 用户重新启动容器"></a>方法一：以 root 用户重新启动容器</h3><p>你可以以 <code>root</code> 用户重新启动容器，然后更改 <code>dev</code> 用户的密码或者直接执行你需要的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="方法二：修改-Dockerfile-重新构建镜像"><a href="#方法二：修改-Dockerfile-重新构建镜像" class="headerlink" title="方法二：修改 Dockerfile 重新构建镜像"></a>方法二：修改 Dockerfile 重新构建镜像</h3><p>如果你有 Dockerfile，可以修改 Dockerfile 来设置 <code>dev</code> 用户的密码或者直接使用 <code>root</code> 用户。</p><p>例如，修改 Dockerfile 来设置 <code>dev</code> 用户的密码：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> your_base_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 dev 用户的密码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;dev:your_new_password&#x27;</span> | chpasswd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他 Dockerfile 指令</span></span><br></pre></td></tr></table></figure><p>然后重新构建镜像并运行容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your_image_name .</span><br><span class="line">docker run -it your_image_name</span><br></pre></td></tr></table></figure><h3 id="方法三：创建新的镜像并修改用户配置"><a href="#方法三：创建新的镜像并修改用户配置" class="headerlink" title="方法三：创建新的镜像并修改用户配置"></a>方法三：创建新的镜像并修改用户配置</h3><p>如果你没有 Dockerfile，但可以访问容器的镜像，你可以创建一个新的镜像并修改用户配置。</p><ol><li><p>首先，启动一个新的容器并进入：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name temp_container your_image_name /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;dev:your_new_password&#x27;</span> | chpasswd</span><br></pre></td></tr></table></figure></li><li><p>退出容器并提交更改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit temp_container your_new_image_name</span><br></pre></td></tr></table></figure></li><li><p>使用新的镜像启动容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it your_new_image_name</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法四：直接进入容器并修改密码"><a href="#方法四：直接进入容器并修改密码" class="headerlink" title="方法四：直接进入容器并修改密码"></a>方法四：直接进入容器并修改密码</h3><p>如果容器已经在运行，你可以直接进入容器并修改 <code>dev</code> 用户的密码。</p><ol><li><p>首先，以 <code>root</code> 用户进入容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;dev:your_new_password&#x27;</span> | chpasswd</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法五：使用-docker-commit-修改现有容器"><a href="#方法五：使用-docker-commit-修改现有容器" class="headerlink" title="方法五：使用 docker commit 修改现有容器"></a>方法五：使用 <code>docker commit</code> 修改现有容器</h3><p>如果你已经有一个运行中的容器，可以使用 <code>docker commit</code> 来创建一个新的镜像，并在新镜像中修改 <code>dev</code> 用户的密码。</p><ol><li><p>首先，以 <code>root</code> 用户进入容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;dev:your_new_password&#x27;</span> | chpasswd</span><br></pre></td></tr></table></figure></li><li><p>退出容器并提交更改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit &lt;container_id_or_name&gt; your_new_image_name</span><br></pre></td></tr></table></figure></li><li><p>使用新的镜像启动容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it your_new_image_name</span><br></pre></td></tr></table></figure></li></ol><p>通过这些方法，你可以解决无法执行 <code>sudo</code> 操作的问题，并根据需要修改 <code>dev</code> 用户的密码或直接使用 <code>root</code> 用户。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你在 Docker 容器中默认用户是 &lt;code&gt;dev&lt;/code&gt;，但不知道密码，无法执行 &lt;code&gt;sudo&lt;/code&gt; 操作，你可以通过以下几种方法来解决这个问题：&lt;/p&gt;
&lt;h3 id=&quot;方法一：以-root-用户重新启动容器&quot;&gt;&lt;a href=&quot;#方法一</summary>
      
    
    
    
    <category term="docker" scheme="https://www.silenceboy.com/categories/docker/"/>
    
    
    <category term="docker" scheme="https://www.silenceboy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比</title>
    <link href="https://www.silenceboy.com/2024/06/24/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%EF%BC%9Asonar%E3%80%81fireline%E3%80%81coverity%E3%80%81fortify%E3%80%81blackduck%E5%AF%B9%E6%AF%94/"/>
    <id>https://www.silenceboy.com/2024/06/24/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%EF%BC%9Asonar%E3%80%81fireline%E3%80%81coverity%E3%80%81fortify%E3%80%81blackduck%E5%AF%B9%E6%AF%94/</id>
    <published>2024-06-24T08:02:01.000Z</published>
    <updated>2024-06-24T08:10:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别：</p><h3 id="1-SonarQube"><a href="#1-SonarQube" class="headerlink" title="1. SonarQube"></a>1. SonarQube</h3><p><strong>简介</strong>:</p><ul><li>SonarQube 是一个开源的代码质量管理工具。</li><li>支持多种编程语言，如 Java、C#、JavaScript、TypeScript、Python 等。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的漏洞、错误和代码异味。</li><li>代码度量：提供代码覆盖率、复杂度等度量指标。</li><li>集成：与 CI&#x2F;CD 工具（如 Jenkins、GitLab CI）集成，自动化代码质量检查。</li></ul><p><strong>优点</strong>:</p><ul><li>开源且社区活跃。</li><li>支持多种插件，扩展功能强大。</li><li>直观的用户界面，易于使用。</li></ul><h3 id="2-Fireline"><a href="#2-Fireline" class="headerlink" title="2. Fireline"></a>2. Fireline</h3><p><strong>简介</strong>:</p><ul><li>Fireline 是一个专注于代码安全的静态分析工具。</li></ul><p><strong>功能</strong>:</p><ul><li>检测代码中的安全漏洞，如 SQL 注入、跨站脚本攻击（XSS）等。</li><li>提供详细的漏洞报告和修复建议。</li></ul><p><strong>优点</strong>:</p><ul><li>专注于安全漏洞检测，提供深度分析。</li><li>适用于需要高安全性的应用程序开发。</li></ul><h3 id="3-Coverity"><a href="#3-Coverity" class="headerlink" title="3. Coverity"></a>3. Coverity</h3><p><strong>简介</strong>:</p><ul><li>Coverity 是 Synopsys 提供的静态代码分析工具。</li><li>支持多种编程语言，如 C、C++、Java、C#、JavaScript 等。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的缺陷和安全漏洞。</li><li>自动化分析：与 CI&#x2F;CD 工具集成，实现自动化代码扫描。</li><li>报告和修复建议：提供详细的缺陷报告和修复建议。</li></ul><p><strong>优点</strong>:</p><ul><li>高准确性和低误报率。</li><li>强大的企业级支持和服务。</li><li>支持广泛的编程语言和复杂代码库。</li></ul><h3 id="4-Fortify"><a href="#4-Fortify" class="headerlink" title="4. Fortify"></a>4. Fortify</h3><p><strong>简介</strong>:</p><ul><li>Fortify 是 Micro Focus 提供的应用安全测试工具。</li><li>包含静态应用安全测试（SAST）和动态应用安全测试（DAST）。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的安全漏洞。</li><li>动态分析：在运行时检测应用程序的安全漏洞。</li><li>安全审计和合规性检查。</li></ul><p><strong>优点</strong>:</p><ul><li>综合的安全测试解决方案，覆盖静态和动态分析。</li><li>强大的企业级支持和服务。</li><li>提供详细的漏洞修复指导。</li></ul><h3 id="5-Black-Duck"><a href="#5-Black-Duck" class="headerlink" title="5. Black Duck"></a>5. Black Duck</h3><p><strong>简介</strong>:</p><ul><li>Black Duck 是 Synopsys 提供的开源安全和管理工具。</li><li>专注于开源组件的安全和合规性。</li></ul><p><strong>功能</strong>:</p><ul><li>开源组件扫描：检测项目中使用的开源组件。</li><li>漏洞检测：识别开源组件中的已知漏洞。</li><li>许可证合规性：检查开源组件的许可证合规性。</li></ul><p><strong>优点</strong>:</p><ul><li>专注于开源组件的管理和安全。</li><li>提供详细的漏洞和许可证合规报告。</li><li>与其他 Synopsys 工具集成，提供全面的安全解决方案。</li></ul><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul><li><strong>SonarQube</strong>：主要关注代码质量和代码异味，提供全面的代码度量和质量报告。</li><li><strong>Fireline</strong>：专注于代码安全漏洞的检测，适用于需要高安全性的应用。</li><li><strong>Coverity</strong>：提供高准确性的静态代码分析，适合复杂和大型代码库。</li><li><strong>Fortify</strong>：综合的应用安全测试工具，覆盖静态和动态分析，适合全面的安全测试需求。</li><li><strong>Black Duck</strong>：专注于开源组件的安全和合规性管理，适用于使用大量开源组件的项目。</li></ul><p>每种工具都有其特定的优势和应用场景，选择合适的工具应根据项目的具体需求和环境来决定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别：&lt;/p&gt;
&lt;h3 id=&quot;1-SonarQube&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="代码扫描" scheme="https://www.silenceboy.com/categories/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
    
    <category term="代码扫描" scheme="https://www.silenceboy.com/tags/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本里的#*@是什么意思</title>
    <link href="https://www.silenceboy.com/2023/09/27/shell%E8%84%9A%E6%9C%AC%E9%87%8C%E7%9A%84-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>https://www.silenceboy.com/2023/09/27/shell%E8%84%9A%E6%9C%AC%E9%87%8C%E7%9A%84-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</id>
    <published>2023-09-27T09:22:45.000Z</published>
    <updated>2023-12-05T01:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Shell脚本中，<code>$&#123;variable#pattern&#125;</code> 是一种字符串处理方式，其中 <code>#</code> 后跟着一个模式<code>（pattern）</code>。这个语法的作用是从字符串变量 variable 的开头删除匹配 <code>pattern</code> 的最短子串，并返回删除后的结果。<code>$&#123;variable#*@&#125;</code> 的含义是：</p><p>● <code>variable</code> 是一个字符串变量，通常是一个包含文本的字符串。</p><p>● <code>#</code> 表示从字符串开头开始匹配。</p><p>● <code>*@</code> 是一个通配符模式，它匹配字符串中的任意字符序列，直到第一个 @ 字符。</p><p>所以，<code>$&#123;variable#*@&#125;</code> 的作用是从变量 <code>variable</code> 的开头删除匹配 <code>*@</code> 模式的最短子串，并返回删除后的结果。通常，这种操作用于处理文本或字符串，以过滤掉或提取感兴趣的部分。<br>例如，如果 <code>variable</code> 的值是 <code>&quot;user@example.com&quot;</code>，那么 <code>$&#123;variable#*@&#125;</code> 的结果将是 <code>&quot;example.com&quot;</code>，因为它删除了字符串中第一个 <code>&quot;@&quot;</code> 符号及其之前的部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Shell脚本中，&lt;code&gt;$&amp;#123;variable#pattern&amp;#125;&lt;/code&gt; 是一种字符串处理方式，其中 &lt;code&gt;#&lt;/code&gt; 后跟着一个模式&lt;code&gt;（pattern）&lt;/code&gt;。这个语法的作用是从字符串变量 variable 的</summary>
      
    
    
    
    <category term="shell" scheme="https://www.silenceboy.com/categories/shell/"/>
    
    
    <category term="shell" scheme="https://www.silenceboy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>用go开发sse接口</title>
    <link href="https://www.silenceboy.com/2023/07/11/%E7%94%A8go%E5%BC%80%E5%8F%91sse%E6%8E%A5%E5%8F%A3/"/>
    <id>https://www.silenceboy.com/2023/07/11/%E7%94%A8go%E5%BC%80%E5%8F%91sse%E6%8E%A5%E5%8F%A3/</id>
    <published>2023-07-11T02:50:24.000Z</published>
    <updated>2023-07-21T05:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p>sse 服务器发送事件(Server-Sent Events)，服务端向客户端单向传递消息。在一些只需要接受服务端数据的需求中可以取代websocket技术，使用起来也很简单。</p><p>目前go已经有一些支持sse的库，我这里选用了：<code>eventsource.v1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get gopkg.in/antage/eventsource.v1</span></span><br></pre></td></tr></table></figure><h2 id="广播模式SSE"><a href="#广播模式SSE" class="headerlink" title="广播模式SSE"></a>广播模式SSE</h2><p>广播模式SSE指不设置事件名，或者说是不设置通道，所有客户端接收同样的数据。</p><p>具体代码实现如下：<a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test1">点击查看源码</a></p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gopkg.in/antage/eventsource.v1&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播模式SSE，不设置事件名称（也可理解为通道）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">es := eventsource.New(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> es.Close()</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;./public&quot;</span>)))</span><br><span class="line">http.Handle(<span class="string">&quot;/events&quot;</span>, es)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 只设置发送数据，不添加事件名</span></span><br><span class="line">es.SendEventMessage(fmt.Sprintf(<span class="string">&quot;send data: %s&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)), <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">log.Printf(<span class="string">&quot;客户端连接数: %d&quot;</span>, es.ConsumersCount())</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Open URL http://localhost:8080/ in your browser.&quot;</span>)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前端</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> es = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;http://localhost:8080/events&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        es.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                .<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;li&gt;&quot;</span> + e.<span class="property">data</span> + <span class="string">&quot;&lt;/li&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        es.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// readyState说明</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 0：浏览器与服务端尚未建立连接或连接已被关闭</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readyState = &quot;</span> + e.<span class="property">currentTarget</span>.<span class="property">readyState</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动服务端代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run main</span></span><br></pre></td></tr></table></figure><p>打开浏览器访问前端代码： <a href="http://localhost:8080/">http://localhost:8080</a></p><p>服务端输出：</p><p><img src="/./images/2023-06-29_20-34_1.png"></p><p>前端输出：</p><p><img src="/./images/2023-06-29_20-34.png"></p><h2 id="点对点模式SSE"><a href="#点对点模式SSE" class="headerlink" title="点对点模式SSE"></a>点对点模式SSE</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test2">点击查看源代码</a></p><p>实现方式和广播模式差不多，只需做简单修改：</p><p>服务端代码只需添加事件名称：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置事件名称为：test-event</span></span><br><span class="line">es.SendEventMessage(fmt.Sprintf(<span class="string">&quot;send data: %s&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)), <span class="string">&quot;test-event&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>前端代码修改接收方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">es.<span class="title function_">addEventListener</span>(<span class="string">&quot;test-event&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        .<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;li&gt;&quot;</span> + e.<span class="property">data</span> + <span class="string">&quot;&lt;/li&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="支持跨域的SSE"><a href="#支持跨域的SSE" class="headerlink" title="支持跨域的SSE"></a>支持跨域的SSE</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test3">点击查看源代码</a></p><p>现在项目开发基本上都是前后端分离，这样就会存在跨域问题，SSE解决跨域的方式只需要在<code>new</code>方法内增加允许跨域请求头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">es := eventsource.New(</span><br><span class="line">    eventsource.DefaultSettings(),</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span></span> [][]<span class="type">byte</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">byte</span>&#123;</span><br><span class="line">            []<span class="type">byte</span>(<span class="string">&quot;X-Accel-Buffering: no&quot;</span>),</span><br><span class="line">            []<span class="type">byte</span>(<span class="string">&quot;Access-Control-Allow-Origin: *&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>前端创建sse连接时也可添加允许跨域参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> es = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;http://localhost:8080/events&quot;</span>, &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="解决火狐浏览器断开不会自动重连问题"><a href="#解决火狐浏览器断开不会自动重连问题" class="headerlink" title="解决火狐浏览器断开不会自动重连问题"></a>解决火狐浏览器断开不会自动重连问题</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test4">点击查看源代码</a></p><p>在Chrome浏览器中sse断开后会自动重连，但firefox浏览器中断开后不会重连，解决办法是，前端js通过判断连接状态主动进行重连请求，通过判断readyState的值进行重新调用初始化操作</p><p>readyState说明：</p><ul><li>0：浏览器与服务端尚未建立连接或连接已被关闭</li><li>1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</li><li>2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</li></ul><p>前端代码可修改为如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> es = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 解决火狐浏览器断开不会自动重连问题</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">initES</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (es == <span class="literal">null</span> || es.<span class="property">readyState</span> == <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                es = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;http://localhost:8080/events&quot;</span>, &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;);</span></span><br><span class="line"><span class="language-javascript">                es.<span class="title function_">addEventListener</span>(<span class="string">&quot;test-event&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                        .<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;li&gt;&quot;</span> + e.<span class="property">data</span> + <span class="string">&quot;&lt;/li&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                es.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// readyState说明</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 0：浏览器与服务端尚未建立连接或连接已被关闭</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readyState = &quot;</span> + e.<span class="property">currentTarget</span>.<span class="property">readyState</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (es.<span class="property">readyState</span> == <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="built_in">setTimeout</span>(initES, <span class="number">5000</span>)</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">initES</span>()</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sse 服务器发送事件(Server-Sent Events)，服务端向客</summary>
      
    
    
    
    <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
    <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（五）：grpc调试工具</title>
    <link href="https://www.silenceboy.com/2023/06/26/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Agrpc%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.silenceboy.com/2023/06/26/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Agrpc%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</id>
    <published>2023-06-26T02:38:01.000Z</published>
    <updated>2023-07-21T05:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p>平时我们编写http的api接口时能够很方便的通过postman工具进行接口调试，那么grpc接口是否也有类似postman的工具可以调试呐？<br>当然可以，github上有一款工具<a href="https://github.com/fullstorydev/grpcui">grpcui</a>，专门用来在浏览器中进行grpc接口调试。</p><h2 id="安装grpcui工具"><a href="#安装grpcui工具" class="headerlink" title="安装grpcui工具"></a>安装grpcui工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/fullstorydev/grpcui/cmd/grpcui@latest</span><br></pre></td></tr></table></figure><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><p>我们以<code>demo_1</code>测试代码为例进行调试。首先在项目中安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/fullstorydev/grpcui</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br></pre></td></tr></table></figure><h3 id="启动grpcui"><a href="#启动grpcui" class="headerlink" title="启动grpcui"></a>启动grpcui</h3><p>另起一个终端，执行一下命令，注意这里的端口号要和grpc服务端口号保持一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grpcui -plaintext 127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>如果你在执行以上命令的时候出现一下报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to compute set of methods to expose: server does not support the reflection API</span><br></pre></td></tr></table></figure><p>需要在<code>server/main.go</code>文件中添加如下代码，增加反射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection.Register(s)</span><br></pre></td></tr></table></figure><p>此时再运行以上启动grpcui命令，可看到一下输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gRPC Web UI available at http://127.0.0.1:41619/</span><br><span class="line">Opening in existing browser session.</span><br></pre></td></tr></table></figure><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>浏览器打开<code>http://127.0.0.1:41619/</code> ,可以看到grpcui调试页面：<br><img src="/../images/2023-06-18_15-34.png"></p><p>点击<code>Invoke</code>按钮，可以看到<code>Response</code>tab页有对于的相应数据：<br><img src="/../images/2023-06-18_15-36.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时我们编写http的api接口时能够很方便的通过postman工具进行接</summary>
      
    
    
    
    <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
    <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（四）：双向流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8F%8C%E5%90%91%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8F%8C%E5%90%91%E6%B5%81%E5%BC%8Frpc/</id>
    <published>2023-06-18T07:13:21.000Z</published>
    <updated>2023-07-21T05:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_4">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_4</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> demo_4 &amp;&amp; <span class="built_in">cd</span> demo_4</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;/helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Hello</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (stream HelloRequest) <span class="keyword">returns</span> (stream HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/silenceboychen/gostudy/demo_4/helloworld&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;The server port&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(stream helloworld.Hello_SayHelloServer) <span class="type">error</span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = stream.Send(&amp;helloworld.HelloReply&#123;</span><br><span class="line">Message: <span class="string">&quot;server stream: &quot;</span> + res.GetName() + <span class="string">&quot;_&quot;</span> + strconv.Itoa(n),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">n++</span><br><span class="line">log.Printf(<span class="string">&quot;client stream: %s&quot;</span>, res.GetName())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/silenceboychen/gostudy/demo_4/helloworld&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">name = flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">_, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;stream err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: *name + <span class="string">&quot;_&quot;</span> + strconv.Itoa(n)&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;client stream err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;server stream err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印返回值</span></span><br><span class="line">log.Println(res.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stream.CloseSend()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;close stream err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:51:39 server listening at [::]:8080</span><br><span class="line">2023/06/16 20:51:42 client stream: world_0</span><br><span class="line">2023/06/16 20:51:42 client stream: world_1</span><br><span class="line">2023/06/16 20:51:42 client stream: world_2</span><br><span class="line">2023/06/16 20:51:42 client stream: world_3</span><br><span class="line">2023/06/16 20:51:42 client stream: world_4</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:51:42 server stream: world_0_0</span><br><span class="line">2023/06/16 20:51:42 server stream: world_1_1</span><br><span class="line">2023/06/16 20:51:42 server stream: world_2_2</span><br><span class="line">2023/06/16 20:51:42 server stream: world_3_3</span><br><span class="line">2023/06/16 20:51:42 server stream: world_4_4</span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍grpc调试工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流</summary>
      
    
    
    
    <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
    <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
</feed>
