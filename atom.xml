<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  <subtitle>morty&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.silenceboy.com/"/>
  <updated>2025-08-27T05:59:07.894Z</updated>
  <id>https://www.silenceboy.com/</id>
  
  <author>
    <name>morty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSE与Streamable HTTP：MCP 背后的传输技术</title>
    <link href="https://www.silenceboy.com/2025/08/27/SSE%E4%B8%8EStreamable-HTTP%EF%BC%9AMCP-%E8%83%8C%E5%90%8E%E7%9A%84%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.silenceboy.com/2025/08/27/SSE与Streamable-HTTP：MCP-背后的传输技术/</id>
    <published>2025-08-27T03:06:46.000Z</published>
    <updated>2025-08-27T05:59:07.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MCP-使用的传输协议背后的历史"><a href="#MCP-使用的传输协议背后的历史" class="headerlink" title="MCP 使用的传输协议背后的历史"></a>MCP 使用的传输协议背后的历史</h1><p>MCP（模型上下文协议）是当今最流行、应用最广泛的人工智能协议之一，它从 2025-03-26 版本开始，用 <code>Streamable HTTP</code> 取代了 <code>HTTP+SSE</code> 传输机制。这标志着该协议架构的重大变革。</p><p>现在，在解释这两种传输机制的含义之前，让我们先更好地理解这一变化。</p><h2 id="为什么AI协议需要传输机制"><a href="#为什么AI协议需要传输机制" class="headerlink" title="为什么AI协议需要传输机制"></a>为什么AI协议需要传输机制</h2><p>像 MCP 这样的 AI 协议需要传输机制来促进协议架构中不同组件之间的信息交换。</p><p>具体来说，MCP 使用 <code>JSON-RPC 2.0</code> 作为客户端和服务器之间的连接格式。对于 <code>JSON-RPC</code> 消息的传输，它依赖于标准传输机制，如 <code>HTTP+SSE</code> 或 <code>Streamable HTTP</code>（在 stdio 中 - 用于通过本地服务器上的标准输入和标准输出进行通信）。</p><p>这些专用的传输层是必需的，因为传统 HTTP 的请求-响应模型对于实时 AI 通信来说效率低下。这是因为纯 HTTP 频繁建立连接会导致高开销和延迟。相比之下，MCP 需要连续、低延迟的数据流——<code>HTTP+SSE</code> 和 <code>Streamable HTTP</code> 正是为此而设计的。</p><h2 id="为什么从-SSE-转变到-Streamable-HTTP"><a href="#为什么从-SSE-转变到-Streamable-HTTP" class="headerlink" title="为什么从 SSE 转变到 Streamable HTTP"></a>为什么从 <code>SSE</code> 转变到 <code>Streamable HTTP</code></h2><p>MCP 最初使用 <code>HTTP+SSE</code> 来实现远程场景下的服务器到客户端的流式传输。然而，以下三个主要限制使得这一改变变得合理：</p><ul><li><strong>不支持可恢复流</strong>：无法从断开处恢复数据流。</li><li><strong>需要维护长连接</strong>：服务器需要维护长时间的、高可用的连接，消耗资源，尤其是在大 规模部署时。</li><li><strong>仅允许通过 SSE 传递服务器消息</strong>：客户端必须使用单独的 HTTP POST 请求发送消息， 无法在同一通道内双向通信。</li></ul><p><code>Streamable HTTP</code> 解决了这些问题。它支持无状态通信，甚至支持按需升级到 <code>SSE</code>。这提高了与现代基础设施的兼容性，并确保了更稳定、更高效的通信。同时，这一转变体现了 MCP 在追求以下目标：</p><ul><li><strong>提升可伸缩性</strong>：通过支持无状态服务器和减少长连接依赖，MCP 能够更好地应对大规模并发请求，为 AI 服务的爆发式增长提供坚实基础。</li><li><strong>增强鲁棒性</strong>：可恢复流的引入，使得 MCP 在面对不稳定的网络环境时，依然能够保证数据传输的可靠性，减少因网络问题导致的数据丢失或服务中断。</li><li><strong>优化资源利用</strong>：减少长连接的维护成本，使得服务器资源能够更高效地分配和利用，降低运营成本。</li><li><strong>拥抱未来趋势</strong>：Streamable HTTP 与现代 Web 技术栈和云原生架构更加契合，为 MCP 未来的发展和与其他技术的融合提供了更广阔的空间。</li></ul><h1 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h1><p><code>SSE</code>（Server-Sent Events）是一种允许 Web 客户端从服务器接收自动更新的机制。这些更新被称为“事件”，并通过单个长寿命 HTTP 连接发送。</p><p>与<code>WebSockets</code> 不同，<code>SSE</code> 是单向的，这意味着数据仅从服务器流向客户端。SSE 的工作原理是服务器通过此开放连接发送事件流，通常格式为<code>text/event-stream</code>MIME类型。</p><h2 id="在-MCP-中使用-HTTP-SSE"><a href="#在-MCP-中使用-HTTP-SSE" class="headerlink" title="在 MCP 中使用 HTTP+SSE"></a>在 <code>MCP</code> 中使用 <code>HTTP+SSE</code></h2><p><img src="../images/sse.png" alt="sse"></p><p>服务器必须提供两个端点：</p><ol><li>客户端用于建立连接并从服务器接收消息的 <code>SSE GET</code> 端点。</li><li>客户端向服务器发送 <code>JSON-RPC</code> 消息的常规 <code>HTTP POST</code> 端点。</li></ol><p>当客户端连接时，服务器必须发送一个端点事件，其中包含客户端将用于发送消息的 URI。所有客户端 <code>JSON-RPC</code> 消息都将作为 <code>HTTP POST</code> 请求发送到此 URI。</p><p>服务器通过打开的 <code>SSE</code> 连接发送流式事件来响应，模拟持久会话。具体来说，服务器消息以 <code>SSE</code> 消息事件的形式传递，其内容在事件数据中以 JSON 格式编码。</p><p>对于单个响应，服务器发送消息并关闭流。对于正在进行的通信，连接保持打开状态。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p><ul><li>流式传输大量结果：允许立即发送部分结果，允许立即发送部分结果，避免 <code>MCP</code> 工具处理大量数据或等待外部 API 响应时的延迟。</li><li>事件驱动触发器：支持未经请求的服务器事件，通过警报或状态更新通知客户端有关更改。</li><li>简单：使用标准 HTTP，无需特殊协议或复杂设置。</li></ul><p>缺点：</p><ul><li>仅限单向：数据只能在 SSE 通道中从服务器流向客户端。客户端必须使用单独的 <code>HTTP POST</code> 请求来发送消息。</li><li>长连接资源使用：维护开放连接会消耗大量服务器资源，尤其是在大规模连接时。</li></ul><h1 id="Streamable-HTTP"><a href="#Streamable-HTTP" class="headerlink" title="Streamable HTTP"></a>Streamable HTTP</h1><p>在 <code>MCP</code> 的语境中，<code>Streamable HTTP</code> 是一种使用纯 HTTP 在客户端和服务器之间传输流式数据的方法。它为实时通信打开了大门，无需长连接。</p><p>虽然它仍然可以使用 <code>SSE</code> 来实现灵活性和向后兼容性，但不再需要该传输方式。这使得 MCP 能够支持无状态服务器，而无需维护高可用性持久连接的开销。</p><blockquote><p>为什么是Streamable HTTP + 可选 SSE 而不是 WebSockets？</p><ol><li>避免不必要的开销：对于简单的 RPC 调用或数据流，WebSocket 的全双工特性可能引入不必要的协议开销和复杂性。Streamable HTTP 在保持流式传输能力的同时，更加轻量。</li><li>更好的 HTTP 兼容性：WebSocket 的协议升级机制有时会与现有的 HTTP 基础设施（如代理、负载均衡器）产生兼容性问题，并且浏览器无法直接在 WebSocket 连接上附加 HTTP 头（如 Authorization）。Streamable HTTP 则完全兼容 HTTP，避免了这些问题。</li><li>POST 请求的灵活性：WebSocket 的升级握手主要基于 GET 请求，这使得基于 POST 的复杂交互流程实现起来较为繁琐。Streamable HTTP 则对 POST 和 GET 请求都提供了良好的支持。</li></ol></blockquote><h2 id="在-MCP-中使用-Streamable-HTTP"><a href="#在-MCP-中使用-Streamable-HTTP" class="headerlink" title="在 MCP 中使用 Streamable HTTP"></a>在 <code>MCP</code> 中使用 <code>Streamable HTTP</code></h2><p>在 <code>Streamable HTTP</code> 传输中，服务器作为一个独立进程，能够处理多个客户端连接。它使用标准的 HTTP <code>POST</code> 和 <code>GET</code> 请求进行通信。</p><p>服务器可以选择使用 <code>SSE</code> 将多条消息流式传输到客户端。这既适用于用于简单请求/响应工具的基本 MCP 服务器，也适用于提供更高级功能（例如流式传输和实时服务器到客户端通知）的服务器。</p><p>服务器必须公开一个支持 <code>POST</code> 和 <code>GET</code> 方法的 HTTP 端点（称为 “MCP 端点“）。</p><p>下图说明了使用 <code>Streamable HTTP</code> 的 MCP 客户端和服务器之间的通信流程：</p><p><img src="../images/streamable-http.png" alt></p><p>为了支持恢复断开的连接并重新传递可能丢失的消息，MCP 服务器会为每个流分配 ID。这些 ID 在每个流中充当游标。</p><h2 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p><ul><li>支持无状态服务器：无需始终在线的长连接。</li><li>纯 HTTP：可以使用任何标准 HTTP 服务器实现，而无需 <code>SSE</code>。</li><li>基础设施友好：与常见的 HTTP 中间件、代理和托管平台兼容。</li><li>向后兼容：在以前的 <code>HTTP+SSE</code> 传输基础上逐步构建。</li><li>可选流式传输：服务器可在需要时升级为 <code>SSE</code>，以实现流式传输响应。</li><li>解决 SSE 局限性：支持可恢复流，无需维护长连接，且允许客户端和服务器在同一 HTTP 端点进行通信（通过 POST 和 GET）。</li><li>效率更高：对于大负载或自定义二进制协议，数据传输更高效，没有 SSE 的事件格式 开销。</li><li>更强的控制力：应用可以更精细地控制缓冲策略，可能减少内存开销。</li></ul><p>缺点：</p><ul><li>暂无</li></ul><h1 id="SSE-与Streamable-HTTP对比"><a href="#SSE-与Streamable-HTTP对比" class="headerlink" title="SSE 与Streamable HTTP对比"></a>SSE 与Streamable HTTP对比</h1><table><thead><tr><th>类型</th><th>HTTP+SSE</th><th>Streamable HTTP</th></tr></thead><tbody><tr><td>通信类型</td><td>单向（服务器→客户端）</td><td>双向（客户端通过 GET/POST ↔ 服务器）</td></tr><tr><td>HTTP 协议的使用</td><td>GET 用于流媒体，POST 用于客户端信息</td><td>从一个端点使用标准 HTTP POST 和 GET</td></tr><tr><td>状态性</td><td>有状态</td><td>有状态，但支持无状态服务器</td></tr><tr><td>需要长期 HTTP 连接</td><td>是</td><td>否</td></tr><tr><td>要求高可用性</td><td>是，用于连接持久性</td><td>否，适用于无状态或临时服务器</td></tr><tr><td>可扩展性</td><td>有限</td><td>高</td></tr><tr><td>流媒体支持</td><td>是（通过文本/事件流）</td><td>是（通过 SSE 作为可选增强功能）</td></tr><tr><td>身份验证支持</td><td>是</td><td>是</td></tr><tr><td>支持可恢复性和重新交付</td><td>没有</td><td>没有</td></tr><tr><td>客户数量</td><td>多个</td><td>多个</td></tr><tr><td>在 MCP 中的使用</td><td>自协议版本 2025-03-26 起已弃用</td><td>在 2025-03-26 版协议中引入</td></tr><tr><td>向后兼容性</td><td>-</td><td>完全向后兼容基于 SSE 的客户端</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MCP-使用的传输协议背后的历史&quot;&gt;&lt;a href=&quot;#MCP-使用的传输协议背后的历史&quot; class=&quot;headerlink&quot; title=&quot;MCP 使用的传输协议背后的历史&quot;&gt;&lt;/a&gt;MCP 使用的传输协议背后的历史&lt;/h1&gt;&lt;p&gt;MCP（模型上下文协议）是当
      
    
    </summary>
    
      <category term="mcp" scheme="https://www.silenceboy.com/categories/mcp/"/>
    
    
      <category term="mcp" scheme="https://www.silenceboy.com/tags/mcp/"/>
    
      <category term="AI" scheme="https://www.silenceboy.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>命令帮手：tldr 安装与中文配置指南</title>
    <link href="https://www.silenceboy.com/2025/05/09/%E5%91%BD%E4%BB%A4%E5%B8%AE%E6%89%8B%EF%BC%9Atldr-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%B8%AD%E6%96%87%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>https://www.silenceboy.com/2025/05/09/命令帮手：tldr-安装与中文配置指南/</id>
    <published>2025-05-09T05:39:38.000Z</published>
    <updated>2025-05-09T05:50:09.722Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发与运维过程中，你是否会觉得传统的 man 手册过于繁琐？<a href="https://tldr.sh/" target="_blank" rel="noopener">tldr</a> 项目正是为了解决这个问题而生，它为上百个常用命令提供了简明直观的示例，极大地提升了查阅效率。本文将手把手介绍 tldr 在 Windows、Mac、Ubuntu 下的安装流程，基本使用方法，以及如何让 tldr 输出为简体中文。</p><h2 id="一、tldr-安装方法"><a href="#一、tldr-安装方法" class="headerlink" title="一、tldr 安装方法"></a>一、tldr 安装方法</h2><h3 id="1-Windows-系统"><a href="#1-Windows-系统" class="headerlink" title="1. Windows 系统"></a>1. Windows 系统</h3><h4 id="方法一：用-Scoop-安装（推荐）"><a href="#方法一：用-Scoop-安装（推荐）" class="headerlink" title="方法一：用 Scoop 安装（推荐）"></a>方法一：用 Scoop 安装（推荐）</h4><ol><li><p>安装 <a href="https://scoop.sh/" target="_blank" rel="noopener">Scoop</a>（如果还没装）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br><span class="line">irm get.scoop.sh | iex</span><br></pre></td></tr></table></figure></li><li><p>安装 tldr：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install tldr</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法二：用-npm-安装"><a href="#方法二：用-npm-安装" class="headerlink" title="方法二：用 npm 安装"></a>方法二：用 npm 安装</h4><p>需先装好 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 与 npm，然后在命令行执行：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> tldr</span><br></pre></td></tr></table></figure></p><h4 id="方法三：用-pip-安装"><a href="#方法三：用-pip-安装" class="headerlink" title="方法三：用 pip 安装"></a>方法三：用 pip 安装</h4><p>需先装好python与pip，然后在命令行执行：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure></p><h3 id="2-macOS-系统"><a href="#2-macOS-系统" class="headerlink" title="2. macOS 系统"></a>2. macOS 系统</h3><p>推荐使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tldr</span><br></pre></td></tr></table></figure><p>或者用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tldr</span><br></pre></td></tr></table></figure><p>或者用 pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><h3 id="3-Ubuntu-Debian-系统"><a href="#3-Ubuntu-Debian-系统" class="headerlink" title="3. Ubuntu / Debian 系统"></a>3. Ubuntu / Debian 系统</h3><p>推荐方式（snap 安装）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install tldr</span><br></pre></td></tr></table></figure><p>或者用 apt（部分老版本仓库没有）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install tldr</span><br></pre></td></tr></table></figure><p>还可以用 npm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tldr</span><br></pre></td></tr></table></figure><p>或者用 pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><h2 id="二、tldr-的基本使用"><a href="#二、tldr-的基本使用" class="headerlink" title="二、tldr 的基本使用"></a>二、tldr 的基本使用</h2><p>安装好 tldr 后，在命令行中直接输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr 命令名</span><br></pre></td></tr></table></figure><p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr tar</span><br></pre></td></tr></table></figure></p><p>它会显示 tar 常用的简要用法和示例。</p><p>常用选项：</p><ul><li><code>tldr -u</code><br>强制更新离线文档缓存。</li><li><code>tldr --list</code><br>查看有哪些命令有 tldr 页面。</li><li><code>tldr --help</code><br>查看 tldr 的详细帮助信息。</li></ul><h2 id="三、配置-tldr-显示中文页面"><a href="#三、配置-tldr-显示中文页面" class="headerlink" title="三、配置 tldr 显示中文页面"></a>三、配置 tldr 显示中文页面</h2><p>tldr 官方已支持多语言，目前大部分主流命令已有简体中文文档。只需调整默认语言环境变量即可。</p><h3 id="1-临时使用中文"><a href="#1-临时使用中文" class="headerlink" title="1. 临时使用中文"></a>1. 临时使用中文</h3><p>只对当前命令生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=zh tldr ls</span><br></pre></td></tr></table></figure><p>或（部分 tldr 客户端支持）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE=zh tldr ls</span><br></pre></td></tr></table></figure></p><h3 id="2-永久设置为中文"><a href="#2-永久设置为中文" class="headerlink" title="2. 永久设置为中文"></a>2. 永久设置为中文</h3><h4 id="macOS-Ubuntu-WSL"><a href="#macOS-Ubuntu-WSL" class="headerlink" title="macOS / Ubuntu / WSL"></a>macOS / Ubuntu / WSL</h4><p>将下方内容添加到 <code>~/.bashrc</code> 或 <code>~/.zshrc</code>（具体看你用哪个 shell）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=zh</span><br></pre></td></tr></table></figure><p>保存后，执行一次：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc    <span class="comment"># 或 source ~/.zshrc</span></span><br></pre></td></tr></table></figure></p><p>这样每次开新终端，tldr 默认输出中文页面。</p><h4 id="Windows（CMD-或-PowerShell）"><a href="#Windows（CMD-或-PowerShell）" class="headerlink" title="Windows（CMD 或 PowerShell）"></a>Windows（CMD 或 PowerShell）</h4><p><strong>CMD 中临时生效：</strong><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> LANG=zh</span><br><span class="line">tldr ls</span><br></pre></td></tr></table></figure></p><p><strong>长期生效</strong>：<br>在系统环境变量或用户环境变量中添加 <code>LANG</code>，值填 <code>zh</code>。</p><h3 id="3-更新缓存（非常重要）"><a href="#3-更新缓存（非常重要）" class="headerlink" title="3. 更新缓存（非常重要）"></a>3. 更新缓存（非常重要）</h3><p>修改语言后，强烈建议刷新缓存让中文页面生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr -u</span><br></pre></td></tr></table></figure><h3 id="4-验证效果"><a href="#4-验证效果" class="headerlink" title="4. 验证效果"></a>4. 验证效果</h3><p>运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr cp</span><br></pre></td></tr></table></figure></p><p>如果出现中文简明用法，表明配置成功。</p><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><ul><li><strong>部分命令还是英文？</strong><br>可能该命令尚未有中文翻译。同样建议及时更新缓存。</li><li><strong>未知命令提示或无法联网？</strong><br>检查网络或采用 <code>tldr --update</code> 手动补全离线缓存。</li><li><strong>Windows 环境变量生效问题？</strong><br>尝试重启终端或电脑，确认语言变量设置无误。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>tldr 是极简而实用的命令行速查工具，无论软件开发者还是 Linux/Unix/Windows 运维者都能从中获益。通过简单的安装和配置，你就能轻松查阅常见命令的简明用法，还能设为汉语输出，降低理解难度，为高效开发助力。</p><blockquote><p><strong>扩展阅读：</strong></p><ul><li>官方网站：<a href="https://tldr.sh/" target="_blank" rel="noopener">https://tldr.sh/</a></li><li>GitHub 项目：<a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常开发与运维过程中，你是否会觉得传统的 man 手册过于繁琐？&lt;a href=&quot;https://tldr.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tldr&lt;/a&gt; 项目正是为了解决这个问题而生，它为上百个常用命令提供了简明直观的示例，极大
      
    
    </summary>
    
      <category term="shell" scheme="https://www.silenceboy.com/categories/shell/"/>
    
    
      <category term="shell" scheme="https://www.silenceboy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Python魔法方法介绍</title>
    <link href="https://www.silenceboy.com/2025/04/25/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.silenceboy.com/2025/04/25/Python魔法方法介绍/</id>
    <published>2025-04-25T06:34:11.000Z</published>
    <updated>2025-04-25T06:35:45.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是魔法方法"><a href="#1-什么是魔法方法" class="headerlink" title="1. 什么是魔法方法"></a>1. 什么是魔法方法</h2><p>魔法方法是指<strong>前后都有双下划线</strong>的特殊方法，例如 <strong>init</strong>、<strong>new</strong>、<strong>str</strong> 等。这些方法是 Python 内部预定义的，将它们以特定名字命名，是为了配合 Python 的特性（如对象创建、属性访问、运算符重载等）实现自定义行为。</p><h2 id="2-常见魔法方法类别与功能"><a href="#2-常见魔法方法类别与功能" class="headerlink" title="2. 常见魔法方法类别与功能"></a>2. 常见魔法方法类别与功能</h2><h3 id="a-对象的构造与销毁"><a href="#a-对象的构造与销毁" class="headerlink" title="a) 对象的构造与销毁"></a>a) 对象的构造与销毁</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>常用场景</th></tr></thead><tbody><tr><td><code>__new__</code></td><td>实例创建，返回一个新对象</td><td>单例、元类、自定义创建流程</td></tr><tr><td><code>__init__</code></td><td>实例初始化，设置属性等</td><td>常规对象初始化</td></tr><tr><td><code>__del__</code></td><td>实例删除前调用（析构函数）</td><td>资源释放、日志等</td></tr></tbody></table><h3 id="b-字符串与可打印表现"><a href="#b-字符串与可打印表现" class="headerlink" title="b) 字符串与可打印表现"></a>b) 字符串与可打印表现</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>常用场景</th></tr></thead><tbody><tr><td><code>__str__</code></td><td>str(obj)、print(obj) 时的表现</td><td>用户友好信息</td></tr><tr><td><code>__repr__</code></td><td>repr(obj)、调试器、解释器中直接输入对象时的表现</td><td>开发调试、复现对象</td></tr></tbody></table><h3 id="c-运算符重载"><a href="#c-运算符重载" class="headerlink" title="c) 运算符重载"></a>c) 运算符重载</h3><p>使实例自定义如何参与各种运算：</p><table><thead><tr><th>魔法方法</th><th>覆盖的运算符</th><th>例子</th></tr></thead><tbody><tr><td><code>__add__</code></td><td>+</td><td>a + b</td></tr><tr><td><code>__sub__</code></td><td>-</td><td>a - b</td></tr><tr><td><code>__mul__</code></td><td>*</td><td>a * b</td></tr><tr><td><code>__truediv__</code></td><td>/</td><td>a / b</td></tr><tr><td><code>__floordiv__</code></td><td>//</td><td>a // b</td></tr><tr><td><code>__mod__</code></td><td>%</td><td>a % b</td></tr><tr><td><code>__pow__</code></td><td>**</td><td>a ** b</td></tr><tr><td><code>__eq__</code></td><td>==</td><td>a == b</td></tr><tr><td><code>__ne__</code></td><td>!=</td><td>a != b</td></tr><tr><td><code>__lt__</code></td><td>&lt;</td><td>a &lt; b</td></tr><tr><td><code>__gt__</code></td><td>&gt;</td><td>a &gt; b</td></tr><tr><td><code>__le__</code></td><td>&lt;=</td><td>a &lt;= b</td></tr></tbody></table><p>还有很多，比如逻辑运算（<code>__and__</code>, <code>__or__</code> 等）、反向运算（如 <code>__radd__</code>)等。</p><h3 id="d-集合与映射接口"><a href="#d-集合与映射接口" class="headerlink" title="d) 集合与映射接口"></a>d) 集合与映射接口</h3><p>用于容器类的自定义：</p><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>使用方式</th></tr></thead><tbody><tr><td><code>__len__</code></td><td>求长度</td><td>len(obj)</td></tr><tr><td><code>__getitem__</code></td><td>获取指定元素</td><td>obj[key]</td></tr><tr><td><code>__setitem__</code></td><td>设置值</td><td>obj[key]=value</td></tr><tr><td><code>__delitem__</code></td><td>删除项</td><td>del obj[key]</td></tr><tr><td><code>__contains__</code></td><td>in/not in 查询</td><td>item in obj</td></tr><tr><td><code>__iter__</code></td><td>返回迭代器</td><td>for x in obj</td></tr><tr><td><code>__next__</code></td><td>迭代器的下一个值</td><td>next(iterator)</td></tr></tbody></table><h3 id="e-上下文管理"><a href="#e-上下文管理" class="headerlink" title="e) 上下文管理"></a>e) 上下文管理</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>使用方式</th></tr></thead><tbody><tr><td><code>__enter__</code></td><td>进入上下文、with块前调用</td><td>with obj as xxx</td></tr><tr><td><code>__exit__</code></td><td>离开上下文、with块后调用</td></tr></tbody></table><h3 id="f-可调用对象相关"><a href="#f-可调用对象相关" class="headerlink" title="f) 可调用对象相关"></a>f) 可调用对象相关</h3><table><thead><tr><th>魔法方法</th><th>作用描述</th><th>示例</th></tr></thead><tbody><tr><td><code>__call__</code></td><td>让实例像函数一样可调用</td><td>obj()</td></tr></tbody></table><h3 id="g-其他常用魔法方法"><a href="#g-其他常用魔法方法" class="headerlink" title="g) 其他常用魔法方法"></a>g) 其他常用魔法方法</h3><ul><li><code>__getattr__</code> / <code>__setattr__</code> / <code>__delattr__</code>：属性访问/设置/删除拦截。</li><li><code>__slots__</code>：限制对象可以有哪些属性，提高内存效率。</li></ul><h2 id="3-魔法方法功能对比表"><a href="#3-魔法方法功能对比表" class="headerlink" title="3. 魔法方法功能对比表"></a>3. 魔法方法功能对比表</h2><table><thead><tr><th>方法</th><th>调用时机/作用</th><th>返回值须</th><th>是否常用</th></tr></thead><tbody><tr><td><code>__new__</code></td><td>创建对象（类-&gt;实例）</td><td>实例 or 其子类</td><td>部分场景</td></tr><tr><td><code>__init__</code></td><td>初始化对象</td><td>None</td><td>常用</td></tr><tr><td><code>__del__</code></td><td>删除对象时</td><td>None</td><td>偶尔</td></tr><tr><td><code>__str__</code></td><td>str/print</td><td>str</td><td>常用</td></tr><tr><td><code>__repr__</code></td><td>repr()，交互式解释器</td><td>str</td><td>常用</td></tr><tr><td><code>__add__</code></td><td>a+b</td><td>任意</td><td>按需</td></tr><tr><td><code>__getitem__</code></td><td>obj[key]</td><td>任意</td><td>按需</td></tr><tr><td><code>__call__</code></td><td>obj()</td><td>任意</td><td>有趣/高阶</td></tr><tr><td><code>__enter__</code></td><td>with 块开始</td><td>任意</td><td>按需</td></tr><tr><td><code>__exit__</code></td><td>with 块结束</td><td>None/Bool</td><td>按需</td></tr></tbody></table><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>魔法方法本质上让我们可以“像内置类型一样”自定义自己的类行为。</li><li>它们不需要显式调用，由 Python 语法环境/运算符/函数自动调用。</li><li>合理地使用魔法方法，可以让自己的类表现得更“Pythonic”，增加灵活性、可读性与可用性。</li><li>不是所有魔法方法都需要重写，按需选择。</li></ul><p><strong>举例说明：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector2D(self.x + other.x, self.y + other.y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)"</span></span><br><span class="line"></span><br><span class="line">v1 = Vector2D(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">v2 = Vector2D(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(v1 + v2)   <span class="comment"># 自动调用 __add__（输出：(4, 6)）</span></span><br><span class="line">print(str(v1))   <span class="comment"># 自动调用 __str__（输出：(1, 2)）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是魔法方法&quot;&gt;&lt;a href=&quot;#1-什么是魔法方法&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是魔法方法&quot;&gt;&lt;/a&gt;1. 什么是魔法方法&lt;/h2&gt;&lt;p&gt;魔法方法是指&lt;strong&gt;前后都有双下划线&lt;/strong&gt;的特殊方法，例如 
      
    
    </summary>
    
      <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
      <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>取消conda终端默认激活base虚拟环境</title>
    <link href="https://www.silenceboy.com/2025/04/09/%E5%8F%96%E6%B6%88conda%E7%BB%88%E7%AB%AF%E9%BB%98%E8%AE%A4%E6%BF%80%E6%B4%BBbase%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.silenceboy.com/2025/04/09/取消conda终端默认激活base虚拟环境/</id>
    <published>2025-04-09T10:20:02.000Z</published>
    <updated>2025-04-09T10:20:52.786Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，安装完conda后，每次打开终端都会自动激活<code>base</code>环境。如果你不习惯这一行为，可以通过修改conda的相关配置，使终端启动时不再默认激活<code>base</code>环境。</p><h2 id="▶️-临时关闭-auto-activate-当前终端有效"><a href="#▶️-临时关闭-auto-activate-当前终端有效" class="headerlink" title="▶️ 临时关闭 auto activate (当前终端有效)"></a>▶️ 临时关闭 auto activate (当前终端有效)</h2><p>如果你只是想一次性临时地关闭，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>但是这种方式仅对当前打开的终端临时生效，打开新的终端窗口时，<code>base</code>还是会自动激活。</p><h2 id="✅-长期永久关闭默认激活-推荐"><a href="#✅-长期永久关闭默认激活-推荐" class="headerlink" title="✅ 长期永久关闭默认激活 (推荐)"></a>✅ 长期永久关闭默认激活 (推荐)</h2><p>要永久关闭每次终端自动激活<code>base</code>环境，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以上命令会修改conda配置文件<code>~/.condarc</code>，添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_activate_base:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以后你每次打开新的终端窗口时，<code>base</code>将不会再自动激活。</p><h2 id="📝-如果你后悔了，如何恢复自动激活base？"><a href="#📝-如果你后悔了，如何恢复自动激活base？" class="headerlink" title="📝 如果你后悔了，如何恢复自动激活base？"></a>📝 如果你后悔了，如何恢复自动激活base？</h2><p>再次启用自动激活：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="🔍-验证你的配置"><a href="#🔍-验证你的配置" class="headerlink" title="🔍 验证你的配置"></a>🔍 验证你的配置</h2><p>执行以下命令验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show | grep auto_activate_base</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_activate_base:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代表成功地关闭了默认激活行为。</p><p>⚠️ <strong>注意</strong>：</p><ul><li>在关闭默认激活之后，如果想激活base或其他虚拟环境，就需要手动运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate base       <span class="comment">#激活base</span></span><br><span class="line">conda activate env_name   <span class="comment">#激活其他环境</span></span><br></pre></td></tr></table></figure><p>按照以上方法，你便可以自由控制conda是否默认激活<code>base</code>环境了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，安装完conda后，每次打开终端都会自动激活&lt;code&gt;base&lt;/code&gt;环境。如果你不习惯这一行为，可以通过修改conda的相关配置，使终端启动时不再默认激活&lt;code&gt;base&lt;/code&gt;环境。&lt;/p&gt;
&lt;h2 id=&quot;▶️-临时关闭-auto-act
      
    
    </summary>
    
      <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
      <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python项目批量检查依赖并添加进requirements文件</title>
    <link href="https://www.silenceboy.com/2025/04/09/python%E9%A1%B9%E7%9B%AE%E6%89%B9%E9%87%8F%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%BF%9Brequirements%E6%96%87%E4%BB%B6/"/>
    <id>https://www.silenceboy.com/2025/04/09/python项目批量检查依赖并添加进requirements文件/</id>
    <published>2025-04-09T01:38:13.000Z</published>
    <updated>2025-04-09T09:04:46.010Z</updated>
    
    <content type="html"><![CDATA[<p>在Python项目中，管理依赖是很重要的工作。下面我介绍几种方法，可以帮助你批量检查项目依赖并更新requirements文件。</p><h2 id="1-使用pipreqs自动生成requirements-txt"><a href="#1-使用pipreqs自动生成requirements-txt" class="headerlink" title="1. 使用pipreqs自动生成requirements.txt"></a>1. 使用pipreqs自动生成requirements.txt</h2><p>pipreqs是一个很好的工具，它能分析你的代码并只生成项目实际使用的依赖列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pipreqs</span></span><br><span class="line">pip install pipreqs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在项目根目录运行</span></span><br><span class="line">pipreqs . --force  <span class="comment"># --force选项会覆盖已存在的requirements.txt</span></span><br></pre></td></tr></table></figure><p>这个工具的优点是它只包含代码中实际导入的包，而不是环境中安装的所有包。</p><h2 id="2-使用pip-tools管理依赖"><a href="#2-使用pip-tools管理依赖" class="headerlink" title="2. 使用pip-tools管理依赖"></a>2. 使用pip-tools管理依赖</h2><p>pip-tools提供了两个命令：<code>pip-compile</code>和<code>pip-sync</code>，可以更精确地管理依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pip-tools</span></span><br><span class="line">pip install pip-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个requirements.in文件，列出主要依赖</span></span><br><span class="line"><span class="comment"># 然后生成详细的requirements.txt</span></span><br><span class="line">pip-compile requirements.in</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持环境与requirements.txt同步</span></span><br><span class="line">pip-sync</span><br></pre></td></tr></table></figure><p>这种方法的优点是可以区分直接依赖和间接依赖，并且锁定所有包的版本。</p><h2 id="3-检查项目中缺少的依赖"><a href="#3-检查项目中缺少的依赖" class="headerlink" title="3. 检查项目中缺少的依赖"></a>3. 检查项目中缺少的依赖</h2><p>可以使用pylint或其他静态分析工具来查找可能缺少的导入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装pylint</span></span><br><span class="line">pip install pylint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描项目</span></span><br><span class="line">pylint --<span class="built_in">disable</span>=all --<span class="built_in">enable</span>=no-name-in-module,import-error path/to/your/project</span><br></pre></td></tr></table></figure><h2 id="4-自动化脚本示例"><a href="#4-自动化脚本示例" class="headerlink" title="4. 自动化脚本示例"></a>4. 自动化脚本示例</h2><p>你可以创建一个脚本来自动执行这些步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">自动检查和更新项目依赖，并添加到requirements.txt文件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    <span class="comment"># 确保pip-tools已安装</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> piptools</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        print(<span class="string">"安装 pip-tools..."</span>)</span><br><span class="line">        subprocess.check_call([sys.executable, <span class="string">"-m"</span>, <span class="string">"pip"</span>, <span class="string">"install"</span>, <span class="string">"pip-tools"</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用pipreqs分析项目依赖</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> pipreqs</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        print(<span class="string">"安装 pipreqs..."</span>)</span><br><span class="line">        subprocess.check_call([sys.executable, <span class="string">"-m"</span>, <span class="string">"pip"</span>, <span class="string">"install"</span>, <span class="string">"pipreqs"</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成临时requirements文件</span></span><br><span class="line">    print(<span class="string">"分析项目依赖..."</span>)</span><br><span class="line">    subprocess.check_call([<span class="string">"pipreqs"</span>, <span class="string">"."</span>, <span class="string">"--savepath"</span>, <span class="string">"requirements.temp.txt"</span>, <span class="string">"--force"</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取现有的requirements.txt (如果存在)</span></span><br><span class="line">    existing_reqs = set()</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"requirements.txt"</span>):</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"requirements.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                line = line.strip()</span><br><span class="line">                <span class="keyword">if</span> line <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">"#"</span>):</span><br><span class="line">                    existing_reqs.add(line.split(<span class="string">"=="</span>)[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取新生成的requirements</span></span><br><span class="line">    new_reqs = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"requirements.temp.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="keyword">if</span> line <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">"#"</span>):</span><br><span class="line">                new_reqs.append(line)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并并分类</span></span><br><span class="line">    main_deps = []</span><br><span class="line">    <span class="keyword">for</span> req <span class="keyword">in</span> new_reqs:</span><br><span class="line">        pkg_name = req.split(<span class="string">"=="</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> pkg_name <span class="keyword">not</span> <span class="keyword">in</span> existing_reqs:</span><br><span class="line">            main_deps.append(<span class="string">f"<span class="subst">&#123;req&#125;</span>  # 新添加的依赖"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            main_deps.append(req)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 写入最终的requirements.txt</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"requirements.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">"# 主要依赖 - 项目直接使用\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> dep <span class="keyword">in</span> sorted(main_deps):</span><br><span class="line">            f.write(<span class="string">f"<span class="subst">&#123;dep&#125;</span>\n"</span>)</span><br><span class="line">        f.write(<span class="string">"\n# 根据实际需要添加开发和测试依赖\n"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清理临时文件</span></span><br><span class="line">    os.remove(<span class="string">"requirements.temp.txt"</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"完成! requirements.txt 已更新。"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将这个脚本保存为<code>update_requirements.py</code>，然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python update_requirements.py</span><br></pre></td></tr></table></figure><h2 id="5-整合进Makefile"><a href="#5-整合进Makefile" class="headerlink" title="5. 整合进Makefile"></a>5. 整合进Makefile</h2><p>如果你的项目使用Makefile，可以添加一个目标来更新依赖：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: update-deps</span></span><br><span class="line"></span><br><span class="line"><span class="section">update-deps:</span></span><br><span class="line">@echo <span class="string">"更新项目依赖..."</span></span><br><span class="line">pip install pipreqs</span><br><span class="line">pipreqs . --force</span><br><span class="line">@echo <span class="string">"依赖已更新到requirements.txt"</span></span><br></pre></td></tr></table></figure><h2 id="6-对于复杂项目的建议"><a href="#6-对于复杂项目的建议" class="headerlink" title="6. 对于复杂项目的建议"></a>6. 对于复杂项目的建议</h2><p>对于有多个环境的复杂项目：</p><ol><li>使用<code>pyproject.toml</code>配合<code>setuptools</code>或<code>poetry</code>管理依赖</li><li>区分开发依赖和运行时依赖</li><li>使用虚拟环境确保依赖隔离</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用poetry</span></span><br><span class="line">poetry init  <span class="comment"># 创建pyproject.toml</span></span><br><span class="line">poetry add package1 package2  <span class="comment"># 添加依赖</span></span><br><span class="line">poetry <span class="built_in">export</span> -f requirements.txt --output requirements.txt  <span class="comment"># 导出requirements.txt</span></span><br></pre></td></tr></table></figure><h2 id="7-检查未使用的依赖"><a href="#7-检查未使用的依赖" class="headerlink" title="7. 检查未使用的依赖"></a>7. 检查未使用的依赖</h2><p>可以使用<code>pip-extra-reqs</code>工具检查未使用的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip-extra-reqs</span><br><span class="line">pip-extra-reqs src/</span><br></pre></td></tr></table></figure><p>通过以上步骤，你可以有效地管理项目依赖，确保requirements.txt文件包含所有必要的依赖，同时避免添加不必要的包。无论项目规模大小，这些方法都能帮助你保持依赖的清晰和最新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python项目中，管理依赖是很重要的工作。下面我介绍几种方法，可以帮助你批量检查项目依赖并更新requirements文件。&lt;/p&gt;
&lt;h2 id=&quot;1-使用pipreqs自动生成requirements-txt&quot;&gt;&lt;a href=&quot;#1-使用pipreqs自动生成re
      
    
    </summary>
    
      <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
      <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>本地管理多个python版本</title>
    <link href="https://www.silenceboy.com/2025/03/26/%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AApython%E7%89%88%E6%9C%AC/"/>
    <id>https://www.silenceboy.com/2025/03/26/本地管理多个python版本/</id>
    <published>2025-03-26T12:13:54.000Z</published>
    <updated>2025-04-09T09:04:36.161Z</updated>
    
    <content type="html"><![CDATA[<p>在本地管理多个 Python 版本是开发中的常见需求，以下是几种主流且高效的方法，适用于不同操作系统：</p><hr><h3 id="一、使用-pyenv（推荐给-macOS-Linux-用户）"><a href="#一、使用-pyenv（推荐给-macOS-Linux-用户）" class="headerlink" title="一、使用 pyenv（推荐给 macOS/Linux 用户）"></a>一、使用 <strong>pyenv</strong>（推荐给 macOS/Linux 用户）</h3><p><strong>原理</strong>：通过修改环境变量动态切换 Python 版本，不依赖系统自带的 Python。</p><h4 id="1-安装-pyenv"><a href="#1-安装-pyenv" class="headerlink" title="1. 安装 pyenv"></a>1. 安装 pyenv</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用安装脚本</span></span><br><span class="line">curl https://pyenv.run | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将以下内容添加到 ~/.bashrc 或 ~/.zshrc</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$HOME</span>/.pyenv/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span></span><br></pre></td></tr></table></figure><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可安装版本</span></span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本（如 Python 3.9.6）</span></span><br><span class="line">pyenv install 3.9.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装版本</span></span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局默认版本</span></span><br><span class="line">pyenv global 3.9.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前目录的本地版本（优先级更高）</span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.8.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载版本</span></span><br><span class="line">pyenv uninstall 3.7.0</span><br></pre></td></tr></table></figure><hr><h3 id="二、使用-conda（跨平台，适合科学计算场景）"><a href="#二、使用-conda（跨平台，适合科学计算场景）" class="headerlink" title="二、使用 conda（跨平台，适合科学计算场景）"></a>二、使用 <strong>conda</strong>（跨平台，适合科学计算场景）</h3><p><strong>原理</strong>：通过虚拟环境管理 Python 版本和依赖。</p><h4 id="1-安装-Miniconda-Anaconda"><a href="#1-安装-Miniconda-Anaconda" class="headerlink" title="1. 安装 Miniconda/Anaconda"></a>1. 安装 Miniconda/Anaconda</h4><p>从官网下载安装包：<a href="https://docs.conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">https://docs.conda.io/en/latest/miniconda.html</a></p><h4 id="2-创建不同-Python-版本的环境"><a href="#2-创建不同-Python-版本的环境" class="headerlink" title="2. 创建不同 Python 版本的环境"></a>2. 创建不同 Python 版本的环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 py38 的环境，指定 Python 3.8</span></span><br><span class="line">conda create -n py38 python=3.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">conda activate py38</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有环境</span></span><br><span class="line">conda env list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除环境</span></span><br><span class="line">conda env remove -n py38</span><br></pre></td></tr></table></figure><hr><h3 id="三、使用-Docker（适合隔离开发环境）"><a href="#三、使用-Docker（适合隔离开发环境）" class="headerlink" title="三、使用 Docker（适合隔离开发环境）"></a>三、使用 <strong>Docker</strong>（适合隔离开发环境）</h3><p>通过容器化技术隔离不同项目环境。</p><h4 id="示例-Dockerfile"><a href="#示例-Dockerfile" class="headerlink" title="示例 Dockerfile"></a>示例 Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h4 id="使用不同镜像版本"><a href="#使用不同镜像版本" class="headerlink" title="使用不同镜像版本"></a>使用不同镜像版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Python 3.9 容器</span></span><br><span class="line">docker run -it --rm python:3.9-alpine python --version</span><br></pre></td></tr></table></figure><hr><h3 id="四、Windows-用户的替代方案"><a href="#四、Windows-用户的替代方案" class="headerlink" title="四、Windows 用户的替代方案"></a>四、Windows 用户的替代方案</h3><ol><li><p><strong>pyenv-win</strong>（类似 Unix 的 pyenv）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="literal">-Uri</span> <span class="string">"https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1"</span> <span class="literal">-OutFile</span> <span class="string">"./install-pyenv-win.ps1"</span></span><br><span class="line">&amp; <span class="string">"./install-pyenv-win.ps1"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动安装多个版本</strong>：</p><ul><li>从官网下载不同版本的安装包（如 <code>python-3.8.exe</code> 和 <code>python-3.10.exe</code>）</li><li>安装时勾选 <strong>“Add to PATH”</strong>，但通过修改可执行文件名区分版本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 Python 3.8 的可执行文件重命名</span></span><br><span class="line">mv /path/to/python3.8/python.exe /path/to/python3.8/python38.exe</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="五、通用技巧：虚拟环境-版本指定"><a href="#五、通用技巧：虚拟环境-版本指定" class="headerlink" title="五、通用技巧：虚拟环境 + 版本指定"></a>五、通用技巧：虚拟环境 + 版本指定</h3><p>即使使用系统 Python，也可通过 <code>venv</code> 或 <code>virtualenv</code> 隔离环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用特定 Python 版本创建虚拟环境</span></span><br><span class="line">/path/to/python3.9 -m venv myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate  <span class="comment"># Linux/macOS</span></span><br><span class="line">myenv\Scripts\activate.bat <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="版本管理工具对比"><a href="#版本管理工具对比" class="headerlink" title="版本管理工具对比"></a>版本管理工具对比</h3><table><thead><tr><th>工具</th><th>适用系统</th><th>特点</th></tr></thead><tbody><tr><td><strong>pyenv</strong></td><td>macOS/Linux</td><td>轻量级，纯命令行操作</td></tr><tr><td><strong>conda</strong></td><td>跨平台</td><td>集成包管理，适合科学计算</td></tr><tr><td><strong>Docker</strong></td><td>跨平台</td><td>完全环境隔离，但需学习容器技术</td></tr><tr><td><strong>手动管理</strong></td><td>所有系统</td><td>灵活性高，但维护成本较高</td></tr></tbody></table><p>选择工具时，建议优先使用 <strong>pyenv</strong>（Unix）或 <strong>conda</strong>（跨平台）以简化操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本地管理多个 Python 版本是开发中的常见需求，以下是几种主流且高效的方法，适用于不同操作系统：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、使用-pyenv（推荐给-macOS-Linux-用户）&quot;&gt;&lt;a href=&quot;#一、使用-pyenv（推荐给-macOS-Linux
      
    
    </summary>
    
      <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
      <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pip自动写入requirements的终极方案</title>
    <link href="https://www.silenceboy.com/2025/03/21/pip%E8%87%AA%E5%8A%A8%E5%86%99%E5%85%A5requirements%E7%9A%84%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88/"/>
    <id>https://www.silenceboy.com/2025/03/21/pip自动写入requirements的终极方案/</id>
    <published>2025-03-21T04:50:53.000Z</published>
    <updated>2025-03-21T04:52:40.422Z</updated>
    
    <content type="html"><![CDATA[<p>在Python开发中，手动维护requirements.txt文件容易遗漏依赖项。本文将介绍三种自动化解决方案，让依赖管理更高效。</p><hr><h3 id="方案一：智能Shell别名（原生pip增强）"><a href="#方案一：智能Shell别名（原生pip增强）" class="headerlink" title="方案一：智能Shell别名（原生pip增强）"></a>方案一：智能Shell别名（原生pip增强）</h3><p><strong>实现原理：</strong> 通过Shell函数封装pip命令，在执行安装后自动更新requirements文件</p><p><strong>配置方法（在.bashrc/.zshrc中添加）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pip</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"install"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">command</span> pip <span class="string">"<span class="variable">$@</span>"</span> &amp;&amp; pip freeze --exclude-editable | grep -v <span class="string">'^#'</span> &gt; requirements.txt</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">command</span> pip <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装包并自动记录</span></span><br><span class="line">pip install requests==2.26.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装多个包（支持所有pip参数）</span></span><br><span class="line">pip install django~=3.2.0 celery[redis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发模式安装（不会记录到requirements）</span></span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure></p><p><strong>方案特点：</strong></p><ul><li>✅ 零依赖，纯Shell实现</li><li>🛡️ 排除<code>-e</code>安装的本地包</li><li>🔍 自动过滤注释行</li><li>⚠️ 注意：会覆盖原有requirements文件</li></ul><hr><h3 id="方案二：pip-autosave工具（专业级自动记录）"><a href="#方案二：pip-autosave工具（专业级自动记录）" class="headerlink" title="方案二：pip-autosave工具（专业级自动记录）"></a>方案二：pip-autosave工具（专业级自动记录）</h3><p><strong>安装使用：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pip-autosave</span><br></pre></td></tr></table></figure></p><p><strong>使用场景：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础用法（自动生成requirements.txt）</span></span><br><span class="line">pip install requests --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定保存文件</span></span><br><span class="line">pip install pandas --save requirements-dev.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量安装并记录</span></span><br><span class="line">pip install -r base-requirements.txt --save</span><br></pre></td></tr></table></figure></p><p><strong>核心功能：</strong></p><ul><li>📦 增量更新模式（保留已有依赖）</li><li>🎯 智能版本锁定（记录精确版本号）</li><li>🔄 支持多环境文件（dev/prod）</li><li>📊 生成依赖关系树可视化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show pandas --save --tree</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="方案三：现代项目管理工具集成"><a href="#方案三：现代项目管理工具集成" class="headerlink" title="方案三：现代项目管理工具集成"></a>方案三：现代项目管理工具集成</h3><p><strong>1. Pipenv工作流：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装并自动更新Pipfile</span></span><br><span class="line">pipenv install requests</span><br><span class="line">pipenv install --dev pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标准requirements文件</span></span><br><span class="line">pipenv requirements &gt; requirements.txt</span><br></pre></td></tr></table></figure></p><p><strong>2. Poetry配置：</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pyproject.toml 配置示例</span></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">"^3.8"</span></span><br><span class="line"><span class="attr">requests</span> = &#123; version = <span class="string">"*"</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">"^6.2.5"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出requirements.txt</span></span><br><span class="line">poetry export -f requirements.txt --output requirements.txt</span><br></pre></td></tr></table></figure></p><p><strong>3. Hatch环境管理：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建带自动依赖跟踪的环境</span></span><br><span class="line">hatch env create myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在环境中安装依赖</span></span><br><span class="line">hatch run myenv pip install numpy</span><br></pre></td></tr></table></figure></p><hr><h3 id="版本控制最佳实践"><a href="#版本控制最佳实践" class="headerlink" title="版本控制最佳实践"></a>版本控制最佳实践</h3><ol><li><p><strong>差异化版本记录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产依赖</span></span><br><span class="line">pip freeze --exclude-editable | grep -v <span class="string">'pkg-resources==0.0.0'</span> &gt; requirements.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开发依赖</span></span><br><span class="line">pip freeze --exclude-editable | grep -E <span class="string">'(pytest|coverage)'</span> &gt; requirements-dev.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>依赖树可视化检查：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipdeptree --exclude pip,pip-autosave,setuptools,wheel</span><br></pre></td></tr></table></figure></li><li><p><strong>安全更新策略：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看过时依赖</span></span><br><span class="line">pip list --outdated --format=columns</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 批量更新命令</span></span><br><span class="line">pip install $(pip list --outdated | awk <span class="string">'NR&gt;2 &#123;print $1&#125;'</span>) --upgrade</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="不同方案的适用场景对比"><a href="#不同方案的适用场景对比" class="headerlink" title="不同方案的适用场景对比"></a>不同方案的适用场景对比</h3><table><thead><tr><th>方案</th><th>适用场景</th><th>优势</th><th>局限性</th></tr></thead><tbody><tr><td>Shell别名</td><td>快速原型开发</td><td>无需安装新工具</td><td>功能有限，可能覆盖文件</td></tr><tr><td>pip-autosave</td><td>企业级项目</td><td>精细控制，支持多环境</td><td>需要额外安装</td></tr><tr><td>Pipenv/Poetry</td><td>长期维护的大型项目</td><td>完整依赖解析，支持锁定文件</td><td>学习成本较高</td></tr><tr><td>Hatch</td><td>多环境复杂配置</td><td>集成测试和构建流程</td><td>生态系统较新</td></tr></tbody></table><hr><h3 id="常见问题解决方案"><a href="#常见问题解决方案" class="headerlink" title="常见问题解决方案"></a>常见问题解决方案</h3><p><strong>Q：如何处理不同操作系统依赖？</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用平台标记</span></span><br><span class="line">pip install pywin32 --save; sys_platform == <span class="string">'win32'</span></span><br></pre></td></tr></table></figure></p><p><strong>Q：如何避免开发工具污染生产依赖？</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用分层requirements文件</span></span><br><span class="line">.</span><br><span class="line">├── requirements</span><br><span class="line">│   ├── base.txt</span><br><span class="line">│   ├── dev.txt</span><br><span class="line">│   └── prod.txt</span><br></pre></td></tr></table></figure></p><p><strong>Q：依赖冲突自动解决示例：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用版本范围语法</span></span><br><span class="line">Django&gt;=<span class="number">3.2</span>,&lt;<span class="number">4.0</span></span><br><span class="line">requests&gt;=<span class="number">2.25</span><span class="number">.1</span>,!=<span class="number">2.28</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python开发中，手动维护requirements.txt文件容易遗漏依赖项。本文将介绍三种自动化解决方案，让依赖管理更高效。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;方案一：智能Shell别名（原生pip增强）&quot;&gt;&lt;a href=&quot;#方案一：智能Shell别名（原生pip增
      
    
    </summary>
    
      <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
      <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python虚拟环境创建、激活、管理与最佳实践</title>
    <link href="https://www.silenceboy.com/2025/03/21/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA%E3%80%81%E6%BF%80%E6%B4%BB%E3%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.silenceboy.com/2025/03/21/Python虚拟环境创建、激活、管理与最佳实践/</id>
    <published>2025-03-21T04:47:36.000Z</published>
    <updated>2025-03-21T04:49:00.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言：为什么需要虚拟环境？"><a href="#引言：为什么需要虚拟环境？" class="headerlink" title="引言：为什么需要虚拟环境？"></a>引言：为什么需要虚拟环境？</h2><p>在Python开发中，不同项目往往依赖不同版本的第三方库。全局安装的包可能导致版本冲突，例如项目A需要Django 3.2，而项目B需要Django 4.0。虚拟环境通过为每个项目创建隔离的Python运行环境，完美解决这一难题。</p><hr><h2 id="一、创建虚拟环境"><a href="#一、创建虚拟环境" class="headerlink" title="一、创建虚拟环境"></a>一、创建虚拟环境</h2><h3 id="1-使用内置venv模块"><a href="#1-使用内置venv模块" class="headerlink" title="1. 使用内置venv模块"></a>1. 使用内置venv模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用于Python 3.3+版本</span></span><br><span class="line">python -m venv myenv  <span class="comment"># 创建名为myenv的虚拟环境</span></span><br></pre></td></tr></table></figure><h3 id="2-指定Python解释器版本"><a href="#2-指定Python解释器版本" class="headerlink" title="2. 指定Python解释器版本"></a>2. 指定Python解释器版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.8 -m venv py38_env  <span class="comment"># 使用特定Python版本创建</span></span><br></pre></td></tr></table></figure><h3 id="3-目录结构解析"><a href="#3-目录结构解析" class="headerlink" title="3. 目录结构解析"></a>3. 目录结构解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myenv/</span><br><span class="line">├── bin/            # Unix激活脚本</span><br><span class="line">├── Scripts/        # Windows激活脚本</span><br><span class="line">├── Lib/            # 安装的第三方库</span><br><span class="line">└── pyvenv.cfg      # 环境配置文件</span><br></pre></td></tr></table></figure><hr><h2 id="二、激活虚拟环境"><a href="#二、激活虚拟环境" class="headerlink" title="二、激活虚拟环境"></a>二、激活虚拟环境</h2><h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myenv\Scripts\activate</span><br><span class="line"><span class="comment"># 命令提示符显示 (myenv) C:\&gt;</span></span><br></pre></td></tr></table></figure><h3 id="macOS-Linux系统"><a href="#macOS-Linux系统" class="headerlink" title="macOS/Linux系统"></a>macOS/Linux系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"><span class="comment"># 终端提示符显示 (myenv) $</span></span><br></pre></td></tr></table></figure><p><strong>验证激活状态：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> python  <span class="comment"># Unix</span></span><br><span class="line"><span class="built_in">where</span> python  <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="三、管理项目依赖"><a href="#三、管理项目依赖" class="headerlink" title="三、管理项目依赖"></a>三、管理项目依赖</h2><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django==3.2.12</span><br></pre></td></tr></table></figure><h3 id="导出依赖清单"><a href="#导出依赖清单" class="headerlink" title="导出依赖清单"></a>导出依赖清单</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h3 id="批量安装依赖"><a href="#批量安装依赖" class="headerlink" title="批量安装依赖"></a>批量安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><hr><h2 id="四、退出虚拟环境"><a href="#四、退出虚拟环境" class="headerlink" title="四、退出虚拟环境"></a>四、退出虚拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br><span class="line"><span class="comment"># 命令提示符恢复默认状态</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、进阶技巧与工具"><a href="#五、进阶技巧与工具" class="headerlink" title="五、进阶技巧与工具"></a>五、进阶技巧与工具</h2><h3 id="1-虚拟环境管理工具对比"><a href="#1-虚拟环境管理工具对比" class="headerlink" title="1. 虚拟环境管理工具对比"></a>1. 虚拟环境管理工具对比</h3><table><thead><tr><th>工具</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>venv</td><td>Python内置，轻量级</td><td>简单项目</td></tr><tr><td>virtualenv</td><td>支持Python 2/3</td><td>兼容旧项目</td></tr><tr><td>pipenv</td><td>整合pip+虚拟环境</td><td>复杂依赖管理</td></tr><tr><td>poetry</td><td>依赖解析+打包一体化</td><td>专业项目开发</td></tr></tbody></table><h3 id="2-快速复制环境"><a href="#2-快速复制环境" class="headerlink" title="2. 快速复制环境"></a>2. 快速复制环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在原环境执行</span></span><br><span class="line">pip list --format=freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新环境执行</span></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="3-环境配置加速"><a href="#3-环境配置加速" class="headerlink" title="3. 环境配置加速"></a>3. 环境配置加速</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install pip --upgrade  <span class="comment"># 升级pip</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple  <span class="comment"># 国内镜像源</span></span><br></pre></td></tr></table></figure><hr><h2 id="六、最佳实践"><a href="#六、最佳实践" class="headerlink" title="六、最佳实践"></a>六、最佳实践</h2><ol><li><strong>项目隔离原则</strong>：每个独立项目创建专属虚拟环境</li><li><p><strong>版本控制</strong>：将requirements.txt加入Git仓库，忽略虚拟环境目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># .gitignore</span><br><span class="line">myenv/</span><br><span class="line">venv/</span><br><span class="line">*.env/</span><br></pre></td></tr></table></figure></li><li><p><strong>定期维护</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip list --outdated  <span class="comment"># 检查过期包</span></span><br><span class="line">pip-autoremove  <span class="comment"># 清理无用依赖</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>掌握虚拟环境是Python开发者的必备技能。通过<code>venv</code>创建隔离环境，配合<code>requirements.txt</code>管理依赖，能有效避免”在我机器上能运行”的经典问题。建议立即在您的下一个Python项目中实践这些技巧，体验更干净的开发环境！</p><blockquote><p><strong>提示</strong>：删除虚拟环境只需删除对应目录即可，但请确保已执行<code>deactivate</code>退出环境。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言：为什么需要虚拟环境？&quot;&gt;&lt;a href=&quot;#引言：为什么需要虚拟环境？&quot; class=&quot;headerlink&quot; title=&quot;引言：为什么需要虚拟环境？&quot;&gt;&lt;/a&gt;引言：为什么需要虚拟环境？&lt;/h2&gt;&lt;p&gt;在Python开发中，不同项目往往依赖不同版本的第三
      
    
    </summary>
    
      <category term="python" scheme="https://www.silenceboy.com/categories/python/"/>
    
    
      <category term="python" scheme="https://www.silenceboy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ASIL等级是什么</title>
    <link href="https://www.silenceboy.com/2024/10/22/ASIL%E7%AD%89%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://www.silenceboy.com/2024/10/22/ASIL等级是什么/</id>
    <published>2024-10-22T06:45:40.000Z</published>
    <updated>2024-10-22T06:46:23.432Z</updated>
    
    <content type="html"><![CDATA[<p>ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL A表示最低的安全要求。</p><h3 id="ASIL等级的定义"><a href="#ASIL等级的定义" class="headerlink" title="ASIL等级的定义"></a>ASIL等级的定义</h3><p>ASIL等级基于三个主要因素来确定：</p><ol><li><strong>严重性（Severity, S）</strong>：故障导致的潜在伤害的严重程度。</li><li><strong>暴露率（Exposure, E）</strong>：驾驶员或乘客暴露于潜在故障的频率。</li><li><strong>可控性（Controllability, C）</strong>：驾驶员或乘客在故障发生时控制车辆的能力。</li></ol><h3 id="ASIL等级的划分"><a href="#ASIL等级的划分" class="headerlink" title="ASIL等级的划分"></a>ASIL等级的划分</h3><p>根据上述三个因素的组合，ASIL等级可以分为以下四个级别：</p><ol><li><strong>ASIL A</strong>：最低的安全要求。适用于故障对安全影响较小、暴露率低且可控性高的情况。</li><li><strong>ASIL B</strong>：中等安全要求。适用于故障对安全影响中等、暴露率中等且可控性一般的情况。</li><li><strong>ASIL C</strong>：较高的安全要求。适用于故障对安全影响较大、暴露率较高且可控性较低的情况。</li><li><strong>ASIL D</strong>：最高的安全要求。适用于故障对安全影响非常大、暴露率非常高且几乎不可控的情况。</li></ol><h3 id="ASIL等级的确定"><a href="#ASIL等级的确定" class="headerlink" title="ASIL等级的确定"></a>ASIL等级的确定</h3><p>ASIL等级的确定通常通过一个风险评估矩阵来完成，该矩阵综合考虑严重性、暴露率和可控性三个因素。以下是一个简化的示例矩阵：</p><table><thead><tr><th>严重性/暴露率/可控性</th><th>E1（低）</th><th>E2（中低）</th><th>E3（中高）</th><th>E4（高）</th></tr></thead><tbody><tr><td>S1（低）</td><td>QM</td><td>QM</td><td>ASIL A</td><td>ASIL A</td></tr><tr><td>S2（中）</td><td>QM</td><td>ASIL A</td><td>ASIL B</td><td>ASIL B</td></tr><tr><td>S3（高）</td><td>ASIL A</td><td>ASIL B</td><td>ASIL C</td><td>ASIL D</td></tr><tr><td>S4（极高）</td><td>ASIL B</td><td>ASIL C</td><td>ASIL D</td><td>ASIL D</td></tr></tbody></table><p><strong>注</strong>：QM（Quality Management）表示不需要特别的安全措施，只需按照质量管理标准进行处理。</p><h3 id="ASIL等级的应用"><a href="#ASIL等级的应用" class="headerlink" title="ASIL等级的应用"></a>ASIL等级的应用</h3><p>在汽车电子系统的设计和开发过程中，确定ASIL等级是确保系统安全性的关键步骤。不同的ASIL等级对应不同的开发流程和验证要求：</p><ul><li><strong>ASIL A</strong>：基本的安全措施和验证。</li><li><strong>ASIL B</strong>：需要更严格的设计和测试流程。</li><li><strong>ASIL C</strong>：需要高级的安全分析和验证技术。</li><li><strong>ASIL D</strong>：需要最高级别的安全措施、冗余设计和全面的验证。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ASIL等级是评估和管理汽车电子系统安全性的关键工具。通过确定系统的ASIL等级，开发人员可以采取适当的设计和验证措施，以确保系统在各种可能的故障情况下都能保持安全性。ISO 26262标准提供了详细的指南和方法，帮助开发人员在整个开发生命周期中实现和维护所需的安全完整性等级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL 
      
    
    </summary>
    
      <category term="ASIL" scheme="https://www.silenceboy.com/categories/ASIL/"/>
    
    
      <category term="ASIL" scheme="https://www.silenceboy.com/tags/ASIL/"/>
    
  </entry>
  
  <entry>
    <title>SOC中除了R核和A核还有哪些处理器核心</title>
    <link href="https://www.silenceboy.com/2024/10/21/SOC%E4%B8%AD%E9%99%A4%E4%BA%86R%E6%A0%B8%E5%92%8CA%E6%A0%B8%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8%E5%BF%83/"/>
    <id>https://www.silenceboy.com/2024/10/21/SOC中除了R核和A核还有哪些处理器核心/</id>
    <published>2024-10-21T06:25:57.000Z</published>
    <updated>2024-10-21T06:26:19.127Z</updated>
    
    <content type="html"><![CDATA[<p>除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型：</p><h3 id="M核（Microcontroller-Core）"><a href="#M核（Microcontroller-Core）" class="headerlink" title="M核（Microcontroller Core）"></a>M核（Microcontroller Core）</h3><p>M核通常指的是微控制器核心，主要用于低功耗、低成本的嵌入式系统。以下是M核的一些特点和应用：</p><ol><li><strong>低功耗</strong>：设计目标是尽量减少功耗，适合电池供电的设备。</li><li><strong>简单架构</strong>：通常具有较简单的指令集和架构，易于编程和调试。</li><li><strong>集成外设</strong>：通常集成了丰富的外设接口，如ADC、DAC、UART、I2C、SPI等。</li><li><strong>实时性</strong>：虽然不如R核那样严格，但也能处理一些实时任务。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>家用电器</li><li>传感器节点</li><li>简单控制系统</li><li>物联网设备</li></ul><h3 id="NPU（Neural-Processing-Unit）"><a href="#NPU（Neural-Processing-Unit）" class="headerlink" title="NPU（Neural Processing Unit）"></a>NPU（Neural Processing Unit）</h3><p>NPU是神经网络处理单元，专门用于加速深度学习和人工智能任务。以下是NPU的一些特点和应用：</p><ol><li><strong>高效计算</strong>：专门优化用于矩阵运算和卷积操作，适合深度学习模型的推理和训练。</li><li><strong>并行处理</strong>：具有高度并行的计算能力，能够同时处理大量数据。</li><li><strong>低功耗</strong>：相对于通用处理器，NPU在执行AI任务时具有更高的能效比。</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>图像和视频处理</li><li>语音识别</li><li>自然语言处理</li><li>自动驾驶</li></ul><h3 id="DSP（Digital-Signal-Processor）"><a href="#DSP（Digital-Signal-Processor）" class="headerlink" title="DSP（Digital Signal Processor）"></a>DSP（Digital Signal Processor）</h3><p>DSP是数字信号处理器，专门用于处理数字信号，如音频、视频和通信信号。以下是DSP的一些特点和应用：</p><ol><li><strong>高效信号处理</strong>：专门优化用于快速傅里叶变换（FFT）、滤波和其他信号处理算法。</li><li><strong>实时处理</strong>：能够实时处理输入信号，适合实时音频和视频处理。</li><li><strong>低延迟</strong>：设计目标是尽量减少处理延迟，确保信号处理的实时性。</li></ol><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>音频处理（如回声消除、降噪）</li><li>视频处理（如编码、解码）</li><li>通信系统（如调制、解调）</li><li>雷达和声纳</li></ul><h3 id="GPU（Graphics-Processing-Unit）"><a href="#GPU（Graphics-Processing-Unit）" class="headerlink" title="GPU（Graphics Processing Unit）"></a>GPU（Graphics Processing Unit）</h3><p>GPU是图形处理单元，主要用于图形渲染和计算加速。以下是GPU的一些特点和应用：</p><ol><li><strong>高并行性</strong>：具有大量并行处理单元，能够同时处理大量数据。</li><li><strong>图形渲染</strong>：专门用于处理图形渲染任务，如3D图形、游戏图形等。</li><li><strong>通用计算</strong>：近年来，GPU也被广泛用于通用计算（GPGPU），如科学计算、机器学习等。</li></ol><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>游戏和娱乐</li><li>图形设计和渲染</li><li>科学计算</li><li>深度学习</li></ul><h3 id="VPU（Vision-Processing-Unit）"><a href="#VPU（Vision-Processing-Unit）" class="headerlink" title="VPU（Vision Processing Unit）"></a>VPU（Vision Processing Unit）</h3><p>VPU是视觉处理单元，专门用于处理计算机视觉任务。以下是VPU的一些特点和应用：</p><ol><li><strong>优化视觉任务</strong>：专门优化用于图像和视频处理任务，如对象检测、图像识别等。</li><li><strong>高效能效比</strong>：在处理视觉任务时具有高效的能效比。</li><li><strong>实时处理</strong>：能够实时处理图像和视频数据，适合实时应用。</li></ol><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>计算机视觉</li><li>增强现实（AR）和虚拟现实（VR）</li><li>自动驾驶</li><li>安全监控</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在现代SoC设计中，除了R核和A核，还有多种类型的处理器核心，如M核、NPU、DSP、GPU和VPU等。每种核心都有其特定的用途和优势，通过组合使用这些核心，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型：&lt;/p&gt;
&lt;h3 id=&quot;M核（Microcontroller-Core）&quot;&gt;&lt;a href=&quot;#M核（Microcontr
      
    
    </summary>
    
      <category term="SoC" scheme="https://www.silenceboy.com/categories/SoC/"/>
    
    
      <category term="SoC" scheme="https://www.silenceboy.com/tags/SoC/"/>
    
  </entry>
  
  <entry>
    <title>SOC的R核、A核有什么区别</title>
    <link href="https://www.silenceboy.com/2024/10/21/SOC%E7%9A%84R%E6%A0%B8%E3%80%81A%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.silenceboy.com/2024/10/21/SOC的R核、A核有什么区别/</id>
    <published>2024-10-21T06:22:57.000Z</published>
    <updated>2024-10-21T06:23:53.596Z</updated>
    
    <content type="html"><![CDATA[<p>在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。</p><h3 id="R核（Real-time-Core）"><a href="#R核（Real-time-Core）" class="headerlink" title="R核（Real-time Core）"></a>R核（Real-time Core）</h3><p>R核通常指的是实时处理器核心，主要用于处理实时任务。以下是R核的一些特点和应用：</p><ol><li><strong>实时性</strong>：R核设计用于处理需要严格时间约束的任务，确保任务在规定时间内完成。</li><li><strong>确定性</strong>：R核通常具有确定的响应时间，适合用于实时操作系统（RTOS）。</li><li><strong>低延迟</strong>：R核的设计目标是尽量减少处理延迟，以确保快速响应外部事件。</li><li><strong>低功耗</strong>：R核通常功耗较低，适合用于电池供电的嵌入式设备。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>工业自动化控制</li><li>汽车电子（如引擎控制单元）</li><li>医疗设备</li><li>物联网设备</li></ul><h3 id="A核（Application-Core）"><a href="#A核（Application-Core）" class="headerlink" title="A核（Application Core）"></a>A核（Application Core）</h3><p>A核通常指的是应用处理器核心，主要用于运行复杂的应用程序和操作系统。以下是A核的一些特点和应用：</p><ol><li><strong>高性能</strong>：A核设计用于处理复杂计算任务，具有较高的处理能力。</li><li><strong>多任务处理</strong>：A核通常支持多任务处理，能够运行完整的操作系统（如Linux、Android）。</li><li><strong>丰富的外设支持</strong>：A核通常集成了丰富的外设接口，如USB、HDMI、以太网等。</li><li><strong>较高功耗</strong>：由于需要处理复杂任务，A核的功耗通常较高。</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>智能手机和平板电脑</li><li>个人计算机</li><li>多媒体设备（如智能电视和机顶盒）</li><li>高级嵌入式系统（如无人机和机器人）</li></ul><h3 id="例子：ARM-Cortex-系列"><a href="#例子：ARM-Cortex-系列" class="headerlink" title="例子：ARM Cortex 系列"></a>例子：ARM Cortex 系列</h3><p>在ARM的Cortex系列处理器中，R核和A核的区别非常明显：</p><ul><li><strong>Cortex-R 系列</strong>：这是ARM的实时处理器系列，设计用于高可靠性和实时性应用，如Cortex-R5和Cortex-R8。</li><li><strong>Cortex-A 系列</strong>：这是ARM的应用处理器系列，设计用于高性能和复杂应用，如Cortex-A53、Cortex-A72等。</li></ul><h3 id="SoC中的组合"><a href="#SoC中的组合" class="headerlink" title="SoC中的组合"></a>SoC中的组合</h3><p>在许多SoC设计中，R核和A核常常被组合使用，以便同时满足实时处理和高性能计算的需求。例如：</p><ul><li><strong>智能手机SoC</strong>：通常包含多个Cortex-A系列核心用于运行操作系统和应用程序，同时可能包含一个或多个Cortex-R系列核心用于处理实时任务，如基带处理。</li><li><strong>汽车电子SoC</strong>：可能包含Cortex-R系列核心用于引擎控制和安全系统，同时包含Cortex-A系列核心用于信息娱乐系统。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>R核（Real-time Core）</strong>：用于实时任务，强调低延迟和确定性，适合工业控制、汽车电子等领域。</li><li><strong>A核（Application Core）</strong>：用于运行复杂应用程序和操作系统，强调高性能和多任务处理，适合智能手机、平板电脑等设备。</li></ul><p>通过结合使用R核和A核，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。&lt;/p&gt;
&lt;h3 id=&quot;R核（Real-time-Core）&quot;&gt;&lt;a href=&quot;#R核（Real-time-Core）&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="SoC" scheme="https://www.silenceboy.com/categories/SoC/"/>
    
    
      <category term="SoC" scheme="https://www.silenceboy.com/tags/SoC/"/>
    
  </entry>
  
  <entry>
    <title>docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？</title>
    <link href="https://www.silenceboy.com/2024/06/28/docker%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E9%9D%9Eroot%EF%BC%8C%E4%B8%94%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AF%86%E7%A0%81%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Csudo%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>https://www.silenceboy.com/2024/06/28/docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？/</id>
    <published>2024-06-28T07:22:18.000Z</published>
    <updated>2024-06-28T07:23:01.137Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在 Docker 容器中默认用户是 <code>dev</code>，但不知道密码，无法执行 <code>sudo</code> 操作，你可以通过以下几种方法来解决这个问题：</p><h3 id="方法一：以-root-用户重新启动容器"><a href="#方法一：以-root-用户重新启动容器" class="headerlink" title="方法一：以 root 用户重新启动容器"></a>方法一：以 root 用户重新启动容器</h3><p>你可以以 <code>root</code> 用户重新启动容器，然后更改 <code>dev</code> 用户的密码或者直接执行你需要的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="方法二：修改-Dockerfile-重新构建镜像"><a href="#方法二：修改-Dockerfile-重新构建镜像" class="headerlink" title="方法二：修改 Dockerfile 重新构建镜像"></a>方法二：修改 Dockerfile 重新构建镜像</h3><p>如果你有 Dockerfile，可以修改 Dockerfile 来设置 <code>dev</code> 用户的密码或者直接使用 <code>root</code> 用户。</p><p>例如，修改 Dockerfile 来设置 <code>dev</code> 用户的密码：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> your_base_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 dev 用户的密码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他 Dockerfile 指令</span></span><br></pre></td></tr></table></figure><p>然后重新构建镜像并运行容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your_image_name .</span><br><span class="line">docker run -it your_image_name</span><br></pre></td></tr></table></figure><h3 id="方法三：创建新的镜像并修改用户配置"><a href="#方法三：创建新的镜像并修改用户配置" class="headerlink" title="方法三：创建新的镜像并修改用户配置"></a>方法三：创建新的镜像并修改用户配置</h3><p>如果你没有 Dockerfile，但可以访问容器的镜像，你可以创建一个新的镜像并修改用户配置。</p><ol><li><p>首先，启动一个新的容器并进入：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name temp_container your_image_name /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span><br></pre></td></tr></table></figure></li><li><p>退出容器并提交更改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit temp_container your_new_image_name</span><br></pre></td></tr></table></figure></li><li><p>使用新的镜像启动容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it your_new_image_name</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法四：直接进入容器并修改密码"><a href="#方法四：直接进入容器并修改密码" class="headerlink" title="方法四：直接进入容器并修改密码"></a>方法四：直接进入容器并修改密码</h3><p>如果容器已经在运行，你可以直接进入容器并修改 <code>dev</code> 用户的密码。</p><ol><li><p>首先，以 <code>root</code> 用户进入容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法五：使用-docker-commit-修改现有容器"><a href="#方法五：使用-docker-commit-修改现有容器" class="headerlink" title="方法五：使用 docker commit 修改现有容器"></a>方法五：使用 <code>docker commit</code> 修改现有容器</h3><p>如果你已经有一个运行中的容器，可以使用 <code>docker commit</code> 来创建一个新的镜像，并在新镜像中修改 <code>dev</code> 用户的密码。</p><ol><li><p>首先，以 <code>root</code> 用户进入容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span><br></pre></td></tr></table></figure></li><li><p>退出容器并提交更改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit &lt;container_id_or_name&gt; your_new_image_name</span><br></pre></td></tr></table></figure></li><li><p>使用新的镜像启动容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it your_new_image_name</span><br></pre></td></tr></table></figure></li></ol><p>通过这些方法，你可以解决无法执行 <code>sudo</code> 操作的问题，并根据需要修改 <code>dev</code> 用户的密码或直接使用 <code>root</code> 用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你在 Docker 容器中默认用户是 &lt;code&gt;dev&lt;/code&gt;，但不知道密码，无法执行 &lt;code&gt;sudo&lt;/code&gt; 操作，你可以通过以下几种方法来解决这个问题：&lt;/p&gt;
&lt;h3 id=&quot;方法一：以-root-用户重新启动容器&quot;&gt;&lt;a href=&quot;#方法一
      
    
    </summary>
    
      <category term="docker" scheme="https://www.silenceboy.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.silenceboy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比</title>
    <link href="https://www.silenceboy.com/2024/06/24/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%EF%BC%9Asonar%E3%80%81fireline%E3%80%81coverity%E3%80%81fortify%E3%80%81blackduck%E5%AF%B9%E6%AF%94/"/>
    <id>https://www.silenceboy.com/2024/06/24/代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比/</id>
    <published>2024-06-24T08:02:01.000Z</published>
    <updated>2024-06-24T08:10:17.375Z</updated>
    
    <content type="html"><![CDATA[<p>代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别：</p><h3 id="1-SonarQube"><a href="#1-SonarQube" class="headerlink" title="1. SonarQube"></a>1. SonarQube</h3><p><strong>简介</strong>:</p><ul><li>SonarQube 是一个开源的代码质量管理工具。</li><li>支持多种编程语言，如 Java、C#、JavaScript、TypeScript、Python 等。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的漏洞、错误和代码异味。</li><li>代码度量：提供代码覆盖率、复杂度等度量指标。</li><li>集成：与 CI/CD 工具（如 Jenkins、GitLab CI）集成，自动化代码质量检查。</li></ul><p><strong>优点</strong>:</p><ul><li>开源且社区活跃。</li><li>支持多种插件，扩展功能强大。</li><li>直观的用户界面，易于使用。</li></ul><h3 id="2-Fireline"><a href="#2-Fireline" class="headerlink" title="2. Fireline"></a>2. Fireline</h3><p><strong>简介</strong>:</p><ul><li>Fireline 是一个专注于代码安全的静态分析工具。</li></ul><p><strong>功能</strong>:</p><ul><li>检测代码中的安全漏洞，如 SQL 注入、跨站脚本攻击（XSS）等。</li><li>提供详细的漏洞报告和修复建议。</li></ul><p><strong>优点</strong>:</p><ul><li>专注于安全漏洞检测，提供深度分析。</li><li>适用于需要高安全性的应用程序开发。</li></ul><h3 id="3-Coverity"><a href="#3-Coverity" class="headerlink" title="3. Coverity"></a>3. Coverity</h3><p><strong>简介</strong>:</p><ul><li>Coverity 是 Synopsys 提供的静态代码分析工具。</li><li>支持多种编程语言，如 C、C++、Java、C#、JavaScript 等。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的缺陷和安全漏洞。</li><li>自动化分析：与 CI/CD 工具集成，实现自动化代码扫描。</li><li>报告和修复建议：提供详细的缺陷报告和修复建议。</li></ul><p><strong>优点</strong>:</p><ul><li>高准确性和低误报率。</li><li>强大的企业级支持和服务。</li><li>支持广泛的编程语言和复杂代码库。</li></ul><h3 id="4-Fortify"><a href="#4-Fortify" class="headerlink" title="4. Fortify"></a>4. Fortify</h3><p><strong>简介</strong>:</p><ul><li>Fortify 是 Micro Focus 提供的应用安全测试工具。</li><li>包含静态应用安全测试（SAST）和动态应用安全测试（DAST）。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的安全漏洞。</li><li>动态分析：在运行时检测应用程序的安全漏洞。</li><li>安全审计和合规性检查。</li></ul><p><strong>优点</strong>:</p><ul><li>综合的安全测试解决方案，覆盖静态和动态分析。</li><li>强大的企业级支持和服务。</li><li>提供详细的漏洞修复指导。</li></ul><h3 id="5-Black-Duck"><a href="#5-Black-Duck" class="headerlink" title="5. Black Duck"></a>5. Black Duck</h3><p><strong>简介</strong>:</p><ul><li>Black Duck 是 Synopsys 提供的开源安全和管理工具。</li><li>专注于开源组件的安全和合规性。</li></ul><p><strong>功能</strong>:</p><ul><li>开源组件扫描：检测项目中使用的开源组件。</li><li>漏洞检测：识别开源组件中的已知漏洞。</li><li>许可证合规性：检查开源组件的许可证合规性。</li></ul><p><strong>优点</strong>:</p><ul><li>专注于开源组件的管理和安全。</li><li>提供详细的漏洞和许可证合规报告。</li><li>与其他 Synopsys 工具集成，提供全面的安全解决方案。</li></ul><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul><li><strong>SonarQube</strong>：主要关注代码质量和代码异味，提供全面的代码度量和质量报告。</li><li><strong>Fireline</strong>：专注于代码安全漏洞的检测，适用于需要高安全性的应用。</li><li><strong>Coverity</strong>：提供高准确性的静态代码分析，适合复杂和大型代码库。</li><li><strong>Fortify</strong>：综合的应用安全测试工具，覆盖静态和动态分析，适合全面的安全测试需求。</li><li><strong>Black Duck</strong>：专注于开源组件的安全和合规性管理，适用于使用大量开源组件的项目。</li></ul><p>每种工具都有其特定的优势和应用场景，选择合适的工具应根据项目的具体需求和环境来决定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别：&lt;/p&gt;
&lt;h3 id=&quot;1-SonarQube&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="代码扫描" scheme="https://www.silenceboy.com/categories/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
    
      <category term="代码扫描" scheme="https://www.silenceboy.com/tags/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本里的#*@是什么意思</title>
    <link href="https://www.silenceboy.com/2023/09/27/shell%E8%84%9A%E6%9C%AC%E9%87%8C%E7%9A%84-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>https://www.silenceboy.com/2023/09/27/shell脚本里的-是什么意思/</id>
    <published>2023-09-27T09:22:45.000Z</published>
    <updated>2023-12-05T01:44:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>在Shell脚本中，<code>${variable#pattern}</code> 是一种字符串处理方式，其中 <code>#</code> 后跟着一个模式<code>（pattern）</code>。这个语法的作用是从字符串变量 variable 的开头删除匹配 <code>pattern</code> 的最短子串，并返回删除后的结果。<code>${variable#*@}</code> 的含义是：</p><p>● <code>variable</code> 是一个字符串变量，通常是一个包含文本的字符串。</p><p>● <code>#</code> 表示从字符串开头开始匹配。</p><p>● <code>*@</code> 是一个通配符模式，它匹配字符串中的任意字符序列，直到第一个 @ 字符。</p><p>所以，<code>${variable#*@}</code> 的作用是从变量 <code>variable</code> 的开头删除匹配 <code>*@</code> 模式的最短子串，并返回删除后的结果。通常，这种操作用于处理文本或字符串，以过滤掉或提取感兴趣的部分。<br>例如，如果 <code>variable</code> 的值是 <code>&quot;user@example.com&quot;</code>，那么 <code>${variable#*@}</code> 的结果将是 <code>&quot;example.com&quot;</code>，因为它删除了字符串中第一个 <code>&quot;@&quot;</code> 符号及其之前的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Shell脚本中，&lt;code&gt;${variable#pattern}&lt;/code&gt; 是一种字符串处理方式，其中 &lt;code&gt;#&lt;/code&gt; 后跟着一个模式&lt;code&gt;（pattern）&lt;/code&gt;。这个语法的作用是从字符串变量 variable 的开头删除匹配 &lt;co
      
    
    </summary>
    
      <category term="shell" scheme="https://www.silenceboy.com/categories/shell/"/>
    
    
      <category term="shell" scheme="https://www.silenceboy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>用go开发sse接口</title>
    <link href="https://www.silenceboy.com/2023/07/11/%E7%94%A8go%E5%BC%80%E5%8F%91sse%E6%8E%A5%E5%8F%A3/"/>
    <id>https://www.silenceboy.com/2023/07/11/用go开发sse接口/</id>
    <published>2023-07-11T02:50:24.000Z</published>
    <updated>2023-07-21T05:36:57.832Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p>sse 服务器发送事件(Server-Sent Events)，服务端向客户端单向传递消息。在一些只需要接受服务端数据的需求中可以取代websocket技术，使用起来也很简单。</p><p>目前go已经有一些支持sse的库，我这里选用了：<code>eventsource.v1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get gopkg.in/antage/eventsource.v1</span></span><br></pre></td></tr></table></figure><h2 id="广播模式SSE"><a href="#广播模式SSE" class="headerlink" title="广播模式SSE"></a>广播模式SSE</h2><p>广播模式SSE指不设置事件名，或者说是不设置通道，所有客户端接收同样的数据。</p><p>具体代码实现如下：<a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test1" target="_blank" rel="noopener">点击查看源码</a></p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gopkg.in/antage/eventsource.v1"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播模式SSE，不设置事件名称（也可理解为通道）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">es := eventsource.New(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> es.Close()</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"./public"</span>)))</span><br><span class="line">http.Handle(<span class="string">"/events"</span>, es)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 只设置发送数据，不添加事件名</span></span><br><span class="line">es.SendEventMessage(fmt.Sprintf(<span class="string">"send data: %s"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>)), <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">log.Printf(<span class="string">"客户端连接数: %d"</span>, es.ConsumersCount())</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"Open URL http://localhost:8080/ in your browser."</span>)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前端</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">        const es = new EventSource("http://localhost:8080/events");</span><br><span class="line">        es.onmessage = function (e) &#123;</span><br><span class="line">            document.getElementById("test")</span><br><span class="line"><span class="xml">                .insertAdjacentHTML("beforeend", "<span class="tag">&lt;<span class="name">li</span>&gt;</span>" + e.data + "<span class="tag">&lt;/<span class="name">li</span>&gt;</span>");</span></span><br><span class="line">        &#125;</span><br><span class="line">        es.onerror = function (e) &#123;</span><br><span class="line">            // readyState说明</span><br><span class="line">            // 0：浏览器与服务端尚未建立连接或连接已被关闭</span><br><span class="line">            // 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</span><br><span class="line">            // 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</span><br><span class="line">            console.log("readyState = " + e.currentTarget.readyState);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动服务端代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main</span></span><br></pre></td></tr></table></figure><p>打开浏览器访问前端代码： <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p>服务端输出：</p><p><img src="./images/2023-06-29_20-34_1.png" alt></p><p>前端输出：</p><p><img src="./images/2023-06-29_20-34.png" alt></p><h2 id="点对点模式SSE"><a href="#点对点模式SSE" class="headerlink" title="点对点模式SSE"></a>点对点模式SSE</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test2" target="_blank" rel="noopener">点击查看源代码</a></p><p>实现方式和广播模式差不多，只需做简单修改：</p><p>服务端代码只需添加事件名称：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置事件名称为：test-event</span></span><br><span class="line">es.SendEventMessage(fmt.Sprintf(<span class="string">"send data: %s"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>)), <span class="string">"test-event"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>前端代码修改接收方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">es.addEventListener(<span class="string">"test-event"</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span><br><span class="line">        .insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;li&gt;"</span> + e.data + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="支持跨域的SSE"><a href="#支持跨域的SSE" class="headerlink" title="支持跨域的SSE"></a>支持跨域的SSE</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test3" target="_blank" rel="noopener">点击查看源代码</a></p><p>现在项目开发基本上都是前后端分离，这样就会存在跨域问题，SSE解决跨域的方式只需要在<code>new</code>方法内增加允许跨域请求头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">es := eventsource.New(</span><br><span class="line">    eventsource.DefaultSettings(),</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            []<span class="keyword">byte</span>(<span class="string">"X-Accel-Buffering: no"</span>),</span><br><span class="line">            []<span class="keyword">byte</span>(<span class="string">"Access-Control-Allow-Origin: *"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>前端创建sse连接时也可添加允许跨域参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> es = <span class="keyword">new</span> EventSource(<span class="string">"http://localhost:8080/events"</span>, &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="解决火狐浏览器断开不会自动重连问题"><a href="#解决火狐浏览器断开不会自动重连问题" class="headerlink" title="解决火狐浏览器断开不会自动重连问题"></a>解决火狐浏览器断开不会自动重连问题</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test4" target="_blank" rel="noopener">点击查看源代码</a></p><p>在Chrome浏览器中sse断开后会自动重连，但firefox浏览器中断开后不会重连，解决办法是，前端js通过判断连接状态主动进行重连请求，通过判断readyState的值进行重新调用初始化操作</p><p>readyState说明：</p><ul><li>0：浏览器与服务端尚未建立连接或连接已被关闭</li><li>1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</li><li>2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</li></ul><p>前端代码可修改为如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> es = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 解决火狐浏览器断开不会自动重连问题</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">initES</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (es == <span class="literal">null</span> || es.readyState == <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="javascript">                es = <span class="keyword">new</span> EventSource(<span class="string">"http://localhost:8080/events"</span>, &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;);</span></span><br><span class="line"><span class="javascript">                es.addEventListener(<span class="string">"test-event"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span></span><br><span class="line"><span class="javascript">                        .insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;li&gt;"</span> + e.data + <span class="string">"&lt;/li&gt;"</span>);</span></span><br><span class="line">                &#125;);</span><br><span class="line"><span class="javascript">                es.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// readyState说明</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 0：浏览器与服务端尚未建立连接或连接已被关闭</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"readyState = "</span> + e.currentTarget.readyState);</span></span><br><span class="line">                    if (es.readyState == 2) &#123;</span><br><span class="line">                        setTimeout(initES, 5000)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        initES()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sse 服务器发送事件(Server-Sent Events)，服务端向客
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（五）：grpc调试工具</title>
    <link href="https://www.silenceboy.com/2023/06/26/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Agrpc%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.silenceboy.com/2023/06/26/grpc系列课程（五）：grpc调试工具/</id>
    <published>2023-06-26T02:38:01.000Z</published>
    <updated>2023-07-21T05:36:57.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p>平时我们编写http的api接口时能够很方便的通过postman工具进行接口调试，那么grpc接口是否也有类似postman的工具可以调试呐？<br>当然可以，github上有一款工具<a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">grpcui</a>，专门用来在浏览器中进行grpc接口调试。</p><h2 id="安装grpcui工具"><a href="#安装grpcui工具" class="headerlink" title="安装grpcui工具"></a>安装grpcui工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/fullstorydev/grpcui/cmd/grpcui@latest</span><br></pre></td></tr></table></figure><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><p>我们以<code>demo_1</code>测试代码为例进行调试。首先在项目中安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/fullstorydev/grpcui</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br></pre></td></tr></table></figure><h3 id="启动grpcui"><a href="#启动grpcui" class="headerlink" title="启动grpcui"></a>启动grpcui</h3><p>另起一个终端，执行一下命令，注意这里的端口号要和grpc服务端口号保持一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grpcui -plaintext 127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>如果你在执行以上命令的时候出现一下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to compute set of methods to expose: server does not support the reflection API</span><br></pre></td></tr></table></figure><p>需要在<code>server/main.go</code>文件中添加如下代码，增加反射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection.Register(s)</span><br></pre></td></tr></table></figure><p>此时再运行以上启动grpcui命令，可看到一下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gRPC Web UI available at http://127.0.0.1:41619/</span><br><span class="line">Opening in existing browser session.</span><br></pre></td></tr></table></figure><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>浏览器打开<code>http://127.0.0.1:41619/</code> ,可以看到grpcui调试页面：<br><img src="/../images/2023-06-18_15-34.png" alt></p><p>点击<code>Invoke</code>按钮，可以看到<code>Response</code>tab页有对于的相应数据：<br><img src="/../images/2023-06-18_15-36.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时我们编写http的api接口时能够很方便的通过postman工具进行接
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（四）：双向流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8F%8C%E5%90%91%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（四）：双向流式rpc/</id>
    <published>2023-06-18T07:13:21.000Z</published>
    <updated>2023-07-21T05:36:57.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_4" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_4</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_4 &amp;&amp; <span class="built_in">cd</span> demo_4</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (stream HelloRequest) <span class="keyword">returns</span> (stream HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_4/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(stream helloworld.Hello_SayHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = stream.Send(&amp;helloworld.HelloReply&#123;</span><br><span class="line">Message: <span class="string">"server stream: "</span> + res.GetName() + <span class="string">"_"</span> + strconv.Itoa(n),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">n++</span><br><span class="line">log.Printf(<span class="string">"client stream: %s"</span>, res.GetName())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_4/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">_, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: *name + <span class="string">"_"</span> + strconv.Itoa(n)&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"client stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"server stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印返回值</span></span><br><span class="line">log.Println(res.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stream.CloseSend()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"close stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:51:39 server listening at [::]:8080</span><br><span class="line">2023/06/16 20:51:42 client stream: world_0</span><br><span class="line">2023/06/16 20:51:42 client stream: world_1</span><br><span class="line">2023/06/16 20:51:42 client stream: world_2</span><br><span class="line">2023/06/16 20:51:42 client stream: world_3</span><br><span class="line">2023/06/16 20:51:42 client stream: world_4</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:51:42 server stream: world_0_0</span><br><span class="line">2023/06/16 20:51:42 server stream: world_1_1</span><br><span class="line">2023/06/16 20:51:42 server stream: world_2_2</span><br><span class="line">2023/06/16 20:51:42 server stream: world_3_3</span><br><span class="line">2023/06/16 20:51:42 server stream: world_4_4</span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍grpc调试工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（三）：客户端流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（三）：客户端流式rpc/</id>
    <published>2023-06-18T07:12:48.000Z</published>
    <updated>2023-07-21T05:36:57.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_3" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_3</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_3 &amp;&amp; <span class="built_in">cd</span> demo_3</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (stream HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_3/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(stream helloworld.Hello_SayHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> stream.SendAndClose(&amp;helloworld.HelloReply&#123;Message: <span class="string">"over"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Println(res.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_3/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Upload list err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line"><span class="comment">//向流中发送消息</span></span><br><span class="line">err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: <span class="string">"stream client rpc "</span> + strconv.Itoa(n)&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"stream request err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流并获取返回的消息</span></span><br><span class="line">res, err := stream.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"SayHello get response err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:24:15 server listening at [::]:8080</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 0</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 1</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 2</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 3</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 4</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:24:22 message:<span class="string">"over"</span></span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍双向流式rpc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（二）：服务端流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（二）：服务端流式rpc/</id>
    <published>2023-06-18T07:11:52.000Z</published>
    <updated>2023-07-21T05:36:57.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_2" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_2</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_2 &amp;&amp; <span class="built_in">cd</span> demo_2</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (stream HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_2/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(in *helloworld.HelloRequest, stream helloworld.Hello_SayHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Received: %v"</span>, in.GetName())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">stream.Send(&amp;helloworld.HelloReply&#123;Message: fmt.Sprintf(<span class="string">"hello %s---%d"</span>, in.Name, i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_2/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not call: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"stream error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"%s"</span>, res.Message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 18:56:57 server listening at [::]:8080</span><br><span class="line">2023/06/16 18:57:02 Received: world</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:11:55 hello world---0</span><br><span class="line">2023/06/16 20:11:55 hello world---1</span><br><span class="line">2023/06/16 20:11:55 hello world---2</span><br><span class="line">2023/06/16 20:11:55 hello world---3</span><br><span class="line">2023/06/16 20:11:55 hello world---4</span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍客户端流式rpc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（一）：单项rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8D%95%E9%A1%B9rpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（一）：单项rpc/</id>
    <published>2023-06-18T07:09:39.000Z</published>
    <updated>2023-07-21T05:36:57.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_1" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_1</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_1 &amp;&amp; <span class="built_in">cd</span> demo_1</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_1/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *helloworld.HelloRequest)</span> <span class="params">(*helloworld.HelloReply, error)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Received: %v"</span>, in.GetName())</span><br><span class="line"><span class="keyword">return</span> &amp;helloworld.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_1/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">r, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Greeting: %s"</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 18:56:57 server listening at [::]:8080</span><br><span class="line">2023/06/16 18:57:02 Received: world</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 18:57:02 Greeting: Hello world</span><br></pre></td></tr></table></figure><p>以上便是go实现单项rpc的所有内容，如果一切顺利，恭喜你，以及成功入门grpc，下一篇将向大家介绍服务端流式rpc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
</feed>
