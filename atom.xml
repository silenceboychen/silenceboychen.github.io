<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  <subtitle>morty&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.silenceboy.com/"/>
  <updated>2024-10-22T06:46:23.432Z</updated>
  <id>https://www.silenceboy.com/</id>
  
  <author>
    <name>morty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ASIL等级是什么</title>
    <link href="https://www.silenceboy.com/2024/10/22/ASIL%E7%AD%89%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://www.silenceboy.com/2024/10/22/ASIL等级是什么/</id>
    <published>2024-10-22T06:45:40.000Z</published>
    <updated>2024-10-22T06:46:23.432Z</updated>
    
    <content type="html"><![CDATA[<p>ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL A表示最低的安全要求。</p><h3 id="ASIL等级的定义"><a href="#ASIL等级的定义" class="headerlink" title="ASIL等级的定义"></a>ASIL等级的定义</h3><p>ASIL等级基于三个主要因素来确定：</p><ol><li><strong>严重性（Severity, S）</strong>：故障导致的潜在伤害的严重程度。</li><li><strong>暴露率（Exposure, E）</strong>：驾驶员或乘客暴露于潜在故障的频率。</li><li><strong>可控性（Controllability, C）</strong>：驾驶员或乘客在故障发生时控制车辆的能力。</li></ol><h3 id="ASIL等级的划分"><a href="#ASIL等级的划分" class="headerlink" title="ASIL等级的划分"></a>ASIL等级的划分</h3><p>根据上述三个因素的组合，ASIL等级可以分为以下四个级别：</p><ol><li><strong>ASIL A</strong>：最低的安全要求。适用于故障对安全影响较小、暴露率低且可控性高的情况。</li><li><strong>ASIL B</strong>：中等安全要求。适用于故障对安全影响中等、暴露率中等且可控性一般的情况。</li><li><strong>ASIL C</strong>：较高的安全要求。适用于故障对安全影响较大、暴露率较高且可控性较低的情况。</li><li><strong>ASIL D</strong>：最高的安全要求。适用于故障对安全影响非常大、暴露率非常高且几乎不可控的情况。</li></ol><h3 id="ASIL等级的确定"><a href="#ASIL等级的确定" class="headerlink" title="ASIL等级的确定"></a>ASIL等级的确定</h3><p>ASIL等级的确定通常通过一个风险评估矩阵来完成，该矩阵综合考虑严重性、暴露率和可控性三个因素。以下是一个简化的示例矩阵：</p><table><thead><tr><th>严重性/暴露率/可控性</th><th>E1（低）</th><th>E2（中低）</th><th>E3（中高）</th><th>E4（高）</th></tr></thead><tbody><tr><td>S1（低）</td><td>QM</td><td>QM</td><td>ASIL A</td><td>ASIL A</td></tr><tr><td>S2（中）</td><td>QM</td><td>ASIL A</td><td>ASIL B</td><td>ASIL B</td></tr><tr><td>S3（高）</td><td>ASIL A</td><td>ASIL B</td><td>ASIL C</td><td>ASIL D</td></tr><tr><td>S4（极高）</td><td>ASIL B</td><td>ASIL C</td><td>ASIL D</td><td>ASIL D</td></tr></tbody></table><p><strong>注</strong>：QM（Quality Management）表示不需要特别的安全措施，只需按照质量管理标准进行处理。</p><h3 id="ASIL等级的应用"><a href="#ASIL等级的应用" class="headerlink" title="ASIL等级的应用"></a>ASIL等级的应用</h3><p>在汽车电子系统的设计和开发过程中，确定ASIL等级是确保系统安全性的关键步骤。不同的ASIL等级对应不同的开发流程和验证要求：</p><ul><li><strong>ASIL A</strong>：基本的安全措施和验证。</li><li><strong>ASIL B</strong>：需要更严格的设计和测试流程。</li><li><strong>ASIL C</strong>：需要高级的安全分析和验证技术。</li><li><strong>ASIL D</strong>：需要最高级别的安全措施、冗余设计和全面的验证。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ASIL等级是评估和管理汽车电子系统安全性的关键工具。通过确定系统的ASIL等级，开发人员可以采取适当的设计和验证措施，以确保系统在各种可能的故障情况下都能保持安全性。ISO 26262标准提供了详细的指南和方法，帮助开发人员在整个开发生命周期中实现和维护所需的安全完整性等级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ASIL（Automotive Safety Integrity Level，汽车安全完整性等级）是ISO 26262标准中定义的一个概念，用于评估和分类汽车电子系统中潜在故障对安全的影响。ASIL等级从A到D，共分为四个级别，其中ASIL D表示最高的安全要求，ASIL 
      
    
    </summary>
    
      <category term="ASIL" scheme="https://www.silenceboy.com/categories/ASIL/"/>
    
    
      <category term="ASIL" scheme="https://www.silenceboy.com/tags/ASIL/"/>
    
  </entry>
  
  <entry>
    <title>SOC中除了R核和A核还有哪些处理器核心</title>
    <link href="https://www.silenceboy.com/2024/10/21/SOC%E4%B8%AD%E9%99%A4%E4%BA%86R%E6%A0%B8%E5%92%8CA%E6%A0%B8%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8%E5%BF%83/"/>
    <id>https://www.silenceboy.com/2024/10/21/SOC中除了R核和A核还有哪些处理器核心/</id>
    <published>2024-10-21T06:25:57.000Z</published>
    <updated>2024-10-21T06:26:19.127Z</updated>
    
    <content type="html"><![CDATA[<p>除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型：</p><h3 id="M核（Microcontroller-Core）"><a href="#M核（Microcontroller-Core）" class="headerlink" title="M核（Microcontroller Core）"></a>M核（Microcontroller Core）</h3><p>M核通常指的是微控制器核心，主要用于低功耗、低成本的嵌入式系统。以下是M核的一些特点和应用：</p><ol><li><strong>低功耗</strong>：设计目标是尽量减少功耗，适合电池供电的设备。</li><li><strong>简单架构</strong>：通常具有较简单的指令集和架构，易于编程和调试。</li><li><strong>集成外设</strong>：通常集成了丰富的外设接口，如ADC、DAC、UART、I2C、SPI等。</li><li><strong>实时性</strong>：虽然不如R核那样严格，但也能处理一些实时任务。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>家用电器</li><li>传感器节点</li><li>简单控制系统</li><li>物联网设备</li></ul><h3 id="NPU（Neural-Processing-Unit）"><a href="#NPU（Neural-Processing-Unit）" class="headerlink" title="NPU（Neural Processing Unit）"></a>NPU（Neural Processing Unit）</h3><p>NPU是神经网络处理单元，专门用于加速深度学习和人工智能任务。以下是NPU的一些特点和应用：</p><ol><li><strong>高效计算</strong>：专门优化用于矩阵运算和卷积操作，适合深度学习模型的推理和训练。</li><li><strong>并行处理</strong>：具有高度并行的计算能力，能够同时处理大量数据。</li><li><strong>低功耗</strong>：相对于通用处理器，NPU在执行AI任务时具有更高的能效比。</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>图像和视频处理</li><li>语音识别</li><li>自然语言处理</li><li>自动驾驶</li></ul><h3 id="DSP（Digital-Signal-Processor）"><a href="#DSP（Digital-Signal-Processor）" class="headerlink" title="DSP（Digital Signal Processor）"></a>DSP（Digital Signal Processor）</h3><p>DSP是数字信号处理器，专门用于处理数字信号，如音频、视频和通信信号。以下是DSP的一些特点和应用：</p><ol><li><strong>高效信号处理</strong>：专门优化用于快速傅里叶变换（FFT）、滤波和其他信号处理算法。</li><li><strong>实时处理</strong>：能够实时处理输入信号，适合实时音频和视频处理。</li><li><strong>低延迟</strong>：设计目标是尽量减少处理延迟，确保信号处理的实时性。</li></ol><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>音频处理（如回声消除、降噪）</li><li>视频处理（如编码、解码）</li><li>通信系统（如调制、解调）</li><li>雷达和声纳</li></ul><h3 id="GPU（Graphics-Processing-Unit）"><a href="#GPU（Graphics-Processing-Unit）" class="headerlink" title="GPU（Graphics Processing Unit）"></a>GPU（Graphics Processing Unit）</h3><p>GPU是图形处理单元，主要用于图形渲染和计算加速。以下是GPU的一些特点和应用：</p><ol><li><strong>高并行性</strong>：具有大量并行处理单元，能够同时处理大量数据。</li><li><strong>图形渲染</strong>：专门用于处理图形渲染任务，如3D图形、游戏图形等。</li><li><strong>通用计算</strong>：近年来，GPU也被广泛用于通用计算（GPGPU），如科学计算、机器学习等。</li></ol><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>游戏和娱乐</li><li>图形设计和渲染</li><li>科学计算</li><li>深度学习</li></ul><h3 id="VPU（Vision-Processing-Unit）"><a href="#VPU（Vision-Processing-Unit）" class="headerlink" title="VPU（Vision Processing Unit）"></a>VPU（Vision Processing Unit）</h3><p>VPU是视觉处理单元，专门用于处理计算机视觉任务。以下是VPU的一些特点和应用：</p><ol><li><strong>优化视觉任务</strong>：专门优化用于图像和视频处理任务，如对象检测、图像识别等。</li><li><strong>高效能效比</strong>：在处理视觉任务时具有高效的能效比。</li><li><strong>实时处理</strong>：能够实时处理图像和视频数据，适合实时应用。</li></ol><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>计算机视觉</li><li>增强现实（AR）和虚拟现实（VR）</li><li>自动驾驶</li><li>安全监控</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在现代SoC设计中，除了R核和A核，还有多种类型的处理器核心，如M核、NPU、DSP、GPU和VPU等。每种核心都有其特定的用途和优势，通过组合使用这些核心，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了R核（实时核心）和A核（应用核心），在系统级芯片（SoC）设计中，还有其他类型的处理器核心，它们各自有特定的用途和特点。以下是一些常见的核心类型：&lt;/p&gt;
&lt;h3 id=&quot;M核（Microcontroller-Core）&quot;&gt;&lt;a href=&quot;#M核（Microcontr
      
    
    </summary>
    
      <category term="SoC" scheme="https://www.silenceboy.com/categories/SoC/"/>
    
    
      <category term="SoC" scheme="https://www.silenceboy.com/tags/SoC/"/>
    
  </entry>
  
  <entry>
    <title>SOC的R核、A核有什么区别</title>
    <link href="https://www.silenceboy.com/2024/10/21/SOC%E7%9A%84R%E6%A0%B8%E3%80%81A%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.silenceboy.com/2024/10/21/SOC的R核、A核有什么区别/</id>
    <published>2024-10-21T06:22:57.000Z</published>
    <updated>2024-10-21T06:23:53.596Z</updated>
    
    <content type="html"><![CDATA[<p>在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。</p><h3 id="R核（Real-time-Core）"><a href="#R核（Real-time-Core）" class="headerlink" title="R核（Real-time Core）"></a>R核（Real-time Core）</h3><p>R核通常指的是实时处理器核心，主要用于处理实时任务。以下是R核的一些特点和应用：</p><ol><li><strong>实时性</strong>：R核设计用于处理需要严格时间约束的任务，确保任务在规定时间内完成。</li><li><strong>确定性</strong>：R核通常具有确定的响应时间，适合用于实时操作系统（RTOS）。</li><li><strong>低延迟</strong>：R核的设计目标是尽量减少处理延迟，以确保快速响应外部事件。</li><li><strong>低功耗</strong>：R核通常功耗较低，适合用于电池供电的嵌入式设备。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>工业自动化控制</li><li>汽车电子（如引擎控制单元）</li><li>医疗设备</li><li>物联网设备</li></ul><h3 id="A核（Application-Core）"><a href="#A核（Application-Core）" class="headerlink" title="A核（Application Core）"></a>A核（Application Core）</h3><p>A核通常指的是应用处理器核心，主要用于运行复杂的应用程序和操作系统。以下是A核的一些特点和应用：</p><ol><li><strong>高性能</strong>：A核设计用于处理复杂计算任务，具有较高的处理能力。</li><li><strong>多任务处理</strong>：A核通常支持多任务处理，能够运行完整的操作系统（如Linux、Android）。</li><li><strong>丰富的外设支持</strong>：A核通常集成了丰富的外设接口，如USB、HDMI、以太网等。</li><li><strong>较高功耗</strong>：由于需要处理复杂任务，A核的功耗通常较高。</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>智能手机和平板电脑</li><li>个人计算机</li><li>多媒体设备（如智能电视和机顶盒）</li><li>高级嵌入式系统（如无人机和机器人）</li></ul><h3 id="例子：ARM-Cortex-系列"><a href="#例子：ARM-Cortex-系列" class="headerlink" title="例子：ARM Cortex 系列"></a>例子：ARM Cortex 系列</h3><p>在ARM的Cortex系列处理器中，R核和A核的区别非常明显：</p><ul><li><strong>Cortex-R 系列</strong>：这是ARM的实时处理器系列，设计用于高可靠性和实时性应用，如Cortex-R5和Cortex-R8。</li><li><strong>Cortex-A 系列</strong>：这是ARM的应用处理器系列，设计用于高性能和复杂应用，如Cortex-A53、Cortex-A72等。</li></ul><h3 id="SoC中的组合"><a href="#SoC中的组合" class="headerlink" title="SoC中的组合"></a>SoC中的组合</h3><p>在许多SoC设计中，R核和A核常常被组合使用，以便同时满足实时处理和高性能计算的需求。例如：</p><ul><li><strong>智能手机SoC</strong>：通常包含多个Cortex-A系列核心用于运行操作系统和应用程序，同时可能包含一个或多个Cortex-R系列核心用于处理实时任务，如基带处理。</li><li><strong>汽车电子SoC</strong>：可能包含Cortex-R系列核心用于引擎控制和安全系统，同时包含Cortex-A系列核心用于信息娱乐系统。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>R核（Real-time Core）</strong>：用于实时任务，强调低延迟和确定性，适合工业控制、汽车电子等领域。</li><li><strong>A核（Application Core）</strong>：用于运行复杂应用程序和操作系统，强调高性能和多任务处理，适合智能手机、平板电脑等设备。</li></ul><p>通过结合使用R核和A核，SoC能够在单一芯片上实现多种功能，满足不同应用场景的需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在系统级芯片（SoC, System on Chip）设计中，R核和A核是指不同类型的处理器核心，它们各自具有不同的用途和特点。&lt;/p&gt;
&lt;h3 id=&quot;R核（Real-time-Core）&quot;&gt;&lt;a href=&quot;#R核（Real-time-Core）&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="SoC" scheme="https://www.silenceboy.com/categories/SoC/"/>
    
    
      <category term="SoC" scheme="https://www.silenceboy.com/tags/SoC/"/>
    
  </entry>
  
  <entry>
    <title>docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？</title>
    <link href="https://www.silenceboy.com/2024/06/28/docker%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E9%9D%9Eroot%EF%BC%8C%E4%B8%94%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AF%86%E7%A0%81%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Csudo%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>https://www.silenceboy.com/2024/06/28/docker容器默认用户非root，且不知道密码，无法执行sudo操作，该怎么解决？/</id>
    <published>2024-06-28T07:22:18.000Z</published>
    <updated>2024-06-28T07:23:01.137Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在 Docker 容器中默认用户是 <code>dev</code>，但不知道密码，无法执行 <code>sudo</code> 操作，你可以通过以下几种方法来解决这个问题：</p><h3 id="方法一：以-root-用户重新启动容器"><a href="#方法一：以-root-用户重新启动容器" class="headerlink" title="方法一：以 root 用户重新启动容器"></a>方法一：以 root 用户重新启动容器</h3><p>你可以以 <code>root</code> 用户重新启动容器，然后更改 <code>dev</code> 用户的密码或者直接执行你需要的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="方法二：修改-Dockerfile-重新构建镜像"><a href="#方法二：修改-Dockerfile-重新构建镜像" class="headerlink" title="方法二：修改 Dockerfile 重新构建镜像"></a>方法二：修改 Dockerfile 重新构建镜像</h3><p>如果你有 Dockerfile，可以修改 Dockerfile 来设置 <code>dev</code> 用户的密码或者直接使用 <code>root</code> 用户。</p><p>例如，修改 Dockerfile 来设置 <code>dev</code> 用户的密码：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> your_base_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 dev 用户的密码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他 Dockerfile 指令</span></span><br></pre></td></tr></table></figure><p>然后重新构建镜像并运行容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your_image_name .</span><br><span class="line">docker run -it your_image_name</span><br></pre></td></tr></table></figure><h3 id="方法三：创建新的镜像并修改用户配置"><a href="#方法三：创建新的镜像并修改用户配置" class="headerlink" title="方法三：创建新的镜像并修改用户配置"></a>方法三：创建新的镜像并修改用户配置</h3><p>如果你没有 Dockerfile，但可以访问容器的镜像，你可以创建一个新的镜像并修改用户配置。</p><ol><li><p>首先，启动一个新的容器并进入：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name temp_container your_image_name /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span><br></pre></td></tr></table></figure></li><li><p>退出容器并提交更改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit temp_container your_new_image_name</span><br></pre></td></tr></table></figure></li><li><p>使用新的镜像启动容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it your_new_image_name</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法四：直接进入容器并修改密码"><a href="#方法四：直接进入容器并修改密码" class="headerlink" title="方法四：直接进入容器并修改密码"></a>方法四：直接进入容器并修改密码</h3><p>如果容器已经在运行，你可以直接进入容器并修改 <code>dev</code> 用户的密码。</p><ol><li><p>首先，以 <code>root</code> 用户进入容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法五：使用-docker-commit-修改现有容器"><a href="#方法五：使用-docker-commit-修改现有容器" class="headerlink" title="方法五：使用 docker commit 修改现有容器"></a>方法五：使用 <code>docker commit</code> 修改现有容器</h3><p>如果你已经有一个运行中的容器，可以使用 <code>docker commit</code> 来创建一个新的镜像，并在新镜像中修改 <code>dev</code> 用户的密码。</p><ol><li><p>首先，以 <code>root</code> 用户进入容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>在容器中修改 <code>dev</code> 用户的密码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'dev:your_new_password'</span> | chpasswd</span><br></pre></td></tr></table></figure></li><li><p>退出容器并提交更改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker commit &lt;container_id_or_name&gt; your_new_image_name</span><br></pre></td></tr></table></figure></li><li><p>使用新的镜像启动容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it your_new_image_name</span><br></pre></td></tr></table></figure></li></ol><p>通过这些方法，你可以解决无法执行 <code>sudo</code> 操作的问题，并根据需要修改 <code>dev</code> 用户的密码或直接使用 <code>root</code> 用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你在 Docker 容器中默认用户是 &lt;code&gt;dev&lt;/code&gt;，但不知道密码，无法执行 &lt;code&gt;sudo&lt;/code&gt; 操作，你可以通过以下几种方法来解决这个问题：&lt;/p&gt;
&lt;h3 id=&quot;方法一：以-root-用户重新启动容器&quot;&gt;&lt;a href=&quot;#方法一
      
    
    </summary>
    
      <category term="docker" scheme="https://www.silenceboy.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.silenceboy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比</title>
    <link href="https://www.silenceboy.com/2024/06/24/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%EF%BC%9Asonar%E3%80%81fireline%E3%80%81coverity%E3%80%81fortify%E3%80%81blackduck%E5%AF%B9%E6%AF%94/"/>
    <id>https://www.silenceboy.com/2024/06/24/代码扫描工具：sonar、fireline、coverity、fortify、blackduck对比/</id>
    <published>2024-06-24T08:02:01.000Z</published>
    <updated>2024-06-24T08:10:17.375Z</updated>
    
    <content type="html"><![CDATA[<p>代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别：</p><h3 id="1-SonarQube"><a href="#1-SonarQube" class="headerlink" title="1. SonarQube"></a>1. SonarQube</h3><p><strong>简介</strong>:</p><ul><li>SonarQube 是一个开源的代码质量管理工具。</li><li>支持多种编程语言，如 Java、C#、JavaScript、TypeScript、Python 等。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的漏洞、错误和代码异味。</li><li>代码度量：提供代码覆盖率、复杂度等度量指标。</li><li>集成：与 CI/CD 工具（如 Jenkins、GitLab CI）集成，自动化代码质量检查。</li></ul><p><strong>优点</strong>:</p><ul><li>开源且社区活跃。</li><li>支持多种插件，扩展功能强大。</li><li>直观的用户界面，易于使用。</li></ul><h3 id="2-Fireline"><a href="#2-Fireline" class="headerlink" title="2. Fireline"></a>2. Fireline</h3><p><strong>简介</strong>:</p><ul><li>Fireline 是一个专注于代码安全的静态分析工具。</li></ul><p><strong>功能</strong>:</p><ul><li>检测代码中的安全漏洞，如 SQL 注入、跨站脚本攻击（XSS）等。</li><li>提供详细的漏洞报告和修复建议。</li></ul><p><strong>优点</strong>:</p><ul><li>专注于安全漏洞检测，提供深度分析。</li><li>适用于需要高安全性的应用程序开发。</li></ul><h3 id="3-Coverity"><a href="#3-Coverity" class="headerlink" title="3. Coverity"></a>3. Coverity</h3><p><strong>简介</strong>:</p><ul><li>Coverity 是 Synopsys 提供的静态代码分析工具。</li><li>支持多种编程语言，如 C、C++、Java、C#、JavaScript 等。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的缺陷和安全漏洞。</li><li>自动化分析：与 CI/CD 工具集成，实现自动化代码扫描。</li><li>报告和修复建议：提供详细的缺陷报告和修复建议。</li></ul><p><strong>优点</strong>:</p><ul><li>高准确性和低误报率。</li><li>强大的企业级支持和服务。</li><li>支持广泛的编程语言和复杂代码库。</li></ul><h3 id="4-Fortify"><a href="#4-Fortify" class="headerlink" title="4. Fortify"></a>4. Fortify</h3><p><strong>简介</strong>:</p><ul><li>Fortify 是 Micro Focus 提供的应用安全测试工具。</li><li>包含静态应用安全测试（SAST）和动态应用安全测试（DAST）。</li></ul><p><strong>功能</strong>:</p><ul><li>静态代码分析：检测代码中的安全漏洞。</li><li>动态分析：在运行时检测应用程序的安全漏洞。</li><li>安全审计和合规性检查。</li></ul><p><strong>优点</strong>:</p><ul><li>综合的安全测试解决方案，覆盖静态和动态分析。</li><li>强大的企业级支持和服务。</li><li>提供详细的漏洞修复指导。</li></ul><h3 id="5-Black-Duck"><a href="#5-Black-Duck" class="headerlink" title="5. Black Duck"></a>5. Black Duck</h3><p><strong>简介</strong>:</p><ul><li>Black Duck 是 Synopsys 提供的开源安全和管理工具。</li><li>专注于开源组件的安全和合规性。</li></ul><p><strong>功能</strong>:</p><ul><li>开源组件扫描：检测项目中使用的开源组件。</li><li>漏洞检测：识别开源组件中的已知漏洞。</li><li>许可证合规性：检查开源组件的许可证合规性。</li></ul><p><strong>优点</strong>:</p><ul><li>专注于开源组件的管理和安全。</li><li>提供详细的漏洞和许可证合规报告。</li><li>与其他 Synopsys 工具集成，提供全面的安全解决方案。</li></ul><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul><li><strong>SonarQube</strong>：主要关注代码质量和代码异味，提供全面的代码度量和质量报告。</li><li><strong>Fireline</strong>：专注于代码安全漏洞的检测，适用于需要高安全性的应用。</li><li><strong>Coverity</strong>：提供高准确性的静态代码分析，适合复杂和大型代码库。</li><li><strong>Fortify</strong>：综合的应用安全测试工具，覆盖静态和动态分析，适合全面的安全测试需求。</li><li><strong>Black Duck</strong>：专注于开源组件的安全和合规性管理，适用于使用大量开源组件的项目。</li></ul><p>每种工具都有其特定的优势和应用场景，选择合适的工具应根据项目的具体需求和环境来决定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码扫描工具在软件开发中扮演着重要的角色，它们帮助开发者识别和修复代码中的潜在问题。以下是对 SonarQube、Fireline、Coverity、Fortify 和 Black Duck 的介绍及其区别：&lt;/p&gt;
&lt;h3 id=&quot;1-SonarQube&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="代码扫描" scheme="https://www.silenceboy.com/categories/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
    
      <category term="代码扫描" scheme="https://www.silenceboy.com/tags/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本里的#*@是什么意思</title>
    <link href="https://www.silenceboy.com/2023/09/27/shell%E8%84%9A%E6%9C%AC%E9%87%8C%E7%9A%84-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>https://www.silenceboy.com/2023/09/27/shell脚本里的-是什么意思/</id>
    <published>2023-09-27T09:22:45.000Z</published>
    <updated>2023-12-05T01:44:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>在Shell脚本中，<code>${variable#pattern}</code> 是一种字符串处理方式，其中 <code>#</code> 后跟着一个模式<code>（pattern）</code>。这个语法的作用是从字符串变量 variable 的开头删除匹配 <code>pattern</code> 的最短子串，并返回删除后的结果。<code>${variable#*@}</code> 的含义是：</p><p>● <code>variable</code> 是一个字符串变量，通常是一个包含文本的字符串。</p><p>● <code>#</code> 表示从字符串开头开始匹配。</p><p>● <code>*@</code> 是一个通配符模式，它匹配字符串中的任意字符序列，直到第一个 @ 字符。</p><p>所以，<code>${variable#*@}</code> 的作用是从变量 <code>variable</code> 的开头删除匹配 <code>*@</code> 模式的最短子串，并返回删除后的结果。通常，这种操作用于处理文本或字符串，以过滤掉或提取感兴趣的部分。<br>例如，如果 <code>variable</code> 的值是 <code>&quot;user@example.com&quot;</code>，那么 <code>${variable#*@}</code> 的结果将是 <code>&quot;example.com&quot;</code>，因为它删除了字符串中第一个 <code>&quot;@&quot;</code> 符号及其之前的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Shell脚本中，&lt;code&gt;${variable#pattern}&lt;/code&gt; 是一种字符串处理方式，其中 &lt;code&gt;#&lt;/code&gt; 后跟着一个模式&lt;code&gt;（pattern）&lt;/code&gt;。这个语法的作用是从字符串变量 variable 的开头删除匹配 &lt;co
      
    
    </summary>
    
      <category term="shell" scheme="https://www.silenceboy.com/categories/shell/"/>
    
    
      <category term="shell" scheme="https://www.silenceboy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>用go开发sse接口</title>
    <link href="https://www.silenceboy.com/2023/07/11/%E7%94%A8go%E5%BC%80%E5%8F%91sse%E6%8E%A5%E5%8F%A3/"/>
    <id>https://www.silenceboy.com/2023/07/11/用go开发sse接口/</id>
    <published>2023-07-11T02:50:24.000Z</published>
    <updated>2023-07-21T05:36:57.832Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p>sse 服务器发送事件(Server-Sent Events)，服务端向客户端单向传递消息。在一些只需要接受服务端数据的需求中可以取代websocket技术，使用起来也很简单。</p><p>目前go已经有一些支持sse的库，我这里选用了：<code>eventsource.v1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get gopkg.in/antage/eventsource.v1</span></span><br></pre></td></tr></table></figure><h2 id="广播模式SSE"><a href="#广播模式SSE" class="headerlink" title="广播模式SSE"></a>广播模式SSE</h2><p>广播模式SSE指不设置事件名，或者说是不设置通道，所有客户端接收同样的数据。</p><p>具体代码实现如下：<a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test1" target="_blank" rel="noopener">点击查看源码</a></p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gopkg.in/antage/eventsource.v1"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播模式SSE，不设置事件名称（也可理解为通道）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">es := eventsource.New(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> es.Close()</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"./public"</span>)))</span><br><span class="line">http.Handle(<span class="string">"/events"</span>, es)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 只设置发送数据，不添加事件名</span></span><br><span class="line">es.SendEventMessage(fmt.Sprintf(<span class="string">"send data: %s"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>)), <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">log.Printf(<span class="string">"客户端连接数: %d"</span>, es.ConsumersCount())</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"Open URL http://localhost:8080/ in your browser."</span>)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前端</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">        const es = new EventSource("http://localhost:8080/events");</span><br><span class="line">        es.onmessage = function (e) &#123;</span><br><span class="line">            document.getElementById("test")</span><br><span class="line"><span class="xml">                .insertAdjacentHTML("beforeend", "<span class="tag">&lt;<span class="name">li</span>&gt;</span>" + e.data + "<span class="tag">&lt;/<span class="name">li</span>&gt;</span>");</span></span><br><span class="line">        &#125;</span><br><span class="line">        es.onerror = function (e) &#123;</span><br><span class="line">            // readyState说明</span><br><span class="line">            // 0：浏览器与服务端尚未建立连接或连接已被关闭</span><br><span class="line">            // 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</span><br><span class="line">            // 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</span><br><span class="line">            console.log("readyState = " + e.currentTarget.readyState);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动服务端代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main</span></span><br></pre></td></tr></table></figure><p>打开浏览器访问前端代码： <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p>服务端输出：</p><p><img src="./images/2023-06-29_20-34_1.png" alt></p><p>前端输出：</p><p><img src="./images/2023-06-29_20-34.png" alt></p><h2 id="点对点模式SSE"><a href="#点对点模式SSE" class="headerlink" title="点对点模式SSE"></a>点对点模式SSE</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test2" target="_blank" rel="noopener">点击查看源代码</a></p><p>实现方式和广播模式差不多，只需做简单修改：</p><p>服务端代码只需添加事件名称：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置事件名称为：test-event</span></span><br><span class="line">es.SendEventMessage(fmt.Sprintf(<span class="string">"send data: %s"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>)), <span class="string">"test-event"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>前端代码修改接收方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">es.addEventListener(<span class="string">"test-event"</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span><br><span class="line">        .insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;li&gt;"</span> + e.data + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="支持跨域的SSE"><a href="#支持跨域的SSE" class="headerlink" title="支持跨域的SSE"></a>支持跨域的SSE</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test3" target="_blank" rel="noopener">点击查看源代码</a></p><p>现在项目开发基本上都是前后端分离，这样就会存在跨域问题，SSE解决跨域的方式只需要在<code>new</code>方法内增加允许跨域请求头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">es := eventsource.New(</span><br><span class="line">    eventsource.DefaultSettings(),</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            []<span class="keyword">byte</span>(<span class="string">"X-Accel-Buffering: no"</span>),</span><br><span class="line">            []<span class="keyword">byte</span>(<span class="string">"Access-Control-Allow-Origin: *"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>前端创建sse连接时也可添加允许跨域参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> es = <span class="keyword">new</span> EventSource(<span class="string">"http://localhost:8080/events"</span>, &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="解决火狐浏览器断开不会自动重连问题"><a href="#解决火狐浏览器断开不会自动重连问题" class="headerlink" title="解决火狐浏览器断开不会自动重连问题"></a>解决火狐浏览器断开不会自动重连问题</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_6/test4" target="_blank" rel="noopener">点击查看源代码</a></p><p>在Chrome浏览器中sse断开后会自动重连，但firefox浏览器中断开后不会重连，解决办法是，前端js通过判断连接状态主动进行重连请求，通过判断readyState的值进行重新调用初始化操作</p><p>readyState说明：</p><ul><li>0：浏览器与服务端尚未建立连接或连接已被关闭</li><li>1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</li><li>2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</li></ul><p>前端代码可修改为如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> es = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 解决火狐浏览器断开不会自动重连问题</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">initES</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (es == <span class="literal">null</span> || es.readyState == <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="javascript">                es = <span class="keyword">new</span> EventSource(<span class="string">"http://localhost:8080/events"</span>, &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;);</span></span><br><span class="line"><span class="javascript">                es.addEventListener(<span class="string">"test-event"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span></span><br><span class="line"><span class="javascript">                        .insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;li&gt;"</span> + e.data + <span class="string">"&lt;/li&gt;"</span>);</span></span><br><span class="line">                &#125;);</span><br><span class="line"><span class="javascript">                es.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// readyState说明</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 0：浏览器与服务端尚未建立连接或连接已被关闭</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 1：浏览器与服务端已成功连接，浏览器正在处理接收到的事件及数据</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 2：浏览器与服务端建立连接失败，客户端不再继续建立与服务端之间的连接</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"readyState = "</span> + e.currentTarget.readyState);</span></span><br><span class="line">                    if (es.readyState == 2) &#123;</span><br><span class="line">                        setTimeout(initES, 5000)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        initES()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sse 服务器发送事件(Server-Sent Events)，服务端向客
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（五）：grpc调试工具</title>
    <link href="https://www.silenceboy.com/2023/06/26/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Agrpc%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.silenceboy.com/2023/06/26/grpc系列课程（五）：grpc调试工具/</id>
    <published>2023-06-26T02:38:01.000Z</published>
    <updated>2023-07-21T05:36:57.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p>平时我们编写http的api接口时能够很方便的通过postman工具进行接口调试，那么grpc接口是否也有类似postman的工具可以调试呐？<br>当然可以，github上有一款工具<a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">grpcui</a>，专门用来在浏览器中进行grpc接口调试。</p><h2 id="安装grpcui工具"><a href="#安装grpcui工具" class="headerlink" title="安装grpcui工具"></a>安装grpcui工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/fullstorydev/grpcui/cmd/grpcui@latest</span><br></pre></td></tr></table></figure><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><p>我们以<code>demo_1</code>测试代码为例进行调试。首先在项目中安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/fullstorydev/grpcui</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br></pre></td></tr></table></figure><h3 id="启动grpcui"><a href="#启动grpcui" class="headerlink" title="启动grpcui"></a>启动grpcui</h3><p>另起一个终端，执行一下命令，注意这里的端口号要和grpc服务端口号保持一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grpcui -plaintext 127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>如果你在执行以上命令的时候出现一下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to compute set of methods to expose: server does not support the reflection API</span><br></pre></td></tr></table></figure><p>需要在<code>server/main.go</code>文件中添加如下代码，增加反射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection.Register(s)</span><br></pre></td></tr></table></figure><p>此时再运行以上启动grpcui命令，可看到一下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gRPC Web UI available at http://127.0.0.1:41619/</span><br><span class="line">Opening in existing browser session.</span><br></pre></td></tr></table></figure><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>浏览器打开<code>http://127.0.0.1:41619/</code> ,可以看到grpcui调试页面：<br><img src="/../images/2023-06-18_15-34.png" alt></p><p>点击<code>Invoke</code>按钮，可以看到<code>Response</code>tab页有对于的相应数据：<br><img src="/../images/2023-06-18_15-36.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时我们编写http的api接口时能够很方便的通过postman工具进行接
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（四）：双向流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8F%8C%E5%90%91%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（四）：双向流式rpc/</id>
    <published>2023-06-18T07:13:21.000Z</published>
    <updated>2023-07-21T05:36:57.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_4" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_4</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_4 &amp;&amp; <span class="built_in">cd</span> demo_4</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (stream HelloRequest) <span class="keyword">returns</span> (stream HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_4/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(stream helloworld.Hello_SayHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = stream.Send(&amp;helloworld.HelloReply&#123;</span><br><span class="line">Message: <span class="string">"server stream: "</span> + res.GetName() + <span class="string">"_"</span> + strconv.Itoa(n),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">n++</span><br><span class="line">log.Printf(<span class="string">"client stream: %s"</span>, res.GetName())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_4/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">_, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: *name + <span class="string">"_"</span> + strconv.Itoa(n)&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"client stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"server stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印返回值</span></span><br><span class="line">log.Println(res.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stream.CloseSend()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"close stream err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:51:39 server listening at [::]:8080</span><br><span class="line">2023/06/16 20:51:42 client stream: world_0</span><br><span class="line">2023/06/16 20:51:42 client stream: world_1</span><br><span class="line">2023/06/16 20:51:42 client stream: world_2</span><br><span class="line">2023/06/16 20:51:42 client stream: world_3</span><br><span class="line">2023/06/16 20:51:42 client stream: world_4</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:51:42 server stream: world_0_0</span><br><span class="line">2023/06/16 20:51:42 server stream: world_1_1</span><br><span class="line">2023/06/16 20:51:42 server stream: world_2_2</span><br><span class="line">2023/06/16 20:51:42 server stream: world_3_3</span><br><span class="line">2023/06/16 20:51:42 server stream: world_4_4</span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍grpc调试工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（三）：客户端流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（三）：客户端流式rpc/</id>
    <published>2023-06-18T07:12:48.000Z</published>
    <updated>2023-07-21T05:36:57.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_3" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_3</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_3 &amp;&amp; <span class="built_in">cd</span> demo_3</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (stream HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_3/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(stream helloworld.Hello_SayHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> stream.SendAndClose(&amp;helloworld.HelloReply&#123;Message: <span class="string">"over"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Println(res.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_3/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Upload list err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line"><span class="comment">//向流中发送消息</span></span><br><span class="line">err := stream.Send(&amp;helloworld.HelloRequest&#123;Name: <span class="string">"stream client rpc "</span> + strconv.Itoa(n)&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"stream request err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流并获取返回的消息</span></span><br><span class="line">res, err := stream.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"SayHello get response err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:24:15 server listening at [::]:8080</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 0</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 1</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 2</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 3</span><br><span class="line">2023/06/16 20:24:22 stream client rpc 4</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:24:22 message:<span class="string">"over"</span></span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍双向流式rpc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（二）：服务端流式rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E5%BC%8Frpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（二）：服务端流式rpc/</id>
    <published>2023-06-18T07:11:52.000Z</published>
    <updated>2023-07-21T05:36:57.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_2" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_2</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_2 &amp;&amp; <span class="built_in">cd</span> demo_2</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><p>流式<code>rpc</code>使用<code>stream</code>关键字定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (stream HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_2/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(in *helloworld.HelloRequest, stream helloworld.Hello_SayHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Received: %v"</span>, in.GetName())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">stream.Send(&amp;helloworld.HelloReply&#123;Message: fmt.Sprintf(<span class="string">"hello %s---%d"</span>, in.Name, i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_2/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">stream, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not call: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"stream error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"%s"</span>, res.Message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 18:56:57 server listening at [::]:8080</span><br><span class="line">2023/06/16 18:57:02 Received: world</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 20:11:55 hello world---0</span><br><span class="line">2023/06/16 20:11:55 hello world---1</span><br><span class="line">2023/06/16 20:11:55 hello world---2</span><br><span class="line">2023/06/16 20:11:55 hello world---3</span><br><span class="line">2023/06/16 20:11:55 hello world---4</span><br></pre></td></tr></table></figure><p>下一篇将向大家介绍客户端流式rpc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>grpc系列课程（一）：单项rpc</title>
    <link href="https://www.silenceboy.com/2023/06/18/grpc%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8D%95%E9%A1%B9rpc/"/>
    <id>https://www.silenceboy.com/2023/06/18/grpc系列课程（一）：单项rpc/</id>
    <published>2023-06-18T07:09:39.000Z</published>
    <updated>2023-07-21T05:36:57.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发环境：</p><p>系统： ubuntu20.04</p><p>go版本： 1.19</p><p>编辑器： goland</p></blockquote><p><code>grpc</code>：远程过程调用，使用场景很多，也是比较流行的技术之一。使用go开发grpc服务，除了必须的go语言开发环境之外，还需要安装grpc相关命令。</p><h2 id="grpc环境配置"><a href="#grpc环境配置" class="headerlink" title="grpc环境配置"></a>grpc环境配置</h2><h3 id="protoc安装"><a href="#protoc安装" class="headerlink" title="protoc安装"></a>protoc安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y protobuf-compiler</span><br><span class="line">$ protoc --version</span><br><span class="line"></span><br><span class="line">libprotoc 3.6.1</span><br></pre></td></tr></table></figure><p>如果是其他系统电脑，安装protoc可参考文档：<a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener">Protocol Buffer Compiler Installation</a></p><h2 id="protocol编译插件安装"><a href="#protocol编译插件安装" class="headerlink" title="protocol编译插件安装"></a>protocol编译插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure><p>安装完成后可以在bin目录下看到相关指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line">protoc-gen-go  protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p><a href="https://github.com/silenceboychen/gostudy/tree/main/demo_1" target="_blank" rel="noopener">项目源码地址</a></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── demo_1</span><br><span class="line">│   ├── client</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   ├── go.sum</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   │   ├── helloworld_grpc.pb.go</span><br><span class="line">│   │   ├── helloworld.pb.go</span><br><span class="line">│   │   └── helloworld.proto</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── server</span><br><span class="line">│       └── main.go</span><br></pre></td></tr></table></figure><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo_1 &amp;&amp; <span class="built_in">cd</span> demo_1</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><h3 id="安装grpc依赖"><a href="#安装grpc依赖" class="headerlink" title="安装grpc依赖"></a>安装grpc依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># helloworld/helloworld.proto</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/helloworld"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">  string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure><p>命令执行成功之后会在helloworld目录下生成两个文件： <code>helloworld_grpc.pb.go</code>和<code>helloworld.pb.go</code>，<strong>注意：</strong> 不要手动编辑这两个文件。</p><h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><p><code>flag</code>用法可参考官方文档： <a href="https://pkg.go.dev/flag" target="_blank" rel="noopener">https://pkg.go.dev/flag</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_1/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">port = flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The server port"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">helloworld.UnimplementedHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *helloworld.HelloRequest)</span> <span class="params">(*helloworld.HelloReply, error)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Received: %v"</span>, in.GetName())</span><br><span class="line"><span class="keyword">return</span> &amp;helloworld.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">reflection.Register(s)</span><br><span class="line">helloworld.RegisterHelloServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/silenceboychen/gostudy/demo_1/helloworld"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"the address to connect to"</span>)</span><br><span class="line">name = flag.String(<span class="string">"name"</span>, <span class="string">"world"</span>, <span class="string">"Name to greet"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := helloworld.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">r, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Greeting: %s"</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>开启两个终端，分别运行服务端代码和客户端代码，服务端代码要先运行。</p><p><strong>服务端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 18:56:57 server listening at [::]:8080</span><br><span class="line">2023/06/16 18:57:02 Received: world</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/main.go</span><br><span class="line"></span><br><span class="line">2023/06/16 18:57:02 Greeting: Hello world</span><br></pre></td></tr></table></figure><p>以上便是go实现单项rpc的所有内容，如果一切顺利，恭喜你，以及成功入门grpc，下一篇将向大家介绍服务端流式rpc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发环境：&lt;/p&gt;
&lt;p&gt;系统： ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本： 1.19&lt;/p&gt;
&lt;p&gt;编辑器： goland&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;grpc&lt;/code&gt;：远程过程调用，使用场景很多，也是比较流
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu20.04禁用搜狗输入法繁简体快捷键设置</title>
    <link href="https://www.silenceboy.com/2023/06/14/ubuntu20-04%E7%A6%81%E7%94%A8%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E7%B9%81%E7%AE%80%E4%BD%93%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://www.silenceboy.com/2023/06/14/ubuntu20-04禁用搜狗输入法繁简体快捷键设置/</id>
    <published>2023-06-14T03:00:52.000Z</published>
    <updated>2023-07-21T05:36:57.831Z</updated>
    
    <content type="html"><![CDATA[<p>最近在ubuntu20.04系统上安装了搜狗输入法之后，发现<code>vscode，idea，golang</code>等编辑器的全局搜索快捷键<code>Ctrl+Shift+F</code>无法使用了，经排查发现是因为搜狗输入法占用了该快捷键，是搜狗输入法的繁简体切换快捷键。打开搜狗输入法的设置页面可以在高级选项里看到。</p><p><img src="/../images/2023-06-14_11-07.png" alt></p><p>但是在设置里取消简繁切换快捷键的勾选保存之后发现无效果，快捷键依然被占用。</p><p>正确的解决方案是：</p><ol><li>修改搜狗输入法配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.config/sogoupinyin/conf/env.ini</span><br></pre></td></tr></table></figure><p>找到<code>ShortCutFanJian</code>配置，将值改为0；默认1，等于开启；改为0表示关闭</p><ol start="2"><li>打开系统输入法配置</li></ol><p><img src="/../images/2023-06-14_13-23.png" alt></p><ol start="3"><li><p>附加组件中找到简繁转换，点击配置<br><img src="/../images/2023-06-14_13-25.png" alt></p></li><li><p>将默认快捷键设置为空, 保存即可。<br><img src="/../images/2023-06-14_13-26.png" alt></p></li></ol><p>如果发现未生效，需要重启电脑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在ubuntu20.04系统上安装了搜狗输入法之后，发现&lt;code&gt;vscode，idea，golang&lt;/code&gt;等编辑器的全局搜索快捷键&lt;code&gt;Ctrl+Shift+F&lt;/code&gt;无法使用了，经排查发现是因为搜狗输入法占用了该快捷键，是搜狗输入法的繁简体切换
      
    
    </summary>
    
      <category term="linux" scheme="https://www.silenceboy.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.silenceboy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>gomobile开发安卓应用环境搭建完整流程</title>
    <link href="https://www.silenceboy.com/2023/06/08/gomobile%E5%BC%80%E5%8F%91%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.silenceboy.com/2023/06/08/gomobile开发安卓应用环境搭建完整流程/</id>
    <published>2023-06-08T05:33:05.000Z</published>
    <updated>2023-06-08T05:34:01.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>go环境搭建不在这里赘述。</p><p>以下内容的执行环境为：</p><p>系统：ubuntu20.04</p><p>go版本：v1.19</p></blockquote><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>执行以下命令创建一个go开发安卓应用的测试目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir $GOPATH/src/goapp &amp;&amp; cd $GOPATH/src/goapp</span><br><span class="line">$ go mod init</span><br></pre></td></tr></table></figure><p>在该目录下执行以下命令获取官方提供的示例项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -d golang.org/x/mobile/example/basic</span><br></pre></td></tr></table></figure><h1 id="安装gomibile"><a href="#安装gomibile" class="headerlink" title="安装gomibile"></a>安装gomibile</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install golang.org/x/mobile/cmd/gomobile@latest</span><br><span class="line">$ gomobile init</span><br></pre></td></tr></table></figure><p>然后执行以下命令打包安卓应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gomobile build -target=android -androidapi 19 golang.org/x/mobile/example/basic</span><br></pre></td></tr></table></figure><p>此时会发现以下相关错误：</p><pre><code>gomobile: could not locate Android SDK: stat /home/test/Android/Sdk: no such file or directory; Android SDK was not found at /home/test/Android/Sdkgomobile: no usable NDK in /home/test/Android/Sdk: open /home/test/Android/Sdk/ndk: no such file or directory, open /home/test/Android/Sdk/ndk-bundle/meta/platforms.json: no such file or directory</code></pre><p>这是因为本地没有配置安卓开发环境导致的。</p><h1 id="安卓开发环境搭建"><a href="#安卓开发环境搭建" class="headerlink" title="安卓开发环境搭建"></a>安卓开发环境搭建</h1><h2 id="Android-Studio安装"><a href="#Android-Studio安装" class="headerlink" title="Android Studio安装"></a>Android Studio安装</h2><p>访问谷歌中国开发者网站下载 Android Studio 编辑器：<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">https://developer.android.google.cn/studio</a></p><p>下载完成后执行以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将安装包移到/opt目录下，需要管理员权限</span></span><br><span class="line">$ sudo mv android-studio-2022.2.1.20-linux.tar.gz /opt</span><br><span class="line"><span class="comment"># 进入/opt目录</span></span><br><span class="line">$ <span class="built_in">cd</span> /opt</span><br><span class="line"><span class="comment"># 解压文件，需要管理员权限</span></span><br><span class="line">$ sudo tar -xzvf android-studio-2022.2.1.20-linux.tar.gz</span><br><span class="line"><span class="comment"># 运行Android Studio</span></span><br><span class="line">$ ./android-studio/bin/studio.sh</span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想在任意位置打开android studio，可配置软连接</span></span><br><span class="line">$ sudo ln -s /opt/android-studio/bin/studio.sh /usr/bin/android-studio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置完成以后在任意位置执行android-studio即可打开应用</span></span><br><span class="line">$ android-studio</span><br></pre></td></tr></table></figure><p>第一次打开android-studio需要进行一些配置，一直选择下一步设置即可，其中有两个地方需要注意：</p><ol><li>选择自定义安装</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6726dec7c44037bcedd07064fa7050~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ol start="2"><li>插件安装，可以全选</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf62541fd1343e9a952444c91f418a2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>插件安装完成之后点击Finish即可打开应用。</p><h2 id="安装NDK"><a href="#安装NDK" class="headerlink" title="安装NDK"></a>安装NDK</h2><p>Android studio安装完成后并没有万事大吉，默认并没安装NDK，需要自己手工再安装。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f3ae9976b04abaad1491894d82d356~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/040bf7ba8aa54a4285b2f2996774a5b0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>点击ok会自动下载选择的插件。</p><h1 id="编译安卓应用"><a href="#编译安卓应用" class="headerlink" title="编译安卓应用"></a>编译安卓应用</h1><p>此时继续回到之前的项目目录，执行安卓构建命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gomobile build -target=android -androidapi 19 golang.org/x/mobile/example/basic</span><br></pre></td></tr></table></figure><p>这一次没有出现报错，并且目录下多了一个basic.apk文件，该文件即为打包成功的安卓应用，可以安装一个安卓模拟器进行测试了。</p><h1 id="安装安卓模拟器"><a href="#安装安卓模拟器" class="headerlink" title="安装安卓模拟器"></a>安装安卓模拟器</h1><p>模拟器我选用了Anbox</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo snap install --devmode --edge anbox</span><br></pre></td></tr></table></figure><p>安装完成之后执行以下命令启动安卓模拟器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ anbox.appmgr</span><br></pre></td></tr></table></figure><p>我比较顺利没有遇到报错，如果遇到模拟器启动报错，可以参考文章：<a href="https://juejin.cn/post/7152407243974148127" target="_blank" rel="noopener">https://juejin.cn/post/7152407243974148127</a> 解决</p><p>打开后的界面如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/279fd239661844cd8ec94a9449b20cb1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h1 id="测试应用"><a href="#测试应用" class="headerlink" title="测试应用"></a>测试应用</h1><p>安装安卓应用还需要adb命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install android-tools-adb -y</span><br></pre></td></tr></table></figure><p>然后在最开始的项目目录下执行以下命令安装应用，此时安卓模拟器必须是打开的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ asb install ./basic.apk</span><br><span class="line"># 或者</span><br><span class="line">$ adb install /home/test/go/src/goapp/basic.apk</span><br></pre></td></tr></table></figure><p>安装成功后即可在模拟器中看到该应用</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b43efa40ce324a9caf8b08ae2759d9d5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>单击打开，运行效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/902dd6d8b0064000b929cde2f445f482~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>此文章主要目的是为了帮助你了解如何使用golang开发安卓应用的流程，流程打通之后，可以结合自己的想法，做一些自己的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;go环境搭建不在这里赘述。&lt;/p&gt;
&lt;p&gt;以下内容的执行环境为：&lt;/p&gt;
&lt;p&gt;系统：ubuntu20.04&lt;/p&gt;
&lt;p&gt;go版本：v1.19&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;项目创建&quot;&gt;&lt;a href=&quot;#项目创建&quot; cla
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go语言1.18 go:linkname must refer to declared function or variable解决办法</title>
    <link href="https://www.silenceboy.com/2022/07/12/go%E8%AF%AD%E8%A8%801-18-go-linkname-must-refer-to-declared-function-or-variable%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://www.silenceboy.com/2022/07/12/go语言1-18-go-linkname-must-refer-to-declared-function-or-variable解决办法/</id>
    <published>2022-07-12T06:13:58.000Z</published>
    <updated>2022-07-12T06:14:58.301Z</updated>
    
    <content type="html"><![CDATA[<p>在macos环境中，go1.18刚刚部署后，会报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">golang.org/x/sys/unix</span><br><span class="line"># golang.org/x/sys/unix</span><br><span class="line">vendor/golang.org/x/sys/unix/syscall_darwin.1_13.go:29:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_13.go:27:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_13.go:40:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:28:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:43:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:59:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:75:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:90:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:105:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:121:3: //go:linkname must refer to declared function or variable</span><br><span class="line">vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go:121:3: too many errors</span><br></pre></td></tr></table></figure><p>解决办法如下：</p><p>1.运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u golang.org/x/sys</span><br></pre></td></tr></table></figure><p>2.运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在macos环境中，go1.18刚刚部署后，会报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="go" scheme="https://www.silenceboy.com/categories/go/"/>
    
    
      <category term="go" scheme="https://www.silenceboy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>macbook如何卸载天空卫士</title>
    <link href="https://www.silenceboy.com/2022/05/20/macbook%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BD%E5%A4%A9%E7%A9%BA%E5%8D%AB%E5%A3%AB/"/>
    <id>https://www.silenceboy.com/2022/05/20/macbook如何卸载天空卫士/</id>
    <published>2022-05-20T06:07:27.000Z</published>
    <updated>2022-05-20T06:19:34.769Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>首先找到安装天空卫士的目录：<code>/Library/Application Support/SkyGuard</code></p></li><li><p>电脑关机，长按开机键直到进入recovery模式, 点自己的用户，输入密码，点下一步，然后到左上方找到终端打开</p></li><li><p>diskutil list 查看目前的磁盘, 找到标记有<code>synthesized</code>的磁盘，并找到对应的数据盘（有data关键字），这里假设为：<code>/dev/disk3s3</code></p></li><li><p>执行<code>diskutil mount /dev/disk3s3</code>, 可能会报 <code>this is an encrypted and locked APFS Volume</code>的错，根据提示执行：<code>diskutil apfs unlockVolume /dev/disk3s3</code>，然后输入密码。再次执行<code>diskutil mount /dev/disk3s3</code>即可。</p></li><li><p>进入<code>/Volumes/Macintosh HD/Library/Application Support</code>目录，可以看到有<code>SkyGuard</code>文件。</p></li><li><p>执行<code>rm -rf SkyGuard</code>删除天空位置文件目录</p></li><li><p><code>reboot</code>重启电脑，发现天空卫士已成功卸载</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先找到安装天空卫士的目录：&lt;code&gt;/Library/Application Support/SkyGuard&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;电脑关机，长按开机键直到进入recovery模式, 点自己的用户，输入密码，点下一步，然后到
      
    
    </summary>
    
      <category term="mac" scheme="https://www.silenceboy.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://www.silenceboy.com/tags/mac/"/>
    
      <category term="天空卫士" scheme="https://www.silenceboy.com/tags/%E5%A4%A9%E7%A9%BA%E5%8D%AB%E5%A3%AB/"/>
    
  </entry>
  
  <entry>
    <title>mac卸载jdk</title>
    <link href="https://www.silenceboy.com/2022/04/29/mac%E5%8D%B8%E8%BD%BDjdk/"/>
    <id>https://www.silenceboy.com/2022/04/29/mac卸载jdk/</id>
    <published>2022-04-29T09:25:19.000Z</published>
    <updated>2022-04-29T09:27:28.102Z</updated>
    
    <content type="html"><![CDATA[<ol><li>删除运行路径和运行环境等</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -fr /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class="line">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane</span><br><span class="line">sudo rm -fr ~/Library/Application\ Support/Java</span><br></pre></td></tr></table></figure><ol start="2"><li>删除当前版本的jdk</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk</span><br></pre></td></tr></table></figure><ol start="3"><li>检查是否卸载成功</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;删除运行路径和运行环境等&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="mac" scheme="https://www.silenceboy.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://www.silenceboy.com/tags/mac/"/>
    
      <category term="jdk" scheme="https://www.silenceboy.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>docker跨平台打包问题does not match the detected host platform</title>
    <link href="https://www.silenceboy.com/2022/04/29/docker%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98does-not-match-the-detected-host-platform/"/>
    <id>https://www.silenceboy.com/2022/04/29/docker跨平台打包问题does-not-match-the-detected-host-platform/</id>
    <published>2022-04-29T03:44:40.000Z</published>
    <updated>2022-04-29T03:56:38.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近在mac M1上构建的docker镜像，发布到ubuntu20系统的服务器上后，一直运行失败。输出以下报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The requested image&apos;s platform (linux/arm64) does not match the detected host platform (linux/amd64) and no specific platform was requested</span><br></pre></td></tr></table></figure><p>在使用docker logs 查看docker日志的时候提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:228: exec user process caused: exec format error​</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>mac M1上设置”experimental”: true </p><p><img src="/../images/docker.png" alt="docker.png"></p></li><li><p>实现跨平台打包</p><p> docker buildx build –platform linux/amd64 -t name .  </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近在mac M1上构建的docker镜像，发布到ubuntu20系统的服务器上后，一直运行失败。输出以下报错信息：&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="docker" scheme="https://www.silenceboy.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.silenceboy.com/tags/docker/"/>
    
      <category term="mac" scheme="https://www.silenceboy.com/tags/mac/"/>
    
      <category term="ubuntu" scheme="https://www.silenceboy.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>mac电脑M1芯片如何安装低版本node环境</title>
    <link href="https://www.silenceboy.com/2021/10/22/mac%E7%94%B5%E8%84%91M1%E8%8A%AF%E7%89%87%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E4%BD%8E%E7%89%88%E6%9C%ACnode%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.silenceboy.com/2021/10/22/mac电脑M1芯片如何安装低版本node环境/</id>
    <published>2021-10-22T09:15:17.000Z</published>
    <updated>2021-10-22T09:25:13.767Z</updated>
    
    <content type="html"><![CDATA[<p>在mac M1上安装v14 及以下的老版本 Node会出现闪退问题，究其原因还是因为低版本的 node 并不是基于 arm64 架构的，所以不适配 M1 芯片。在这里教大家两个方法，就能成功安装上低版本 Node。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在终端中，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch -x86_64 zsh</span><br></pre></td></tr></table></figure><p>通过这个命令可以让 shell 运行在Rosetta2下。<br>之后你可以通过 <code>nvm install v14</code> 来安装低版本 Node。<br>在此之后，您可以不用在 Rosetta2 中就可以使用安装的可执行文件，也就是说，您可以将 Node v15与其他节点版本互换使用。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>方法二就是通过 Rosetta2 来启动终端，这样通过 Rosetta2 转译到 x86 架构中执行安装，也一样可以安装成功。</p><ol><li>在 finder 中，点击应用程序，并在实用工具中找到终端 (Terminal)</li><li>右键终端，点击获取信息</li><li>勾选 Open using Rosetta</li><li>重启终端，并执行 <code>nvm install v14</code> 命令</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mac M1上安装v14 及以下的老版本 Node会出现闪退问题，究其原因还是因为低版本的 node 并不是基于 arm64 架构的，所以不适配 M1 芯片。在这里教大家两个方法，就能成功安装上低版本 Node。&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="nodejs" scheme="https://www.silenceboy.com/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="https://www.silenceboy.com/tags/nodejs/"/>
    
      <category term="mac" scheme="https://www.silenceboy.com/tags/mac/"/>
    
      <category term="M1" scheme="https://www.silenceboy.com/tags/M1/"/>
    
  </entry>
  
  <entry>
    <title>Arch linux i3wm运行企业微信和微信</title>
    <link href="https://www.silenceboy.com/2021/05/26/Arch-linux-i3wm%E8%BF%90%E8%A1%8C%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%92%8C%E5%BE%AE%E4%BF%A1/"/>
    <id>https://www.silenceboy.com/2021/05/26/Arch-linux-i3wm运行企业微信和微信/</id>
    <published>2021-05-26T14:05:02.000Z</published>
    <updated>2021-09-27T07:27:40.435Z</updated>
    
    <content type="html"><![CDATA[<p>当你运行在i3wm环境下时，运行通过deepin-wine安装的企业微信和微信时，打开软件时会出现闪退的现象，启动不了软件。或直接在命令行里执行命令也启动不了程序，会出现以下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X Error of failed request:  BadWindow (invalid Window parameter)</span><br><span class="line">  Major opcode of failed request:  20 (X_GetProperty)</span><br><span class="line">  Resource id in failed request:  0x0</span><br><span class="line">  Serial number of failed request:  10</span><br><span class="line">  Current serial number in output stream:  10</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><p>这个问题其实和 KDE 无关, 应该是 deepin 在打包 deepin-wine 的过程中有意或者无意加入了 GNOME 依赖。</p><p>执行 <code>/usr/lib/gnome-settings-daemon/gsd-xsettings</code> 即可.<br>或者后台运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/lib/gnome-settings-daemon/gsd-xsettings &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>如果 GNOME 的版本较低(比如Debian 9), 没有单独的 <code>gsd-xsettings</code> 可执行文件, 则执行 <code>gnome-settings-daemon</code>.</p><p>然后切换到对应目录 <code>cd /opt/deepinwine/apps/Deepin-WXWork</code> 或者 <code>/opt/deepinwine/apps/Deepin-WeChat</code><br>运行 <code>./run.sh</code>即可启动软件。</p><p>由于每次都执行上边的命令很繁琐，可以将其加入i3的启动项，每次开机制动设置即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你运行在i3wm环境下时，运行通过deepin-wine安装的企业微信和微信时，打开软件时会出现闪退的现象，启动不了软件。或直接在命令行里执行命令也启动不了程序，会出现以下提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="linux" scheme="https://www.silenceboy.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.silenceboy.com/tags/linux/"/>
    
      <category term="i3wm" scheme="https://www.silenceboy.com/tags/i3wm/"/>
    
      <category term="i3" scheme="https://www.silenceboy.com/tags/i3/"/>
    
  </entry>
  
</feed>
